<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript-原型和原型链</title>
      <link href="/2025/05/27/qian-duan/javascript-yuan-xing-he-yuan-xing-lian/"/>
      <url>/2025/05/27/qian-duan/javascript-yuan-xing-he-yuan-xing-lian/</url>
      
        <content type="html"><![CDATA[<h2 id="原型与原型链的理解"><a href="#原型与原型链的理解" class="headerlink" title="原型与原型链的理解"></a>原型与原型链的理解</h2><p><img src="/2025/05/27/qian-duan/javascript-yuan-xing-he-yuan-xing-lian/image-20250527130709416.png" alt="image-20250527130709416"></p><p>在 JavaScript 中，每个对象都有一个“隐藏属性”指向另一个对象，这个对象就是它的<strong>原型</strong>，我们可以通过 <code>__proto__</code> 来访问它。</p><p>例如：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = { <span class="attr">name</span>: <span class="string">'小明'</span> };</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>); <span class="comment">// [Object: null prototype] {...}</span></span><br></pre></td></tr></tbody></table></figure><p>这表示 <code>obj</code> 是通过 <code>Object</code> 构造函数创建的，它的原型是 <code>Object.prototype</code>。JavaScript 在访问对象的属性时，如果对象本身没有，就会从它的原型上找。</p><hr><h3 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h3><p>对象的 <code>__proto__</code> 属性（实际标准中叫 <code>[[Prototype]]</code>）会一直向上指向另一个对象，直到指向 <code>null</code> 为止，这条向上查找的路径就叫做<strong>原型链</strong>。</p><p>例子：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) {}</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Hi'</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">sayHi</span>(); <span class="comment">// Hi</span></span><br></pre></td></tr></tbody></table></figure><p>这里的查找过程是：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p → p.__proto__（Person.prototype）→ Person.prototype.__proto__（Object.prototype）→ null</span><br></pre></td></tr></tbody></table></figure><p>只要找到为止就停下来，如果链条末端也没有（即 <code>null</code>），就返回 <code>undefined</code>。</p><hr><h3 id="构造函数、prototype-和实例对象的关系"><a href="#构造函数、prototype-和实例对象的关系" class="headerlink" title="构造函数、prototype 和实例对象的关系"></a>构造函数、prototype 和实例对象的关系</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) {}</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br></pre></td></tr></tbody></table></figure><p>它们之间的关系可以总结为：</p><ul><li><code>dog.__proto__ === Animal.prototype</code></li><li><code>Animal.prototype.constructor === Animal</code></li></ul><p>这意味着构造函数通过 <code>.prototype</code> 定义了实例对象共享的属性或方法，实例对象通过 <code>__proto__</code> 访问到这些内容。</p><hr><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><ul><li>每个对象都有 <code>__proto__</code>，指向它的原型对象；</li><li>每个函数都有 <code>prototype</code>，创建出来的对象的 <code>__proto__</code> 就是这个 <code>prototype</code>；</li><li>对象的属性查找是沿着原型链逐级查找的；</li><li>原型链的尽头是 <code>null</code>。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并行&amp;并发&amp;线程&amp;进程</title>
      <link href="/2025/05/27/ji-suan-ji-wang-luo-ji-chu/bing-xing-bing-fa-xian-cheng-jin-cheng/"/>
      <url>/2025/05/27/ji-suan-ji-wang-luo-ji-chu/bing-xing-bing-fa-xian-cheng-jin-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="🧠-一句话理解："><a href="#🧠-一句话理解：" class="headerlink" title="🧠 一句话理解："></a>🧠 一句话理解：</h2><table><thead><tr><th>概念</th><th>一句话解释</th></tr></thead><tbody><tr><td>进程</td><td>一个正在运行的程序，是资源分配的基本单位。</td></tr><tr><td>线程</td><td>进程内的“执行路线”，是执行调度的基本单位。</td></tr><tr><td>并发</td><td>多个任务<strong>你一会我一会地执行</strong>，宏观上像是同时运行。</td></tr><tr><td>并行</td><td>多个任务<strong>真正在同一时间点一起执行</strong>，是硬件支持的结果。</td></tr></tbody></table><hr><h2 id="简单的比喻"><a href="#简单的比喻" class="headerlink" title="简单的比喻"></a>简单的比喻</h2><h3 id="👨‍🍳-进程-厨房"><a href="#👨‍🍳-进程-厨房" class="headerlink" title="👨‍🍳 进程 = 厨房"></a>👨‍🍳 <strong>进程 = 厨房</strong></h3><p>每个厨房是一个进程，里面有一套完整的厨具（资源），能独立做饭。</p><h3 id="🧍‍♂️-线程-厨师"><a href="#🧍‍♂️-线程-厨师" class="headerlink" title="🧍‍♂️ 线程 = 厨师"></a>🧍‍♂️ <strong>线程 = 厨师</strong></h3><p>一个厨房里可以有一个或多个厨师，每个厨师负责做一道菜，他们共享厨房资源（锅、刀）。</p><h3 id="🔁-并发-一个厨师做多道菜"><a href="#🔁-并发-一个厨师做多道菜" class="headerlink" title="🔁 并发 = 一个厨师做多道菜"></a>🔁 <strong>并发 = 一个厨师做多道菜</strong></h3><p>比如一个厨师边炒菜边煲汤，轮流去照看它们。<strong>看上去两道菜同时在做，其实是轮流做</strong>。</p><h3 id="🧑‍🍳🧑‍🍳-并行-多个厨师同时做菜"><a href="#🧑‍🍳🧑‍🍳-并行-多个厨师同时做菜" class="headerlink" title="🧑‍🍳🧑‍🍳 并行 = 多个厨师同时做菜"></a>🧑‍🍳🧑‍🍳 <strong>并行 = 多个厨师同时做菜</strong></h3><p>多个厨师每人做一道菜，<strong>真的同时在干活</strong>。</p><hr><h2 id="💻-计算机知识！"><a href="#💻-计算机知识！" class="headerlink" title="💻 计算机知识！"></a>💻 计算机知识！</h2><h3 id="✅-进程（Process）"><a href="#✅-进程（Process）" class="headerlink" title="✅ 进程（Process）"></a>✅ <strong>进程（Process）</strong></h3><ul><li>每个运行的程序就是一个进程。</li><li>每个进程有自己独立的内存空间、变量、文件描述符等资源。</li><li>比如你开了两个微信、一个浏览器，是三个进程。</li></ul><hr><h3 id="✅-线程（Thread）"><a href="#✅-线程（Thread）" class="headerlink" title="✅ 线程（Thread）"></a>✅ <strong>线程（Thread）</strong></h3><ul><li>是进程内的一个执行单元。</li><li>一个进程可以有多个线程，这些线程<strong>共享进程的资源</strong>。</li><li>比如浏览器的主线程负责 UI 渲染，其他线程可能处理网络请求、JS 执行等。</li></ul><hr><h3 id="✅-并发（Concurrency）"><a href="#✅-并发（Concurrency）" class="headerlink" title="✅ 并发（Concurrency）"></a>✅ <strong>并发（Concurrency）</strong></h3><ul><li>“在同一时间段内交替执行多个任务”。</li><li>比如单核 CPU，通过操作系统快速切换线程实现多个任务。</li><li><strong>线程看起来一起跑，实际上是轮流跑（交替）</strong>。</li></ul><hr><h3 id="✅-并行（Parallelism）"><a href="#✅-并行（Parallelism）" class="headerlink" title="✅ 并行（Parallelism）"></a>✅ <strong>并行（Parallelism）</strong></h3><ul><li>多个任务在<strong>同一时刻真正一起运行</strong>。</li><li>比如多核 CPU，每个核都跑一个线程。</li></ul><hr><h2 id="🧪-一个常见误区："><a href="#🧪-一个常见误区：" class="headerlink" title="🧪 一个常见误区："></a>🧪 一个常见误区：</h2><blockquote><p>❓ 并发 = 并行 吗？</p></blockquote><p><strong>不是！</strong></p><table><thead><tr><th>并发</th><th>并行</th></tr></thead><tbody><tr><td>强调“逻辑上同时”</td><td>强调“物理上同时”</td></tr><tr><td>一个人伪装多个任务</td><td>多个人真在干不同任务</td></tr><tr><td>单核 CPU 可实现</td><td>多核 CPU 才能实现</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域&amp;同源</title>
      <link href="/2025/05/26/ji-suan-ji-wang-luo-ji-chu/kua-yu-tong-yuan/"/>
      <url>/2025/05/26/ji-suan-ji-wang-luo-ji-chu/kua-yu-tong-yuan/</url>
      
        <content type="html"><![CDATA[<h2 id="同源-跨域"><a href="#同源-跨域" class="headerlink" title="同源&amp;跨域"></a>同源&amp;跨域</h2><h3 id="🔒-同源策略（Same-Origin-Policy）"><a href="#🔒-同源策略（Same-Origin-Policy）" class="headerlink" title="🔒 同源策略（Same-Origin Policy）"></a>🔒 同源策略（Same-Origin Policy）</h3><p>浏览器的安全机制，<strong>限制 JS 对不同源资源的访问</strong>。判断是否同源需满足：<strong>协议、域名、端口号相同</strong>。</p><p>示例：</p><table><thead><tr><th>页面地址</th><th>资源地址</th><th>是否同源</th><th>🚨原因</th></tr></thead><tbody><tr><td><code>http://a.com:80</code></td><td><code>http://a.com:80</code></td><td>✅</td><td>完全相同</td></tr><tr><td><code>http://a.com</code></td><td><code>https://a.com</code></td><td>❌</td><td>协议不同</td></tr><tr><td><code>http://a.com</code></td><td><code>http://b.com</code></td><td>❌</td><td>域名不同</td></tr><tr><td><code>http://a.com:80</code></td><td><code>http://a.com:8080</code></td><td>❌</td><td>端口不同</td></tr></tbody></table><hr><h3 id="🚫-哪些操作会被限制？"><a href="#🚫-哪些操作会被限制？" class="headerlink" title="🚫 哪些操作会被限制？"></a>🚫 哪些操作会被限制？</h3><ul><li>JS 发起的 <code>fetch</code> / <code>XMLHttpRequest</code> 跨域请求</li><li>访问 <code>localStorage</code>、<code>cookie</code> 等数据</li><li>iframe 跨域访问父/子页面 DOM</li></ul><hr><h3 id="🌐-什么是跨域？"><a href="#🌐-什么是跨域？" class="headerlink" title="🌐 什么是跨域？"></a>🌐 什么是跨域？</h3><p><strong>浏览器阻止你访问不同源资源</strong>时，就发生了跨域。<br> 非同源访问资源（如 Ajax 请求）默认会被浏览器拦截。</p><hr><h3 id="简单请求与复杂请求"><a href="#简单请求与复杂请求" class="headerlink" title="简单请求与复杂请求"></a>简单请求与复杂请求</h3><p>浏览器把跨域请求分为两类：</p><h4 id="✅-简单请求（不会发送预检）"><a href="#✅-简单请求（不会发送预检）" class="headerlink" title="✅ 简单请求（不会发送预检）"></a>✅ 简单请求（不会发送预检）</h4><p>同时满足以下三个条件：</p><ol><li>方法是 <code>GET</code>、<code>POST</code> 或 <code>HEAD</code></li><li>请求头 <strong>仅限于</strong>：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Type</code>（值仅限于：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）</li><li><strong>没有自定义请求头</strong></li></ol><h4 id="⚠️-复杂请求（会先发送预检-OPTIONS-请求）"><a href="#⚠️-复杂请求（会先发送预检-OPTIONS-请求）" class="headerlink" title="⚠️ 复杂请求（会先发送预检 OPTIONS 请求）"></a>⚠️ 复杂请求（会先发送预检 OPTIONS 请求）</h4><p>只要<strong>满足以下任意一项</strong>，就属于复杂请求：</p><ul><li>方法为 <code>PUT</code>、<code>DELETE</code> 等非 GET/POST/HEAD</li><li>请求头中有<strong>自定义 Header</strong>（如 <code>X-Token</code>）</li><li><code>Content-Type</code> 为 <code>application/json</code> 等非简单类型</li><li>使用了 <code>XMLHttpRequest.withCredentials = true</code>（携带 cookie）</li></ul><p><strong>🔁 流程：</strong></p><ol><li>浏览器先发 <code>OPTIONS</code> 请求询问服务器是否允许</li><li>服务器返回 <code>Access-Control-Allow-*</code> 系列响应头，表示允许</li><li>浏览器才会发起真正的请求</li></ol><blockquote><p>⛔ 若预检失败（服务器未正确设置允许跨域），正式请求不会被发送</p></blockquote><hr><h4 id="🔁-预检请求长这样（由浏览器自动发出）："><a href="#🔁-预检请求长这样（由浏览器自动发出）：" class="headerlink" title="🔁 预检请求长这样（由浏览器自动发出）："></a>🔁 预检请求长这样（由浏览器自动发出）：</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">httpCopyEditOPTIONS /user HTTP/1.1</span><br><span class="line">Origin: https://web.example.com</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: Content-Type</span><br></pre></td></tr></tbody></table></figure><p>服务端响应应如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">httpCopyEditHTTP/1.1 204 No Content</span><br><span class="line">Access-Control-Allow-Origin: https://web.example.com</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">Access-Control-Allow-Headers: Content-Type</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="✅-CORS：主流跨域解决方案"><a href="#✅-CORS：主流跨域解决方案" class="headerlink" title="✅ CORS：主流跨域解决方案"></a>✅ CORS：主流跨域解决方案</h3><p>服务端返回特殊响应头，告诉浏览器“我允许你跨域访问”：</p><p>示例：</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>https://your-frontend.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>Content-Type</span><br></pre></td></tr></tbody></table></figure><p>通配符允许所有：</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="🧪-跨域开发常见解决方案"><a href="#🧪-跨域开发常见解决方案" class="headerlink" title="🧪 跨域开发常见解决方案"></a>🧪 跨域开发常见解决方案</h3><table><thead><tr><th>方式</th><th>说明</th></tr></thead><tbody><tr><td>✅ CORS</td><td>服务端设置响应头（最推荐）</td></tr><tr><td>🌀 代理转发</td><td>本地开发用 <code>webpack devServer</code> 或 Nginx 转发</td></tr><tr><td>📜 JSONP</td><td>只支持 GET，已过时</td></tr><tr><td>📨 postMessage</td><td>iframe/窗口间通信方案</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-异步</title>
      <link href="/2025/05/25/qian-duan/javascript-yao-dian/"/>
      <url>/2025/05/25/qian-duan/javascript-yao-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>JavaScript 是单线程的，意味着它一次只能执行一个任务。如果遇到耗时操作（如网络请求），程序会“阻塞”，导致页面卡顿。为了解决这个问题，JavaScript 使用<strong>异步编程</strong>，让耗时操作在后台执行，同时继续执行其他代码。</p><h4 id="异步的特点："><a href="#异步的特点：" class="headerlink" title="异步的特点："></a>异步的特点：</h4><ul><li>不会阻塞后续代码的执行。</li><li>耗时操作完成后，通过回调函数、Promise 或 async/await 来处理结果。</li></ul><p>也就是实现异步编程有 3 种方法：回调函数、Promise 或 async/await </p><blockquote><p>回调函数容易出现”回调地狱”的情况，所以目前不怎么依赖它来实现异步编程，我们简单介绍即可</p></blockquote><hr><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数本质就是一个函数，只是把它作为参数传递给了另一个函数，并在某个操作完成后被调用。回调函数的核心思想是：</p><ul><li><strong>延迟执行</strong>：在某个条件满足或某个操作完成后，才执行这个函数。</li><li><strong>异步处理</strong>：常用于处理异步操作的结果。</li></ul><p>示例：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义一个回调函数（取餐后的动作）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">takeFood</span>(<span class="params">food</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"取餐："</span> + food);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义一个函数（点餐）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">orderFood</span>(<span class="params">callback</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"点餐：汉堡"</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="keyword">const</span> food = <span class="string">"汉堡"</span>;</span><br><span class="line">        <span class="title function_">callback</span>(food); <span class="comment">// 3秒后调用回调函数</span></span><br><span class="line">    }, <span class="number">3000</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 点餐，并告诉服务员取餐时调用 takeFood 函数</span></span><br><span class="line"><span class="title function_">orderFood</span>(takeFood);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 继续做其他事情</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"等待取餐中，先玩手机..."</span>);</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">点餐：汉堡</span><br><span class="line">等待取餐中，先玩手机...</span><br><span class="line">取餐：汉堡</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>本质上 Promise 是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了,它表示一个异步操作的最终完成（或失败）及其结果值。你可以把它理解为一个“承诺”：</p><ul><li><strong>承诺</strong>：将来会完成某个操作（成功或失败）</li><li><strong>结果</strong>：操作完成后，会返回一个值（或错误）</li></ul><h3 id="Promise-的三种状态"><a href="#Promise-的三种状态" class="headerlink" title="Promise 的三种状态"></a><strong>Promise 的三种状态</strong></h3><p>一个 Promise 对象有三种状态：</p><ol><li><strong>Pending（进行中）</strong>：初始状态，表示操作尚未完成。</li><li><strong>Fulfilled（已成功）</strong>：表示操作成功完成，并返回结果值。</li><li><strong>Rejected（已失败）</strong>：表示操作失败，并返回错误原因。</li></ol><p>一旦 Promise 的状态从 Pending 变为 Fulfilled 或 Rejected，就不可再改变。</p><h3 id="then"><a href="#then" class="headerlink" title="then()"></a>then()</h3><p><code>.then()</code> 是 <strong>Promise</strong> 对象的一个方法，用于处理 Promise 成功完成后的结果。它是 JavaScript 中实现异步编程的核心工具之一，让代码更清晰、更易读</p><h4 id="then-的作用"><a href="#then-的作用" class="headerlink" title=".then() 的作用"></a><strong><code>.then()</code> 的作用</strong></h4><ul><li><strong>处理成功的结果</strong>：当 Promise 的状态从 Pending 变为 Fulfilled（即成功）时，<code>.then()</code> 中的回调函数会被调用。</li><li><strong>链式调用</strong>：<code>.then()</code> 返回一个新的 Promise，可以继续调用下一个 <code>.then()</code>，从而实现多个异步操作的顺序执行。</li></ul><h4 id="then-的语法"><a href="#then-的语法" class="headerlink" title=".then()的语法"></a>.then()的语法</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected);</span><br></pre></td></tr></tbody></table></figure><ul><li>**<code>onFulfilled</code>**：一个回调函数，当 Promise 成功时调用。它接受一个参数，即 Promise 的成功结果。</li><li>**<code>onRejected</code>**（可选）：一个回调函数，当 Promise 失败时调用。它接受一个参数，即 Promise 的失败原因。</li></ul><p>通常，我们只使用 <code>onFulfilled</code>，而用 <code>.catch()</code> 来处理失败的情况。</p><p>链式调用-示例：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">"第一步结果"</span>), <span class="number">1000</span>);</span><br><span class="line">  });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomethingElse</span>(<span class="params">result</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result + <span class="string">" -&gt; 第二步结果"</span>), <span class="number">1000</span>);</span><br><span class="line">  });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doThirdThing</span>(<span class="params">result</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result + <span class="string">" -&gt; 第三步结果"</span>), <span class="number">1000</span>);</span><br><span class="line">  });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">failureCallback</span>(<span class="params">error</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">"出错："</span>, error);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">doSomethingElse</span>(result);</span><br><span class="line">  })</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">newResult</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">doThirdThing</span>(newResult);</span><br><span class="line">  })</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">finalResult</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`得到最终结果：<span class="subst">${finalResult}</span>`</span>);</span><br><span class="line">  })</span><br><span class="line">  .<span class="title function_">catch</span>(failureCallback);</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">得到最终结果：第一步结果 -&gt; 第二步结果 -&gt; 第三步结果</span><br></pre></td></tr></tbody></table></figure><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async<code>/</code>await</h2><p>async/await 是 JavaScript 中用于简化异步编程的<strong>语法糖</strong>。它基于 Promise，但让异步代码的写法更像同步代码，从而更容易理解和维护。</p><p><strong>async</strong>：用于声明一个异步函数。异步函数会隐式返回一个 Promise</p><p><strong>await</strong>：用于等待一个 Promise 完成（即 Promise 的状态变为 resolved）。await 只能在 async 函数中使用</p><p>promise章节中的代码用async<code>/</code>await简写如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">async function main() {</span><br><span class="line">  try {</span><br><span class="line">    const result1 = await doSomething(); // 等待第一步完成</span><br><span class="line">    const result2 = await doSomethingElse(result1); // 等待第二步完成</span><br><span class="line">    const finalResult = await doThirdThing(result2); // 等待第三步完成</span><br><span class="line">    console.log(`得到最终结果：${finalResult}`);</span><br><span class="line">  } catch (error) {</span><br><span class="line">    failureCallback(error); // 捕获错误</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 调用 main 函数</span><br><span class="line">main();</span><br></pre></td></tr></tbody></table></figure><blockquote><p>💡关于语法糖<br>不改变语言的功能：语法糖只是提供了一种更简洁的写法，底层实现仍然是原有的语法或机制。</p><p>提高代码的可读性：语法糖通常会让代码更直观、更易理解。</p><p>减少代码量：语法糖可以帮助开发者用更少的代码实现相同的功能。</p></blockquote><hr><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是指一个函数能够“记住”并访问它定义时的环境，即使这个函数在定义时的环境之外执行。即 <code>闭包 = 函数 + 引用环境</code></p><h3 id="闭包的核心"><a href="#闭包的核心" class="headerlink" title="闭包的核心"></a>闭包的核心</h3><ol><li><p><strong>函数嵌套</strong>：</p><ul><li>闭包通常发生在函数嵌套的情况下，即一个函数内部定义了另一个函数。</li></ul></li><li><p><strong>访问外部变量</strong>：</p><ul><li>内部函数可以访问外部函数的变量，即使外部函数已经执行完毕。</li></ul></li><li><p><strong>“记住”环境</strong>：</p><ul><li>闭包会“记住”它定义时的环境（即外部函数的作用域），即使外部函数已经执行完毕。</li></ul></li></ol><p>示例 1：简单的闭包</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">"Hello, Closure!"</span>; <span class="comment">// 外部函数的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// 内部函数访问外部函数的变量</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner; <span class="comment">// 返回内部函数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> innerFunc = <span class="title function_">outer</span>(); <span class="comment">// outer 执行完毕</span></span><br><span class="line"><span class="title function_">innerFunc</span>(); <span class="comment">// 输出: Hello, Closure!</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>outer</code> 函数内部有一个变量 <code>message</code>。</li><li><code>inner</code> 函数使用了 <code>message</code>。</li><li>即使 <code>outer</code> 函数执行完毕，<code>inner</code> 函数仍然可以访问 <code>message</code>，这就是闭包。</li></ul><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ol><li><p><strong>记住变量</strong>：</p><ul><li>闭包可以让函数“记住”它定义时的变量，即使外部函数已经执行完毕。</li></ul></li><li><p><strong>创建私有变量</strong>：</p><ul><li>闭包可以用来隐藏变量，避免被外部直接修改。</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name</span>) {</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">0</span>; <span class="comment">// 私有变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">getAge</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">celebrateBirthday</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">            age++;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="title function_">createPerson</span>(<span class="string">"Alice"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// 输出: Alice</span></span><br><span class="line">person.<span class="title function_">celebrateBirthday</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getAge</span>()); <span class="comment">// 输出: 1</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>实现模块化</strong>：</p><ul><li>闭包可以用来隐藏内部实现细节，只暴露必要的功能。</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = (<span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> privateVariable = <span class="string">"I am private"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">        <span class="attr">publicMethod</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(privateVariable);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">})();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="title function_">publicMethod</span>(); <span class="comment">// 输出: I am private</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="闭包的注意事项"><a href="#闭包的注意事项" class="headerlink" title="闭包的注意事项"></a>闭包的注意事项</h3><ol><li><strong>内存泄漏</strong>：<ul><li>闭包会一直“记住”外部函数的变量，即使这些变量已经不再需要了。如果闭包用得太多，可能会导致内存占用过高。</li><li>解决方法：在不需要时手动解除引用。</li></ul></li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) {</span><br><span class="line">    <span class="keyword">const</span> largeData = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">fill</span>(<span class="string">"data"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Closure!"</span>);</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> innerFunc = <span class="title function_">outer</span>();</span><br><span class="line"><span class="comment">// 不再需要时解除引用</span></span><br><span class="line">innerFunc = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="🖥️-JavaScript的单线程和异步并发原理"><a href="#🖥️-JavaScript的单线程和异步并发原理" class="headerlink" title="🖥️ JavaScript的单线程和异步并发原理"></a>🖥️ JavaScript的单线程和异步并发原理</h1><h2 id="1-JavaScript是单线程的"><a href="#1-JavaScript是单线程的" class="headerlink" title="1. JavaScript是单线程的"></a>1. <strong>JavaScript是单线程的</strong></h2><ul><li>只有一个执行线程（主线程）执行代码，任何时刻只能执行一个任务。</li><li>这就意味着，代码是<strong>逐行执行</strong>，同步任务一个接一个。</li></ul><hr><h2 id="2-为什么需要异步？"><a href="#2-为什么需要异步？" class="headerlink" title="2. 为什么需要异步？"></a>2. <strong>为什么需要异步？</strong></h2><ul><li>有些操作耗时，比如网络请求、文件读取、定时器。</li><li>如果这些操作都是同步执行，JS主线程会被堵塞，页面卡死。</li><li>所以引入<strong>异步机制</strong>，避免阻塞，提升用户体验。</li></ul><hr><h2 id="3-事件循环（Event-Loop）机制"><a href="#3-事件循环（Event-Loop）机制" class="headerlink" title="3. 事件循环（Event Loop）机制"></a>3. <strong>事件循环（Event Loop）机制</strong></h2><p>核心就是：</p><ul><li>主线程有一个任务栈（Call Stack），同步任务进栈执行，执行完出栈。</li><li>异步任务（比如setTimeout、Promise等）会被放入<strong>任务队列</strong>（Task Queue / Microtask Queue）。</li><li>事件循环不断检查任务栈是否为空，空了就去任务队列里取任务执行。</li></ul><hr><h2 id="4-任务队列分两种"><a href="#4-任务队列分两种" class="headerlink" title="4. 任务队列分两种"></a>4. <strong>任务队列分两种</strong></h2><ul><li><strong>宏任务（Macrotasks）</strong>：setTimeout、setInterval、I/O、UI渲染等。</li><li><strong>微任务（Microtasks）</strong>：Promise的.then/catch/finally，MutationObserver等。</li></ul><p>事件循环的规则：</p><ol><li>执行主线程的同步代码（任务栈）。</li><li>主线程空了，执行所有微任务队列里的任务。</li><li>微任务清空后，执行一个宏任务。</li><li>重复以上步骤。</li></ol><hr><h2 id="5-并发效果但不是并行"><a href="#5-并发效果但不是并行" class="headerlink" title="5. 并发效果但不是并行"></a>5. <strong>并发效果但不是并行</strong></h2><p>虽然只有一个线程，异步任务通过事件循环机制，实现了<strong>逻辑上的并发</strong>：</p><ul><li>你发起多个异步请求，浏览器会帮你管理它们。</li><li>JS主线程不等待结果，继续执行其他代码。</li><li>异步操作完成后，回调函数排入任务队列，等待主线程空闲时执行。</li></ul><p>所以，看起来是“多个任务同时进行”，其实是“任务轮流执行”，这就是<strong>并发</strong>，而不是硬件层面的<strong>并行</strong>。</p><hr><h2 id="6-举例说明"><a href="#6-举例说明" class="headerlink" title="6. 举例说明"></a>6. <strong>举例说明</strong></h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'timeout'</span>);</span><br><span class="line">}, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'promise'</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'end'</span>);</span><br></pre></td></tr></tbody></table></figure><p>执行顺序是：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise</span><br><span class="line">timeout</span><br></pre></td></tr></tbody></table></figure><ul><li><code>console.log('start')</code> 同步执行。</li><li><code>setTimeout</code> 的回调是宏任务，先放到宏任务队列。</li><li><code>Promise.then</code> 的回调是微任务，放到微任务队列。</li><li><code>console.log('end')</code> 同步执行。</li><li>主线程空了，先执行所有微任务（打印 ‘promise’）。</li><li>再执行宏任务（打印 ‘timeout’）。</li></ul><hr><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. <strong>总结</strong></h2><table><thead><tr><th>术语</th><th>JS中体现</th></tr></thead><tbody><tr><td>单线程</td><td>JS只有一个主执行线程</td></tr><tr><td>并发</td><td>异步任务通过事件循环交替执行</td></tr><tr><td>并行</td><td>需要多核CPU或Web Worker支持</td></tr><tr><td>事件循环</td><td>管理同步/异步任务的执行顺序</td></tr><tr><td>微任务/宏任务队列</td><td>按优先级执行异步回调</td></tr></tbody></table><hr><h2 id="进阶内容之-Web-Worker-——-JavaScript的多线程实现"><a href="#进阶内容之-Web-Worker-——-JavaScript的多线程实现" class="headerlink" title="进阶内容之 Web Worker —— JavaScript的多线程实现"></a>进阶内容之 Web Worker —— JavaScript的多线程实现</h2><h3 id="1-什么是-Web-Worker？"><a href="#1-什么是-Web-Worker？" class="headerlink" title="1. 什么是 Web Worker？"></a>1. 什么是 Web Worker？</h3><ul><li>Web Worker 是浏览器提供的 <strong>后台线程</strong>，可以在主线程之外运行脚本。</li><li>这样，耗时的计算或任务不会阻塞页面主线程，提升性能和用户体验。</li><li>主线程和 Worker 线程是 <strong>独立的线程</strong>，它们之间通过消息传递通信。</li></ul><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li><strong>Web Worker</strong> 是浏览器给JavaScript的“多线程”支持，帮助实现并行。</li><li>主线程和 Worker 线程相互独立，通过消息传递交流。</li><li>解决了 JS 单线程阻塞的问题，提升性能和响应速度。</li></ul><hr><h3 id="2-为什么需要-Web-Worker？"><a href="#2-为什么需要-Web-Worker？" class="headerlink" title="2. 为什么需要 Web Worker？"></a>2. 为什么需要 Web Worker？</h3><ul><li>JavaScript 本身是单线程，耗时任务（大计算、复杂数据处理）会阻塞UI，导致页面卡顿。</li><li>使用 Web Worker，可以把耗时任务放到后台线程，主线程继续响应用户操作。</li></ul><hr><h3 id="3-Web-Worker-的基本用法"><a href="#3-Web-Worker-的基本用法" class="headerlink" title="3. Web Worker 的基本用法"></a>3. Web Worker 的基本用法</h3><h4 id="主线程代码（main-js）"><a href="#主线程代码（main-js）" class="headerlink" title="主线程代码（main.js）"></a>主线程代码（main.js）</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsCopy code// 创建一个Worker，指定运行的脚本文件worker.js</span><br><span class="line">const worker = new Worker('worker.js');</span><br><span class="line"></span><br><span class="line">// 监听Worker发送来的消息</span><br><span class="line">worker.onmessage = function(event) {</span><br><span class="line">  console.log('从worker收到消息:', event.data);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// 向Worker发送消息</span><br><span class="line">worker.postMessage('开始计算');</span><br></pre></td></tr></tbody></table></figure><hr><h4 id="Worker线程代码（worker-js）"><a href="#Worker线程代码（worker-js）" class="headerlink" title="Worker线程代码（worker.js）"></a>Worker线程代码（worker.js）</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jsCopy code// 监听主线程发送的消息</span><br><span class="line">onmessage = function(event) {</span><br><span class="line">  console.log('Worker收到消息:', event.data);</span><br><span class="line"></span><br><span class="line">  // 执行一些耗时计算，比如大循环</span><br><span class="line">  let count = 0;</span><br><span class="line">  for (let i = 0; i &lt; 1e9; i++) {</span><br><span class="line">    count += i;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // 计算完，向主线程发送结果</span><br><span class="line">  postMessage('计算完成，结果是：' + count);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="4-Web-Worker-的特点"><a href="#4-Web-Worker-的特点" class="headerlink" title="4. Web Worker 的特点"></a>4. Web Worker 的特点</h3><ul><li>运行在独立线程，拥有自己的运行环境。</li><li>不能访问 DOM 和全局变量，只能通过消息通信。</li><li>只能用有限的API（比如不能直接操作window、document）。</li><li>适合做大量计算、数据处理、图像处理等。</li></ul><hr><h3 id="5-Web-Worker-vs-主线程"><a href="#5-Web-Worker-vs-主线程" class="headerlink" title="5. Web Worker vs 主线程"></a>5. Web Worker vs 主线程</h3><table><thead><tr><th>比较项</th><th>主线程</th><th>Web Worker</th></tr></thead><tbody><tr><td>线程数</td><td>单线程</td><td>独立多线程</td></tr><tr><td>DOM访问</td><td>可以直接访问DOM</td><td>不能访问DOM，只能通信</td></tr><tr><td>阻塞风险</td><td>大量计算会阻塞UI</td><td>不阻塞UI，后台运行</td></tr><tr><td>通信方式</td><td>直接操作变量/函数</td><td>通过 <code>postMessage</code> 传递消息</td></tr><tr><td>使用场景</td><td>UI渲染、事件响应</td><td>复杂计算、数据处理</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web相关-计网知识</title>
      <link href="/2025/05/25/ji-suan-ji-wang-luo-ji-chu/postweb-xiang-guan-ji-wang-zhi-shi/"/>
      <url>/2025/05/25/ji-suan-ji-wang-luo-ji-chu/postweb-xiang-guan-ji-wang-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="🌐-浏览器输入-URL-后发生了什么？"><a href="#🌐-浏览器输入-URL-后发生了什么？" class="headerlink" title="🌐 浏览器输入 URL 后发生了什么？"></a>🌐 浏览器输入 URL 后发生了什么？</h2><hr><h3 id="⛓️-一、URL-解析"><a href="#⛓️-一、URL-解析" class="headerlink" title="⛓️ 一、URL 解析"></a>⛓️ 一、URL 解析</h3><ol><li><p>浏览器解析你输入的 URL（统一资源定位符）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com:443/path?query=abc#hash</span><br></pre></td></tr></tbody></table></figure><ul><li>协议（Scheme）：<code>https</code></li><li>主机名（Host）：<code>www.example.com</code></li><li>端口（Port）：默认443（HTTPS）</li><li>路径（Path）：<code>/path</code></li><li>查询参数（Query）：<code>query=abc</code></li><li>锚点（Hash）：<code>#hash</code>（客户端用，不发送给服务器）</li></ul></li></ol><hr><h3 id="🌍-二、DNS-解析（域名解析）"><a href="#🌍-二、DNS-解析（域名解析）" class="headerlink" title="🌍 二、DNS 解析（域名解析）"></a>🌍 二、DNS 解析（域名解析）</h3><ul><li>浏览器 → 系统 → 本地 DNS 缓存 → hosts 文件 → DNS 服务器</li><li>将 <code>www.example.com</code> 解析为 IP 地址，如 <code>93.184.216.34</code></li></ul><hr><h3 id="🔐-三、建立连接"><a href="#🔐-三、建立连接" class="headerlink" title="🔐 三、建立连接"></a>🔐 三、建立连接</h3><h4 id="情况一：HTTP"><a href="#情况一：HTTP" class="headerlink" title="情况一：HTTP"></a>情况一：HTTP</h4><ul><li>使用 TCP 三次握手，建立连接。</li></ul><h4 id="情况二：HTTPS"><a href="#情况二：HTTPS" class="headerlink" title="情况二：HTTPS"></a>情况二：HTTPS</h4><ul><li>先进行 TCP 三次握手。</li><li>然后进行 TLS/SSL 握手，协商加密算法、交换证书、公钥，建立「安全连接」。</li></ul><hr><h3 id="📤-四、发送-HTTP-请求"><a href="#📤-四、发送-HTTP-请求" class="headerlink" title="📤 四、发送 HTTP 请求"></a>📤 四、发送 HTTP 请求</h3><p>浏览器构造并发送请求报文：</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/path?query=abc</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Chrome/123.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="📥-五、服务器处理请求"><a href="#📥-五、服务器处理请求" class="headerlink" title="📥 五、服务器处理请求"></a>📥 五、服务器处理请求</h3><ul><li>Web 服务器（如 Nginx、Apache、Node.js）接收请求。</li><li>应用服务器处理路径和参数，例如调后端接口、数据库。</li><li>返回 HTTP 响应，可能包含 HTML 页面、JSON 数据或其他资源。</li></ul><hr><h3 id="📨-六、浏览器接收响应"><a href="#📨-六、浏览器接收响应" class="headerlink" title="📨 六、浏览器接收响应"></a>📨 六、浏览器接收响应</h3><p>服务器返回响应：</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1234</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span>...<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><hr><h3 id="🖼️-七、浏览器渲染页面"><a href="#🖼️-七、浏览器渲染页面" class="headerlink" title="🖼️ 七、浏览器渲染页面"></a>🖼️ 七、浏览器渲染页面</h3><ol><li><strong>解析 HTML，构建 DOM 树</strong></li><li><strong>下载 CSS → 构建 CSSOM 树</strong></li><li><strong>执行 JavaScript 脚本</strong></li><li><strong>构建 Render Tree（渲染树）</strong></li><li><strong>计算布局（Layout）</strong></li><li><strong>绘制页面（Paint）</strong></li><li>用户看到完整网页</li></ol><hr><h3 id="📦-八、可能的额外动作"><a href="#📦-八、可能的额外动作" class="headerlink" title="📦 八、可能的额外动作"></a>📦 八、可能的额外动作</h3><ul><li>浏览器发送资源请求（如 CSS、JS、图片等）</li><li>Cookie 存取、Session 校验</li><li>缓存策略（如强缓存、协商缓存）</li><li>CORS 跨域校验</li><li>数据预加载等</li></ul><hr><h2 id="🧠-总结一句话："><a href="#🧠-总结一句话：" class="headerlink" title="🧠 总结一句话："></a>🧠 总结一句话：</h2><blockquote><p>输入 URL → DNS 解析 → 建立连接（TCP/TLS）→ 发送请求 → 服务器响应 → 浏览器渲染 → 展示页面</p></blockquote><hr><h2 id="跨域同源策略"><a href="#跨域同源策略" class="headerlink" title="跨域同源策略"></a>跨域同源策略</h2><h3 id="🔒-什么是同源策略（Same-Origin-Policy-SOP）"><a href="#🔒-什么是同源策略（Same-Origin-Policy-SOP）" class="headerlink" title="🔒 什么是同源策略（Same-Origin Policy, SOP）"></a>🔒 什么是同源策略（Same-Origin Policy, SOP）</h3><p><strong>同源策略</strong>是浏览器的一种安全机制，<strong>限制不同源的网页之间的交互</strong>，以防止恶意网站窃取敏感信息。</p><h4 id="📌-什么是“同源”？"><a href="#📌-什么是“同源”？" class="headerlink" title="📌 什么是“同源”？"></a>📌 什么是“同源”？</h4><p>两个 URL 的协议、域名、端口 <strong>完全相同</strong>，才称为同源：</p><p>例如：</p><table><thead><tr><th>URL</th><th>是否同源</th><th>说明</th></tr></thead><tbody><tr><td><code>https://example.com</code></td><td>✅ 同源</td><td>完全一致</td></tr><tr><td><code>http://example.com</code></td><td>❌ 跨源</td><td>协议不同</td></tr><tr><td><code>https://sub.example.com</code></td><td>❌ 跨源</td><td>子域名不同</td></tr><tr><td><code>https://example.com:8080</code></td><td>❌ 跨源</td><td>端口不同</td></tr></tbody></table><hr><h3 id="🚫-同源策略的限制内容"><a href="#🚫-同源策略的限制内容" class="headerlink" title="🚫 同源策略的限制内容"></a>🚫 同源策略的限制内容</h3><p>浏览器中，如果两个页面 <strong>非同源</strong>，则受限制：</p><table><thead><tr><th>受限制的内容</th><th>说明</th></tr></thead><tbody><tr><td>DOM 访问</td><td>JS 不能访问另一个源页面的 DOM</td></tr><tr><td>Cookie/LocalStorage</td><td>不能读写其他源的 cookie 和本地存储</td></tr><tr><td>AJAX 请求</td><td>JS 不能用 <code>XMLHttpRequest</code>/<code>fetch</code> 访问其他源的接口</td></tr></tbody></table><hr><h3 id="🔁-什么是跨域？"><a href="#🔁-什么是跨域？" class="headerlink" title="🔁 什么是跨域？"></a>🔁 什么是跨域？</h3><p>当你尝试访问非同源的资源时，就叫做“跨域”。</p><p>例如：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前页面： https://a.com</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">"https://b.com/api/data"</span>); <span class="comment">// ← 跨域请求</span></span><br></pre></td></tr></tbody></table></figure><p>由于同源策略限制，这类请求默认会被浏览器拦截或限制。</p><hr><h3 id="✅-常见跨域解决方案"><a href="#✅-常见跨域解决方案" class="headerlink" title="✅ 常见跨域解决方案"></a>✅ 常见跨域解决方案</h3><table><thead><tr><th>方法</th><th>原理简介</th><th>说明</th></tr></thead><tbody><tr><td><strong>CORS</strong></td><td>服务器通过设置响应头允许跨域访问</td><td>最常用、推荐的方式</td></tr><tr><td><strong>JSONP</strong></td><td>通过 <code>&lt;script&gt;</code> 标签实现 GET 跨域</td><td>仅支持 GET，请求不安全</td></tr><tr><td><strong>代理服务器</strong></td><td>前端请求发到同源代理，代理再访问真实接口</td><td>开发中常用于本地调试</td></tr><tr><td><strong>postMessage</strong></td><td>用于两个不同源的窗口之间安全地通信</td><td>常用于 iframe、窗口通信</td></tr><tr><td><strong>nginx 反向代理</strong></td><td>nginx 转发前端请求到目标服务器</td><td>服务端配置</td></tr><tr><td><strong>跨域资源嵌入</strong></td><td>如 <code>&lt;img&gt;</code> <code>&lt;script&gt;</code> <code>&lt;iframe&gt;</code> 加载外部资源</td><td>不受同源策略限制（但有限能力）</td></tr></tbody></table><hr><h3 id="🌐-CORS-示例"><a href="#🌐-CORS-示例" class="headerlink" title="🌐 CORS 示例"></a>🌐 CORS 示例</h3><p>前端请求：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">'https://api.example.com/data'</span>)</span><br></pre></td></tr></tbody></table></figure><p>服务器响应头必须包含：</p><figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>https://your-frontend.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>Content-Type</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="🧠-总结一句话：-1"><a href="#🧠-总结一句话：-1" class="headerlink" title="🧠 总结一句话："></a>🧠 总结一句话：</h3><blockquote><p>同源策略保护浏览器安全，防止不同源之间随意交互。跨域是绕过同源策略的方式，常用的解决方案是 <strong>CORS</strong>。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一把梭之NextJs</title>
      <link href="/2025/04/14/qian-duan/yi-ba-suo-zhi-nextjs/"/>
      <url>/2025/04/14/qian-duan/yi-ba-suo-zhi-nextjs/</url>
      
        <content type="html"><![CDATA[<h2 id="File-Router-文件路由"><a href="#File-Router-文件路由" class="headerlink" title="File Router - 文件路由"></a>File Router - 文件路由</h2><h3 id="🧠-什么是-File-Router？"><a href="#🧠-什么是-File-Router？" class="headerlink" title="🧠 什么是 File Router？"></a>🧠 什么是 File Router？</h3><blockquote><p><strong>File Router</strong> 是指：<strong>文件结构就是路由结构</strong>。</p></blockquote><p>你不需要手动配置路由（不像 React-Router 那样写一堆 <code>&lt;Route&gt;</code>），只需要把页面组件放到 <code>app/</code> 或 <code>pages/</code> 目录下，Next.js 就会<strong>自动把它注册成 URL 路由</strong>。</p><hr><h3 id="📁-App-Router-模式（app-目录）"><a href="#📁-App-Router-模式（app-目录）" class="headerlink" title="📁 App Router 模式（app/ 目录）"></a>📁 App Router 模式（<code>app/</code> 目录）</h3><p>从 <strong>Next.js 13</strong> 起，推荐使用 <code>app/</code> 目录，支持更强大的功能，比如：</p><ul><li>Layout 嵌套</li><li>服务端组件（Server Component）</li><li>并发和加载状态</li><li>共享模板（<code>layout.tsx</code>、<code>template.tsx</code>）</li><li>等等…</li></ul><hr><h4 id="🔗-文件结构-路由结构（核心）"><a href="#🔗-文件结构-路由结构（核心）" class="headerlink" title="🔗 文件结构 = 路由结构（核心）"></a>🔗 文件结构 = 路由结构（核心）</h4><p>假设你有这个项目结构：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/app</span><br><span class="line">  ├── layout.tsx</span><br><span class="line">  ├── page.tsx               // 对应 "/"</span><br><span class="line">  ├── about</span><br><span class="line">  │    └── page.tsx          // 对应 "/about"</span><br><span class="line">  ├── blog</span><br><span class="line">  │    ├── page.tsx          // 对应 "/blog"</span><br><span class="line">  │    └── [slug]</span><br><span class="line">  │         └── page.tsx     // 对应 "/blog/xxx"</span><br></pre></td></tr></tbody></table></figure><p>👉 上面这些文件和路径会自动生成这些路由：</p><table><thead><tr><th>文件路径</th><th>访问地址</th></tr></thead><tbody><tr><td><code>app/page.tsx</code></td><td><code>/</code></td></tr><tr><td><code>app/about/page.tsx</code></td><td><code>/about</code></td></tr><tr><td><code>app/blog/page.tsx</code></td><td><code>/blog</code></td></tr><tr><td><code>app/blog/[slug]/page.tsx</code></td><td><code>/blog/123</code>、<code>/blog/abc</code> 等动态路由</td></tr></tbody></table><hr><h3 id="🔁-动态路由（Dynamic-Routes）"><a href="#🔁-动态路由（Dynamic-Routes）" class="headerlink" title="🔁 动态路由（Dynamic Routes）"></a>🔁 动态路由（Dynamic Routes）</h3><p>如果你想让路由接受参数，只需要用 <code>[]</code> 括起来参数名：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app/products/[<span class="built_in">id</span>]/page.tsx</span><br></pre></td></tr></tbody></table></figure><p>访问 <code>/products/123</code> 时，组件中就可以用 <code>params.id</code> 读取这个参数。</p><figure class="highlight tsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/products/[id]/page.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ProductPage</span>(<span class="params">{ params }</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Product ID: {params.id}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="📦-Layout-和-Page-的区别"><a href="#📦-Layout-和-Page-的区别" class="headerlink" title="📦 Layout 和 Page 的区别"></a>📦 Layout 和 Page 的区别</h3><table><thead><tr><th>文件名</th><th>用途</th></tr></thead><tbody><tr><td><code>layout.tsx</code></td><td>可复用的界面结构（如导航栏、侧边栏）</td></tr><tr><td><code>page.tsx</code></td><td>实际的页面内容（路由终点）</td></tr></tbody></table><p>你可以有嵌套的 layout，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/app</span><br><span class="line">  ├── layout.tsx           // 全局 Layout</span><br><span class="line">  └── dashboard</span><br><span class="line">        ├── layout.tsx     // Dashboard 专属 Layout</span><br><span class="line">        └── page.tsx       // /dashboard 页面</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="🧪-特殊文件名"><a href="#🧪-特殊文件名" class="headerlink" title="🧪 特殊文件名"></a>🧪 特殊文件名</h3><table><thead><tr><th>文件</th><th>功能</th></tr></thead><tbody><tr><td><code>page.tsx</code></td><td>页面组件，对应具体路由</td></tr><tr><td><code>layout.tsx</code></td><td>共享布局（每层目录可以有自己的 Layout）</td></tr><tr><td><code>loading.tsx</code></td><td>页面加载时展示的 loading 动画</td></tr><tr><td><code>error.tsx</code></td><td>页面加载失败时的错误处理</td></tr><tr><td><code>not-found.tsx</code></td><td>404 页面</td></tr></tbody></table><hr><h2 id="✅-小总结"><a href="#✅-小总结" class="headerlink" title="✅ 小总结"></a>✅ 小总结</h2><table><thead><tr><th>特性</th><th>简介</th></tr></thead><tbody><tr><td>✅ 文件结构就是路由</td><td>不用写路由表，目录结构天然决定路径</td></tr><tr><td>✅ 动态路由</td><td><code>[param]</code> 形式接收参数</td></tr><tr><td>✅ 支持嵌套路由</td><td>子目录即子页面，自然嵌套</td></tr><tr><td>✅ Layout 可共享页面结构</td><td><code>layout.tsx</code> 非常适合放导航栏、头部等</td></tr><tr><td>✅ 支持 loading、error、not-found</td><td>内建页面状态管理支持</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TailWindCss</title>
      <link href="/2025/03/02/qian-duan/tailwindcss/"/>
      <url>/2025/03/02/qian-duan/tailwindcss/</url>
      
        <content type="html"><![CDATA[<h1 id="TailWind"><a href="#TailWind" class="headerlink" title="TailWind"></a>TailWind</h1><h3 id="安装-tailwindcss"><a href="#安装-tailwindcss" class="headerlink" title="安装 tailwindcss"></a>安装 tailwindcss</h3><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="literal">-D</span> tailwindcss</span><br><span class="line">npx tailwindcss init</span><br></pre></td></tr></tbody></table></figure><p>创建<code>tailwind.config.js</code> 配置文件</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在 <code>tailwind.config.js</code> 配置文件中添加所有模板文件的路径。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type</span> {<span class="type">import('tailwindcss').Config</span>} */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = {</span><br><span class="line">  <span class="attr">content</span>: [<span class="string">"./src/**/*.{html,js}"</span>],  <span class="comment">// 根据项目实际文件类型调整</span></span><br><span class="line">  <span class="attr">theme</span>: {</span><br><span class="line">    <span class="attr">extend</span>: {},</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在x分钟内学会go</title>
      <link href="/2025/02/25/hou-duan/zai-x-fen-zhong-nei-xue-hui-go/"/>
      <url>/2025/02/25/hou-duan/zai-x-fen-zhong-nei-xue-hui-go/</url>
      
        <content type="html"><![CDATA[<p>参考资料：</p><ul><li><a href="https://learnxinyminutes.com/go/">https://learnxinyminutes.com/go/</a></li></ul><hr><h2 id="go-类型"><a href="#go-类型" class="headerlink" title="go 类型"></a>go 类型</h2><table><thead><tr><th>类型分类</th><th>类型示例</th><th>定义语法</th></tr></thead><tbody><tr><td><strong>基本类型</strong></td><td><code>int</code>, <code>float32</code>, <code>bool</code>, <code>string</code>, <code>rune</code> 等</td><td><code>var x int</code>  <code>var y float32</code>  <code>var isTrue bool</code>  <code>var s string</code></td></tr><tr><td><strong>复合类型</strong></td><td><code>array</code>, <code>slice</code>, <code>map</code>, <code>struct</code></td><td><code>var arr [5]int</code>  <code>var s []int</code>  <code>var m map[string]int</code>  <code>type Person struct { Name string; Age int }</code></td></tr><tr><td><strong>引用类型</strong></td><td><code>slice</code>, <code>map</code>, <code>channel</code>, <code>pointer</code></td><td><code>var p *int</code>  <code>var ch chan int</code>  <code>var s []int</code>  <code>var m map[string]int</code></td></tr><tr><td><strong>接口类型</strong></td><td><code>interface{}</code>, 自定义接口</td><td><code>var i interface{}</code>  <code>type Animal interface { Speak() string }</code></td></tr><tr><td><strong>函数类型</strong></td><td>函数类型可以作为类型，传递函数</td><td><code>type AddFunc func(a int, b int) int</code>  <code>var sum AddFunc</code></td></tr><tr><td><strong>常量类型</strong></td><td>常量类型通过 <code>const</code> 声明，值不可更改</td><td><code>const Pi = 3.14</code>  <code>const Name = "Go"</code></td></tr><tr><td><strong>类型别名</strong></td><td><code>type NewType oldType</code> 用于为类型创建别名</td><td><code>type MyInt int</code>  <code>var x MyInt</code></td></tr></tbody></table><h2 id="代码通识💡"><a href="#代码通识💡" class="headerlink" title="代码通识💡"></a>代码通识💡</h2><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/* 多行注释 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构建标签是以 //go:build 开头的行注释</span></span><br><span class="line"><span class="comment">  可以通过 go build -tags="foo bar" 命令执行。</span></span><br><span class="line"><span class="comment">  构建标签放在包声明之前，靠近文件顶部</span></span><br><span class="line"><span class="comment">  后面跟着一个空行或其他行注释。 */</span></span><br><span class="line"><span class="comment">//go:build prod || dev || test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个源文件都以包声明开始。</span></span><br><span class="line"><span class="comment">// main 是一个特殊名称，声明一个可执行文件而不是库。</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入声明声明在此文件中引用的库包。</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span>              <span class="comment">// Go 标准库中的一个包。</span></span><br><span class="line"><span class="string">"io"</span>               <span class="comment">// 实现一些 I/O 工具函数。</span></span><br><span class="line">m <span class="string">"math"</span>           <span class="comment">// 带有本地别名 m 的数学库。</span></span><br><span class="line"><span class="string">"net/http"</span>         <span class="comment">// 是的，一个网络服务器！</span></span><br><span class="line">_ <span class="string">"net/http/pprof"</span> <span class="comment">// 仅为副作用导入的分析库</span></span><br><span class="line"><span class="string">"os"</span>               <span class="comment">// 像处理文件系统的 OS 函数</span></span><br><span class="line"><span class="string">"strconv"</span>          <span class="comment">// 字符串转换。</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义。Main 是特殊的。它是可执行程序的入口点。</span></span><br><span class="line"><span class="comment">// 喜欢它或讨厌它，Go 使用大括号。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// Println 输出一行到标准输出。</span></span><br><span class="line"><span class="comment">// 它来自 fmt 包。</span></span><br><span class="line">fmt.Println(<span class="string">"Hello world!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此包内调用另一个函数。</span></span><br><span class="line">beyondHello()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数可以有参数在括号中。</span></span><br><span class="line"><span class="comment">// 如果没有参数，空括号仍然是必需的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">beyondHello</span><span class="params">()</span></span> {</span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span> <span class="comment">// 变量声明。变量必须在使用前声明。</span></span><br><span class="line">x = <span class="number">3</span>     <span class="comment">// 变量赋值。</span></span><br><span class="line"><span class="comment">// "短"声明使用 := 来推断类型，声明并赋值。</span></span><br><span class="line">y := <span class="number">4</span></span><br><span class="line">sum, prod := learnMultiple(x, y)        <span class="comment">// 函数返回两个值。</span></span><br><span class="line">fmt.Println(<span class="string">"sum:"</span>, sum, <span class="string">"prod:"</span>, prod) <span class="comment">// 简单输出。</span></span><br><span class="line">learnTypes()                            <span class="comment">// &lt; y 分钟，了解更多！</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;- 多行注释</span></span><br><span class="line"><span class="comment">函数可以有参数和（多个！）返回值。</span></span><br><span class="line"><span class="comment">这里 `x`，`y` 是参数，`sum`，`prod` 是签名（返回的内容）。</span></span><br><span class="line"><span class="comment">注意 `x` 和 `sum` 接收类型 `int`。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnMultiple</span><span class="params">(x, y <span class="type">int</span>)</span></span> (sum, prod <span class="type">int</span>) {</span><br><span class="line"><span class="keyword">return</span> x + y, x * y <span class="comment">// 返回两个值。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些内置类型和字面量。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnTypes</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 短声明通常会给你想要的东西。</span></span><br><span class="line">str := <span class="string">"Learn Go!"</span> <span class="comment">// 字符串类型。</span></span><br><span class="line"></span><br><span class="line">s2 := <span class="string">`A "raw" string literal</span></span><br><span class="line"><span class="string">can include line breaks.`</span> <span class="comment">// 同样的字符串类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非 ASCII 字面量。Go 源代码是 UTF-8。</span></span><br><span class="line">g := <span class="string">'Σ'</span> <span class="comment">// rune 类型，是 int32 的别名，保存一个 unicode 码点。</span></span><br><span class="line"></span><br><span class="line">f := <span class="number">3.14159</span> <span class="comment">// float64，IEEE-754 64 位浮点数。</span></span><br><span class="line">c := <span class="number">3</span> + <span class="number">4i</span>  <span class="comment">// complex128，内部用两个 float64 表示。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有初始化器的 var 语法。</span></span><br><span class="line"><span class="keyword">var</span> u <span class="type">uint</span> = <span class="number">7</span> <span class="comment">// 无符号，但实现依赖于大小，与 int 一样。</span></span><br><span class="line"><span class="keyword">var</span> pi <span class="type">float32</span> = <span class="number">22.</span> / <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换语法与短声明。</span></span><br><span class="line">n := <span class="type">byte</span>(<span class="string">'\n'</span>) <span class="comment">// byte 是 uint8 的别名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的大小在编译时固定。</span></span><br><span class="line"><span class="keyword">var</span> a4 [<span class="number">4</span>]<span class="type">int</span>                    <span class="comment">// 一个包含 4 个 int 的数组，初始化为全 0。</span></span><br><span class="line">a5 := [...]<span class="type">int</span>{<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">100</span>} <span class="comment">// 一个初始化为固定大小为五的数组</span></span><br><span class="line"><span class="comment">// 元素，值为 3，1，5，10 和 100。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组具有值语义。</span></span><br><span class="line">a4_cpy := a4                    <span class="comment">// a4_cpy 是 a4 的副本，两个独立的实例。</span></span><br><span class="line">a4_cpy[<span class="number">0</span>] = <span class="number">25</span>                  <span class="comment">// 只有 a4_cpy 被更改，a4 保持不变。</span></span><br><span class="line">fmt.Println(a4_cpy[<span class="number">0</span>] == a4[<span class="number">0</span>]) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片具有动态大小。数组和切片各有优缺点</span></span><br><span class="line"><span class="comment">// 但切片的使用场景更为常见。</span></span><br><span class="line">s3 := []<span class="type">int</span>{<span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>}    <span class="comment">// 与 a5 相比。这里没有省略号。</span></span><br><span class="line">s4 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>)    <span class="comment">// 分配 4 个 int 的切片，初始化为全 0。</span></span><br><span class="line"><span class="keyword">var</span> d2 [][]<span class="type">float64</span>      <span class="comment">// 仅声明，没有分配任何内容。</span></span><br><span class="line">bs := []<span class="type">byte</span>(<span class="string">"a slice"</span>) <span class="comment">// 类型转换语法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片（以及映射和通道）具有引用语义。</span></span><br><span class="line">s3_cpy := s3                    <span class="comment">// 两个变量指向同一个实例。</span></span><br><span class="line">s3_cpy[<span class="number">0</span>] = <span class="number">0</span>                   <span class="comment">// 这意味着两个都被更新。</span></span><br><span class="line">fmt.Println(s3_cpy[<span class="number">0</span>] == s3[<span class="number">0</span>]) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为它们是动态的，切片可以按需追加。</span></span><br><span class="line"><span class="comment">// 要向切片追加元素，使用内置的 append() 函数。</span></span><br><span class="line"><span class="comment">// 第一个参数是我们要追加的切片。通常，</span></span><br><span class="line"><span class="comment">// 切片变量就地更新，如下面的示例。</span></span><br><span class="line">s := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}    <span class="comment">// 结果是一个长度为 3 的切片。</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 添加了 3 个元素。切片现在的长度为 6。</span></span><br><span class="line">fmt.Println(s)         <span class="comment">// 更新后的切片现在是 [1 2 3 4 5 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要追加另一个切片，而不是原子元素的列表，我们可以</span></span><br><span class="line"><span class="comment">// 传递对切片的引用或像这样带有尾随省略号的切片字面量，</span></span><br><span class="line"><span class="comment">// 意思是取一个切片并展开其元素，</span></span><br><span class="line"><span class="comment">// 将它们追加到切片 s。</span></span><br><span class="line">s = <span class="built_in">append</span>(s, []<span class="type">int</span>{<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>}...) <span class="comment">// 第二个参数是一个切片字面量。</span></span><br><span class="line">fmt.Println(s)                   <span class="comment">// 更新后的切片现在是 [1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line">p, q := learnMemory() <span class="comment">// 声明 p，q 为指向 int 的指针。</span></span><br><span class="line">fmt.Println(*p, *q)   <span class="comment">// * 后跟指针。这将打印两个 int。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射是动态可增长的关联数组类型，类似于某些其他语言的</span></span><br><span class="line"><span class="comment">// 哈希或字典类型。</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>{<span class="string">"three"</span>: <span class="number">3</span>, <span class="string">"four"</span>: <span class="number">4</span>}</span><br><span class="line">m[<span class="string">"one"</span>] = <span class="number">1</span></span><br><span class="line"><span class="comment">// 检查键是否存在于映射中，如下所示：</span></span><br><span class="line"><span class="keyword">if</span> val, ok := m[<span class="string">"one"</span>]; ok {</span><br><span class="line"><span class="comment">// 做一些事情</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未使用的变量在 Go 中是一个错误。</span></span><br><span class="line"><span class="comment">// 下划线让你"使用"一个变量但丢弃其值。</span></span><br><span class="line">_, _, _, _, _, _, _, _, _, _ = str, s2, g, f, u, pi, n, a5, s4, bs</span><br><span class="line"><span class="comment">// 通常你用它来忽略函数的返回值之一</span></span><br><span class="line"><span class="comment">// 例如，在一个快速而肮脏的脚本中，你可能会忽略</span></span><br><span class="line"><span class="comment">// 从 os.Create 返回的错误值，并期望文件</span></span><br><span class="line"><span class="comment">// 总是会被创建。</span></span><br><span class="line">file, _ := os.Create(<span class="string">"output.txt"</span>)</span><br><span class="line">fmt.Fprint(file, <span class="string">"这就是你如何写入文件，顺便说一下"</span>)</span><br><span class="line">file.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，输出也算作使用一个变量。</span></span><br><span class="line">fmt.Println(s, c, a4, s3, d2, m)</span><br><span class="line"></span><br><span class="line">learnFlowControl() <span class="comment">// 回到流程控制。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在许多其他语言中，Go 中的函数</span></span><br><span class="line"><span class="comment">// 可以有命名返回值。</span></span><br><span class="line"><span class="comment">// 在函数声明行中为返回的类型分配一个名称</span></span><br><span class="line"><span class="comment">// 允许我们轻松地从函数中的多个点返回，以及</span></span><br><span class="line"><span class="comment">// 只使用 return 关键字，而不需要其他内容。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnNamedReturns</span><span class="params">(x, y <span class="type">int</span>)</span></span> (z <span class="type">int</span>) {</span><br><span class="line">z = x * y</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// z 在这里是隐式的，因为我们之前命名了它。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 是完全垃圾回收的。它有指针但没有指针运算。</span></span><br><span class="line"><span class="comment">// 你可以犯一个 nil 指针的错误，但不会通过递增指针。</span></span><br><span class="line"><span class="comment">// 与 C/C++ 不同，获取和返回局部变量的地址也是安全的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnMemory</span><span class="params">()</span></span> (p, q *<span class="type">int</span>) {</span><br><span class="line"><span class="comment">// 命名返回值 p 和 q 的类型是指向 int 的指针。</span></span><br><span class="line">p = <span class="built_in">new</span>(<span class="type">int</span>) <span class="comment">// 内置函数 new 分配内存。</span></span><br><span class="line"><span class="comment">// 分配的 int 切片初始化为 0，p 不再是 nil。</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">20</span>) <span class="comment">// 分配 20 个 int 作为一块内存。</span></span><br><span class="line">s[<span class="number">3</span>] = <span class="number">7</span>             <span class="comment">// 赋值其中一个。</span></span><br><span class="line">r := <span class="number">-2</span>              <span class="comment">// 声明另一个局部变量。</span></span><br><span class="line"><span class="keyword">return</span> &amp;s[<span class="number">3</span>], &amp;r     <span class="comment">// &amp; 获取对象的地址。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用别名数学库（见上面的导入）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expensiveComputation</span><span class="params">()</span></span> <span class="type">float64</span> {</span><br><span class="line"><span class="keyword">return</span> m.Exp(<span class="number">10</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnFlowControl</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 如果语句需要大括号，并且不需要括号。</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> {</span><br><span class="line">fmt.Println(<span class="string">"我告诉过你"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 格式化由命令行命令 "go fmt" 标准化。</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">false</span> {</span><br><span class="line"><span class="comment">// 呜呜。</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="comment">// 得意。</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 使用 switch 优先于链式 if 语句。</span></span><br><span class="line">x := <span class="number">42.0</span></span><br><span class="line"><span class="keyword">switch</span> x {</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>: <span class="comment">// 可以在一个 case 中有多个匹配</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">42</span>:</span><br><span class="line"><span class="comment">// case 不会"穿透"。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">然而，有一个 `fallthrough` 关键字，见：</span></span><br><span class="line"><span class="comment">https://go.dev/wiki/Switch#fall-through</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">43</span>:</span><br><span class="line"><span class="comment">// 未到达。</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 默认情况是可选的。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型开关允许根据某个东西的类型而不是值进行切换</span></span><br><span class="line"><span class="keyword">var</span> data <span class="keyword">interface</span>{}</span><br><span class="line">data = <span class="string">""</span></span><br><span class="line"><span class="keyword">switch</span> c := data.(<span class="keyword">type</span>) {</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Println(c, <span class="string">"是一个字符串"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">int64</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%d 是一个 int64\n"</span>, c)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 所有其他情况</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 if 一样，for 也不使用括号。</span></span><br><span class="line"><span class="comment">// 在 for 和 if 中声明的变量是局部的。</span></span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">3</span>; x++ { <span class="comment">// ++ 是一个语句。</span></span><br><span class="line">fmt.Println(<span class="string">"迭代"</span>, x)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// x == 42 在这里。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for 是 Go 中唯一的循环语句，但它有替代形式。</span></span><br><span class="line"><span class="keyword">for</span> { <span class="comment">// 无限循环。</span></span><br><span class="line"><span class="keyword">break</span>    <span class="comment">// 开玩笑的。</span></span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// 未到达。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以使用 range 遍历数组、切片、字符串、映射或通道。</span></span><br><span class="line"><span class="comment">// range 返回一个（通道）或两个值（数组、切片、字符串和映射）。</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>{<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>, <span class="string">"three"</span>: <span class="number">3</span>} {</span><br><span class="line"><span class="comment">// 对于映射中的每一对，打印键和值</span></span><br><span class="line">fmt.Printf(<span class="string">"key=%s, value=%d\n"</span>, key, value)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 如果你只需要值，使用下划线作为键</span></span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> []<span class="type">string</span>{<span class="string">"Bob"</span>, <span class="string">"Bill"</span>, <span class="string">"Joe"</span>} {</span><br><span class="line">fmt.Printf(<span class="string">"你好，%s\n"</span>, name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 for 一样，:= 在 if 语句中意味着先声明并赋值</span></span><br><span class="line"><span class="comment">// y，然后测试 y &gt; x。</span></span><br><span class="line"><span class="keyword">if</span> y := expensiveComputation(); y &gt; x {</span><br><span class="line">x = y</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 函数字面量是闭包。</span></span><br><span class="line">xBig := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> {</span><br><span class="line"><span class="keyword">return</span> x &gt; <span class="number">10000</span> <span class="comment">// 引用上面 switch 语句中声明的 x。</span></span><br><span class="line">}</span><br><span class="line">x = <span class="number">99999</span></span><br><span class="line">fmt.Println(<span class="string">"xBig:"</span>, xBig()) <span class="comment">// true</span></span><br><span class="line">x = <span class="number">1.3e3</span>                    <span class="comment">// 这使得 x == 1300</span></span><br><span class="line">fmt.Println(<span class="string">"xBig:"</span>, xBig()) <span class="comment">// 现在是 false。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更重要的是，函数字面量可以在线定义和调用，</span></span><br><span class="line"><span class="comment">// 作为函数的参数，只要：</span></span><br><span class="line"><span class="comment">// a) 函数字面量立即调用（），</span></span><br><span class="line"><span class="comment">// b) 结果类型与参数的预期类型匹配。</span></span><br><span class="line">fmt.Println(<span class="string">"加 + 乘以两个数字："</span>,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line"><span class="keyword">return</span> (a + b) * <span class="number">2</span></span><br><span class="line">}(<span class="number">10</span>, <span class="number">2</span>)) <span class="comment">// 用参数 10 和 2 调用</span></span><br><span class="line"><span class="comment">// =&gt; 加 + 乘以两个数字：24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当你需要它时，你会喜欢它。</span></span><br><span class="line"><span class="keyword">goto</span> love</span><br><span class="line">love:</span><br><span class="line"></span><br><span class="line">learnFunctionFactory() <span class="comment">// func 返回 func 是有趣的(3)(3)</span></span><br><span class="line">learnDefer()      <span class="comment">// 一个快速的绕道到一个重要的关键字。</span></span><br><span class="line">learnInterfaces() <span class="comment">// 好东西即将到来！</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnFunctionFactory</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 接下来的两个是等效的，第二个更实用</span></span><br><span class="line">fmt.Println(sentenceFactory(<span class="string">"summer"</span>)(<span class="string">"一个美丽的"</span>, <span class="string">"日子！"</span>))</span><br><span class="line"></span><br><span class="line">d := sentenceFactory(<span class="string">"summer"</span>)</span><br><span class="line">fmt.Println(d(<span class="string">"一个美丽的"</span>, <span class="string">"日子！"</span>))</span><br><span class="line">fmt.Println(d(<span class="string">"一个懒惰的"</span>, <span class="string">"下午！"</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器在其他语言中很常见。Go 中也可以做到</span></span><br><span class="line"><span class="comment">// 使用接受参数的函数字面量。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sentenceFactory</span><span class="params">(mystring <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(before, after <span class="type">string</span>)</span></span> <span class="type">string</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(before, after <span class="type">string</span>)</span></span> <span class="type">string</span> {</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s %s %s"</span>, before, mystring, after) <span class="comment">// 新字符串</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//defer-后进先出（LIFO）顺序执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnDefer</span><span class="params">()</span></span> (ok <span class="type">bool</span>) {</span><br><span class="line"><span class="comment">// defer 语句将函数调用推送到列表中。保存的</span></span><br><span class="line"><span class="comment">// 调用列表在周围的函数返回后执行。</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"延迟语句以相反的顺序执行（LIFO）。"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"\n这一行首先被打印，因为"</span>)</span><br><span class="line"><span class="comment">// defer 通常用于关闭文件，因此关闭文件的函数</span></span><br><span class="line"><span class="comment">// 保持在打开文件的函数附近。</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Stringer 作为具有一个方法 String 的接口类型。</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> {</span><br><span class="line">String() <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 pair 作为具有两个字段的结构体，命名为 x 和 y 的 int。</span></span><br><span class="line"><span class="keyword">type</span> pair <span class="keyword">struct</span> {</span><br><span class="line">x, y <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类型 pair 上定义一个方法。Pair 现在实现了 Stringer，因为 Pair 定义了接口中的所有方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p pair)</span></span> String() <span class="type">string</span> { <span class="comment">// p 被称为"接收者"</span></span><br><span class="line"><span class="comment">// Sprintf 是 fmt 包中的另一个公共函数。</span></span><br><span class="line"><span class="comment">// 点语法引用 p 的字段。</span></span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"(%d, %d)"</span>, p.x, p.y)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnInterfaces</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 大括号语法是"结构字面量"。它计算为初始化</span></span><br><span class="line"><span class="comment">// 结构。:= 语法声明并初始化 p 为此结构。</span></span><br><span class="line">p := pair{<span class="number">3</span>, <span class="number">4</span>}</span><br><span class="line">fmt.Println(p.String()) <span class="comment">// 调用类型为 pair 的 p 的 String 方法。</span></span><br><span class="line"><span class="keyword">var</span> i Stringer          <span class="comment">// 声明 i 为接口类型 Stringer。</span></span><br><span class="line">i = p                   <span class="comment">// 有效，因为 pair 实现了 Stringer</span></span><br><span class="line"><span class="comment">// 调用类型为 Stringer 的 i 的 String 方法。输出与上面相同。</span></span><br><span class="line">fmt.Println(i.String())</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt 包中的函数调用 String 方法以请求对象</span></span><br><span class="line"><span class="comment">// 的可打印表示。</span></span><br><span class="line">fmt.Println(p) <span class="comment">// 输出与上面相同。Println 调用 String 方法。</span></span><br><span class="line">fmt.Println(i) <span class="comment">// 输出与上面相同。</span></span><br><span class="line"></span><br><span class="line">learnVariadicParams(<span class="string">"很棒的"</span>, <span class="string">"学习"</span>, <span class="string">"在这里！"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数可以有变参。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnVariadicParams</span><span class="params">(myStrings ...any)</span></span> { <span class="comment">// any 是 interface{} 的别名</span></span><br><span class="line"><span class="comment">// 迭代每个变参的值。</span></span><br><span class="line"><span class="comment">// 这里的下划线忽略了数组的索引参数。</span></span><br><span class="line"><span class="keyword">for</span> _, param := <span class="keyword">range</span> myStrings {</span><br><span class="line">fmt.Println(<span class="string">"参数:"</span>, param)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将变参值作为变参传递。</span></span><br><span class="line">fmt.Println(<span class="string">"参数:"</span>, fmt.Sprintln(myStrings...))</span><br><span class="line"></span><br><span class="line">learnErrorHandling()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnErrorHandling</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// ", ok" 习语用于告诉某件事情是否成功。</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>{<span class="number">3</span>: <span class="string">"three"</span>, <span class="number">4</span>: <span class="string">"four"</span>}</span><br><span class="line"><span class="keyword">if</span> x, ok := m[<span class="number">1</span>]; !ok { <span class="comment">// ok 将为 false，因为 1 不在映射中。</span></span><br><span class="line">fmt.Println(<span class="string">"没有人"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">fmt.Print(x) <span class="comment">// 如果 x 在映射中，它将是值。</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 错误值不仅传达"ok"，还传达更多关于问题的信息。</span></span><br><span class="line"><span class="keyword">if</span> _, err := strconv.Atoi(<span class="string">"非整数"</span>); err != <span class="literal">nil</span> { <span class="comment">// _ 丢弃值</span></span><br><span class="line"><span class="comment">// 打印 'strconv.ParseInt: parsing "non-int": invalid syntax'</span></span><br><span class="line">fmt.Println(err)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 我们稍后会重新访问接口。与此同时，</span></span><br><span class="line">learnConcurrency()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// c 是一个通道，一个并发安全的通信对象。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inc</span><span class="params">(i <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> {</span><br><span class="line">c &lt;- i + <span class="number">1</span> <span class="comment">// &lt;- 是当通道出现在左侧时的"发送"运算符。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将使用 inc 来并发地递增一些数字。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnConcurrency</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// 与之前用于创建切片的 make 函数相同。Make 分配和</span></span><br><span class="line"><span class="comment">// 初始化切片、映射和通道。</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="comment">// 启动三个并发的 goroutine。数字将被递增</span></span><br><span class="line"><span class="comment">// 并发地，可能在机器能够并且</span></span><br><span class="line"><span class="comment">// 正确配置的情况下并行。所有三个发送到同一个通道。</span></span><br><span class="line"><span class="keyword">go</span> inc(<span class="number">0</span>, c) <span class="comment">// go 是一个语句，启动一个新的 goroutine。</span></span><br><span class="line"><span class="keyword">go</span> inc(<span class="number">10</span>, c)</span><br><span class="line"><span class="keyword">go</span> inc(<span class="number">-805</span>, c)</span><br><span class="line"><span class="comment">// 从通道读取三个结果并打印它们。</span></span><br><span class="line"><span class="comment">// 没有办法知道结果将以什么顺序到达！</span></span><br><span class="line">fmt.Println(&lt;-c, &lt;-c, &lt;-c) <span class="comment">// 通道在右侧，&lt;- 是"接收"运算符。</span></span><br><span class="line"></span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)       <span class="comment">// 另一个通道，这个处理字符串。</span></span><br><span class="line">ccs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="type">string</span>) <span class="comment">// 一个字符串通道的通道。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { c &lt;- <span class="number">84</span> }()       <span class="comment">// 启动一个新的 goroutine 仅仅发送一个值。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { cs &lt;- <span class="string">"wordy"</span> }() <span class="comment">// 再次，为 cs 这次。</span></span><br><span class="line"><span class="comment">// select 的语法类似于 switch 语句，但每个 case 涉及</span></span><br><span class="line"><span class="comment">// 通道操作。它随机选择准备通信的 case。</span></span><br><span class="line"><span class="keyword">select</span> {</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c: <span class="comment">// 接收到的值可以分配给一个变量，</span></span><br><span class="line">fmt.Printf(<span class="string">"它是一个 %T"</span>, i)</span><br><span class="line"><span class="keyword">case</span> &lt;-cs: <span class="comment">// 或者接收到的值可以被丢弃。</span></span><br><span class="line">fmt.Println(<span class="string">"它是一个字符串"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ccs: <span class="comment">// 空通道，未准备好通信。</span></span><br><span class="line">fmt.Println(<span class="string">"没有发生。"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 此时，从 c 或 cs 中取出了一个值。上面启动的两个</span></span><br><span class="line"><span class="comment">// goroutine 中的一个已经完成，另一个将保持阻塞。</span></span><br><span class="line"></span><br><span class="line">learnWebProgramming() <span class="comment">// Go 做到了。你也想这样做。</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// package http 中的一个单一函数启动一个网络服务器。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnWebProgramming</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// ListenAndServe 的第一个参数是要监听的 TCP 地址。</span></span><br><span class="line"><span class="comment">// 第二个参数是一个接口，特别是 http.Handler。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">err := http.ListenAndServe(<span class="string">":8080"</span>, pair{})</span><br><span class="line">fmt.Println(err) <span class="comment">// 不要忽略错误</span></span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">requestServer()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过实现其唯一方法 ServeHTTP，使 pair 成为 http.Handler。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p pair)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) {</span><br><span class="line"><span class="comment">// 使用 http.ResponseWriter 的方法提供数据。</span></span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">"你在 Y 分钟内学会了 Go！"</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestServer</span><span class="params">()</span></span>{</span><br><span class="line"><span class="comment">//函数向 http://localhost:8080 发送一个 GET 请求。</span></span><br><span class="line">resp,err := http.Get(<span class="string">"http://localhost:8080"</span>)</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()<span class="comment">//在函数执行完毕后关闭请求</span></span><br><span class="line"><span class="comment">//读取 resp.Body 中的所有内容-响应体</span></span><br><span class="line">body,err := io.ReadAll(resp.Body)</span><br><span class="line">fmt.Printf(<span class="string">"\nWebserver 说: `%s`"</span>, <span class="type">string</span>(body))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="难点解析💡"><a href="#难点解析💡" class="headerlink" title="难点解析💡"></a>难点解析💡</h3><h4 id="一、装饰器"><a href="#一、装饰器" class="headerlink" title="一、装饰器"></a>一、装饰器</h4><blockquote><p><strong>装饰器的概念：</strong></p><ul><li><strong>装饰器（Decorator）</strong> 是一种常见的设计模式，目的是在不改变原有函数的情况下对其功能进行扩展或修改。在 Go 语言中，通过闭包可以实现类似装饰器的功能。</li><li>在本例中，<code>sentenceFactory</code> 就是一个简单的装饰器，它将一个常量字符串（<code>mystring</code>）和传入的参数组合成新的句子。</li></ul></blockquote><ol><li><h5 id="sentenceFactory-函数工厂："><a href="#sentenceFactory-函数工厂：" class="headerlink" title="sentenceFactory 函数工厂："></a><strong><code>sentenceFactory</code> 函数工厂：</strong></h5><p><code>sentenceFactory</code> 是一个函数工厂，它接收一个字符串（如 <code>"summer"</code>）并返回一个新的函数，这个返回的函数接收两个参数 <code>before</code> 和 <code>after</code>，并返回一个格式化的字符串。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sentenceFactory</span><span class="params">(mystring <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(before, after <span class="type">string</span>)</span></span> <span class="type">string</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(before, after <span class="type">string</span>)</span></span> <span class="type">string</span> {</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s %s %s"</span>, before, mystring, after)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个函数工厂的核心是：</p><ul><li>它返回一个匿名函数（也叫做闭包），这个匿名函数接受两个字符串参数 <code>before</code> 和 <code>after</code>，并通过 <code>fmt.Sprintf</code> 格式化并返回一个新的字符串。</li><li>在格式化的过程中，<code>mystring</code> 是函数工厂的输入参数，代表固定的一部分字符串。<code>before</code> 和 <code>after</code> 则是调用这个函数时传入的参数。</li></ul></li><li><p><strong><code>learnFunctionFactory</code> 使用：</strong></p><p><code>learnFunctionFactory</code> 函数演示了如何使用 <code>sentenceFactory</code>。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnFunctionFactory</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Println(sentenceFactory(<span class="string">"summer"</span>)(<span class="string">"一个美丽的"</span>, <span class="string">"日子！"</span>))</span><br><span class="line"></span><br><span class="line">    d := sentenceFactory(<span class="string">"summer"</span>)</span><br><span class="line">    fmt.Println(d(<span class="string">"一个美丽的"</span>, <span class="string">"日子！"</span>))</span><br><span class="line">    fmt.Println(d(<span class="string">"一个懒惰的"</span>, <span class="string">"下午！"</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>sentenceFactory("summer")("一个美丽的", "日子！")</code> 这一行创建了一个使用 <code>"summer"</code> 字符串的函数，并立即调用它，传入 <code>"一个美丽的"</code> 和 <code>"日子！"</code> 作为参数。输出将是：<code>"一个美丽的 summer 日子！"</code>.</li><li><code>d := sentenceFactory("summer")</code> 先将工厂返回的函数赋值给 <code>d</code>，然后可以多次调用 <code>d</code>，传入不同的参数，生成不同的句子。第二次调用时传入的是 <code>"一个懒惰的"</code> 和 <code>"下午！"</code>，输出将是：<code>"一个懒惰的 summer 下午！"</code>。</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Coin &amp; Token 在使用中的一些区别</title>
      <link href="/2025/02/23/qu-kuai-lian/coin-token-yi-ji-balance-de-qu-bie/"/>
      <url>/2025/02/23/qu-kuai-lian/coin-token-yi-ji-balance-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>参考资料：</p><ul><li><a href="https://www.bilibili.com/video/BV1MPrvYpE4z?spm_id_from=333.788.videopod.sections&amp;vd_source=7815abf75f25008fd075daf46f5ff072">HOH水分子社区前端课</a></li><li><a href="https://docs.sui.io/standards">SUI官方文档</a></li></ul><h1 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h1><table><thead><tr><th align="left">特性</th><th align="left"><code>sui::token</code></th><th align="left"><code>sui::coin</code></th></tr></thead><tbody><tr><td align="left"><strong>系统类型</strong></td><td align="left">闭环系统</td><td align="left">开环系统</td></tr><tr><td align="left"><strong>权限控制</strong></td><td align="left">双层(TokenPolicyCap + TreasuryCap)</td><td align="left">单层(TreasuryCap)</td></tr><tr><td align="left"><strong>操作验证</strong></td><td align="left">必须通过策略规则验证</td><td align="left">无需验证</td></tr><tr><td align="left"><strong>代币转移</strong></td><td align="left">需要创建和确认ActionRequest</td><td align="left">直接转移</td></tr><tr><td align="left"><strong>供应量控制</strong></td><td align="left">更精细(支持暂存余额)</td><td align="left">直接增减</td></tr><tr><td align="left"><strong>灵活性</strong></td><td align="left">支持自定义规则和操作</td><td align="left">固定操作集</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">监管严格的应用</td><td align="left">通用代币</td></tr></tbody></table><p><strong>结构区别</strong></p><img src="/2025/02/23/qu-kuai-lian/coin-token-yi-ji-balance-de-qu-bie/CoinBalanceToken.png" alt="CoinBalanceToken" style="zoom:80%;"><p><strong>API区别</strong></p><img src="/2025/02/23/qu-kuai-lian/coin-token-yi-ji-balance-de-qu-bie/api区别-17471474544153.png" alt="api区别" style="zoom: 80%;"><h2 id="Coin-Open-loop-fungible-token"><a href="#Coin-Open-loop-fungible-token" class="headerlink" title="Coin -  Open-loop fungible token"></a>Coin -  Open-loop fungible token</h2><p><strong>💡含义</strong>： 可以自由转让，能和其他Coin实现互换，自由流动，key+store(可包装）。类似于rmb，拥有者可以自由地支配他</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct Coin&lt;phantom T&gt; has key, store { id: UID, balance: Balance&lt;T&gt; }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>一般称 Coin 为“币”，称 Token 为 “代币”</p><p>怎么理解可包装</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Foo has key {</span><br><span class="line"> id: UID,</span><br><span class="line"> bar: Bar,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">struct Bar has store {</span><br><span class="line"> value: u64,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3><p>具体使用可以结合官方仓库中sui::coin的模块进行学习</p><p><strong>创建代币</strong>：采用coin::create_currency，返回一个<code>treasury</code>和<code>metadate</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let (treasury_cap, metadata) = coin::create_currency&lt;HOH&gt;(</span><br><span class="line">       otw,</span><br><span class="line">       DECIMALS,</span><br><span class="line">       SYMBOLS, </span><br><span class="line">       NAME, </span><br><span class="line">       DESCRIPTION, </span><br><span class="line">       option::some(new_unsafe_from_bytes(ICON_URL)), </span><br><span class="line">       ctx</span><br><span class="line">   );</span><br></pre></td></tr></tbody></table></figure><ul><li><p><code>metadate</code>主要包括一个coin所拥有的字节</p><ul><li><pre><code class="move">  public struct CoinMetadata&lt;phantom T&gt; has key, store {      id: UID,      ///定义了如何将链上存储的整数值 N 转换为用户友好的小数格式（如 UI 显示或交易所报价）      ///decimals 仅用于显示逻辑，链上存储的 value 始终是整数      decimals: u8,      name: string::String,      /// 代币符号      symbol: ascii::String,      description: string::String,      /// 代币图片      icon_url: Option&lt;Url&gt;  }  //为什么需要 decimals？  //1.不同代币可能有不同的最小单位（如 BTC 用 8 位小数，USDC 用 6 位）。//decimals 确保前端能正确解析。  //2.避免浮点数问题  //链上只存整数（如 7002），通过 decimals 在链下转换为小数，避免浮点数计算的复杂性。  //3.兼容性  //与 ERC-20 等标准的小数位设计一致，减少跨链或跨协议时的适配成本</code></pre></li></ul></li><li><p><code>TreasuryCap</code>代表了一个代币的mint和burn权限，通常由项目方或者治理人拥有，用于初始代币分发、增发代币、代币销毁、代币供应量管理等</p><ul><li><pre><code class="move">public struct TreasuryCap&lt;phantom T&gt; has key, store {    id: UID,    ///代币的总供应量    total_supply: Supply&lt;T&gt;}<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">一个比较完整Coin示例如下：</span><br><span class="line"></span><br><span class="line">```move</span><br><span class="line">module my_coin::my_coin {</span><br><span class="line">    use sui::coin::{Self, TreasuryCap, Coin};</span><br><span class="line">    use sui::transfer;</span><br><span class="line">    use sui::tx_context::TxContext;</span><br><span class="line"></span><br><span class="line">    // 1. 定义代币类型（需 one-time witness 模式）</span><br><span class="line">    struct MY_COIN has drop {}</span><br><span class="line"></span><br><span class="line">    // 2. 初始化函数（设置初始供应量）</span><br><span class="line">    public entry fun init(</span><br><span class="line">        ctx: &amp;mut TxContext</span><br><span class="line">    ) {</span><br><span class="line">        let (treasury_cap, metadata) = coin::create_currency(</span><br><span class="line">            MY_COIN {}, // one-time witness</span><br><span class="line">            9,          // decimals（例如 9 位小数）</span><br><span class="line">            b"MYC",     // symbol</span><br><span class="line">            b"My Coin", // name</span><br><span class="line">            b"My custom coin", // description</span><br><span class="line">            none(),     // icon_url（可选）</span><br><span class="line">            ctx</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 3. 设置初始供应量：铸造 1_000_000_000 个代币（假设 1 个整单位 = 1 MYC）</span><br><span class="line">        let total_supply = 1_000_000_000;</span><br><span class="line">        let initial_coins = coin::mint(&amp;mut treasury_cap, total_supply, ctx);</span><br><span class="line"></span><br><span class="line">        // 4. 将初始代币发送到指定地址（例如项目方地址）</span><br><span class="line">        let recipient = @0x123; // 替换为实际地址</span><br><span class="line">        transfer::public_transfer(initial_coins, recipient);</span><br><span class="line"></span><br><span class="line">        // 5. 转移 TreasuryCap 到安全地址（如治理合约）</span><br><span class="line">        transfer::public_transfer(treasury_cap, @0x456);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></code></pre></li></ul></li></ul><hr><h2 id="Token-Closed-Loop-Token"><a href="#Token-Closed-Loop-Token" class="headerlink" title="Token - Closed-Loop Token"></a>Token - Closed-Loop Token</h2><p><strong>💡含义</strong>：当你相对用户的权限做一些限制的时候，可以发布一个Token，制定自己的代币经济模型，来限制可以使用代币的应用程序，以及转账、消费和交换的规则；类似于创建一个受到限制和监控的银行账户</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct Token&lt;phantom T&gt; has key { id: UID, balance: Balance&lt;T&gt; }</span><br></pre></td></tr></tbody></table></figure><p><strong>🔦与Coin不同</strong>：Token 则仅具备<code>key</code>功能，无法被包装、存储为动态字段或自由转账（除非有自定义策略）。由于此限制，Token<strong>只能由账户拥有</strong>，无法存储在应用程序中，但可以“spend”,这个下文会讲到。</p><p><strong>重要模块</strong>：<code>TokenPolicyCap</code> <code>TreasuryCap </code> <code>ActionRequest</code></p><ul><li><p><code>TokenPolicyCap</code>：定义 <code>Token</code> 的操作规则。它包含了哪些操作是允许的，以及每个操作需要满足的规则集合</p><ul><li><pre><code class="move">public struct TokenPolicy&lt;phantom T&gt; has key {    id: UID,                          // `TokenPolicy` 的唯一标识符。    spent_balance: Balance&lt;T&gt;,        // 用户在 "spend" 操作中消耗的余额。    rules: VecMap&lt;String, VecSet&lt;TypeName&gt;&gt;, // 定义每个操作的规则集合。}<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `TreasuryCap`：这里和Coin模块中的是一致的，不过多解释</span><br><span class="line"></span><br><span class="line">- `ActionRequest`：每一个受监管的行为发生的时候，都会发出一个`ActionRequest`，同时ActionRequest需要一个`confirm_request`来解决 ，在 `confirm_request` 或 `confirm_request_mut` 中，`ActionRequest` 会与 `TokenPolicy` 的规则进行匹配，确保操作符合策略</span><br><span class="line"></span><br><span class="line">  - ```move</span><br><span class="line">    public struct ActionRequest&lt;phantom T&gt; {</span><br><span class="line">        name: String,                     // 操作的名称，例如 "transfer" 或 "spend"。</span><br><span class="line">        amount: u64,                      // 操作涉及的金额。</span><br><span class="line">        sender: address,                  // 操作的发起者地址。</span><br><span class="line">        recipient: Option&lt;address&gt;,       // 接收者地址，仅在 "transfer" 操作中存在。</span><br><span class="line">        spent_balance: Option&lt;Balance&lt;T&gt;&gt;, // 操作中消耗的余额，仅在 "spend" 操作中存在。</span><br><span class="line">        approvals: VecSet&lt;TypeName&gt;,      // 已完成规则的批准集合。</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></code></pre></li></ul></li></ul><blockquote><p>💡Hot_Potato</p><p>ActionRequest是一个没有任何能力的结构体也称作”Hot-Potato”,它涉及一个没有任何能力的结构体，称为 “hot potato”。这种结构体只能在其模块内进行打包和解包。Hot Potato Pattern 利用 PTB（Programmatic Transaction Block）机制，通常用于在交易结束之前强制用户完成特定业务逻辑的场景。</p><p>简单来说，如果一个交易命令 A 返回一个 hot potato 值，则必须在同一个 PTB 中的任何后续命令 B 中消费它。最常见的用例是闪电贷（flashloan）。</p></blockquote><h3 id="典型工作流程"><a href="#典型工作流程" class="headerlink" title="典型工作流程"></a>典型工作流程</h3><ol><li><p>初始化：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let (policy, policy_cap) = token::new_policy(&amp;treasury_cap, ctx);</span><br><span class="line">token::share_policy(policy);</span><br><span class="line">/// 创建一个新的 `TokenPolicy` 和一个匹配的 `TokenPolicyCap`。</span><br><span class="line">/// 然后必须使用 `share_policy` 方法共享 `TokenPolicy`。</span><br></pre></td></tr></tbody></table></figure></li><li><p>设置规则：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">///允许transfer操作可以自由使用</span><br><span class="line">token::allow(&amp;mut policy, &amp;policy_cap, b"transfer", ctx);</span><br><span class="line">///为transfer操作添加一个规则</span><br><span class="line">token::add_rule_config(rule_witness, &amp;mut policy, &amp;policy_cap, config, ctx);</span><br></pre></td></tr></tbody></table></figure></li><li><p>执行操作：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let request = token::transfer(token, recipient, ctx);</span><br><span class="line">let (_, amount, sender, _) = token::confirm_request(&amp;policy, request, ctx);</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="Public-公共操作"><a href="#Public-公共操作" class="headerlink" title="Public  - 公共操作"></a>Public  - 公共操作</h3><p>Token有一系列公共和保护操作用来管理代币。公共操作对所有人可用，不需要任何授权。</p><ul><li>token::keep - 将代币发送给交易发送者</li><li>token::join - 合并两个代币</li><li>token::split - 将一个代币分成两个，指定分割的金额</li><li>token::zero - 创建一个空（零余额）的代币</li><li>token::destroy_zero - 销毁一个零余额的代币</li></ul><h3 id="Protected-受监管的操作"><a href="#Protected-受监管的操作" class="headerlink" title="Protected  - 受监管的操作"></a>Protected  - 受监管的操作</h3><p>注：默认是禁用的，可以在TokenPolicy中启用，并自定义规则</p><p>保护操作是那些发出ActionRequest的操作。有三种主要的方法来解决ActionRequest，最常见的是通过TokenPolicy。</p><ul><li>token::transfer - 将代币转账到指定地址</li><li>token::to_coin - 将token转换为coin</li><li>token::from_coin - 将coin转换为token</li><li>token::spend - 在指定地址花费代币</li></ul><h3 id="Spend"><a href="#Spend" class="headerlink" title="Spend"></a>Spend</h3><p><strong>💡含义</strong>: 由于<code>Token</code>类型不具备这种<code>store</code>能力，因此无法将它们存储在另一个对象中。因此，<code>Coin</code>类似 的消费方式无法实现——接受<code>Token</code>付款的应用程序无法将其添加到其余额中。为了解决这个问题，<code>Token</code>有一种<code>spend</code>方法，允许在一个应用程序中消费它，然后将其作为 spent_balance交付<code>TokenPolicy</code>或者立即使用 TreasuryCap`进行销毁。</p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>解构 <code>Token</code>，提取其唯一标识符和余额 (<code>id</code> 和 <code>balance</code>)，删除 <code>Token</code> 对象后，调用 <code>new_request</code> 创建 <code>ActionRequest</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public fun spend&lt;T&gt;(token: Token&lt;T&gt;, ctx: &amp;mut TxContext): ActionRequest&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure><ol><li><strong>实现 <code>Token</code> 的消费逻辑</strong>:<ul><li><code>spend</code> 函数允许用户销毁 <code>Token</code>，并将其余额记录为消费余额。</li><li>这是 <code>Token</code> 模块中一个重要的操作，支持多种应用场景。</li></ul></li><li><strong>与 <code>TokenPolicy</code> 的规则集成</strong>:<ul><li><code>spend</code> 操作必须符合 <code>TokenPolicy</code> 的规则，确保消费操作受到严格控制。</li><li>通过规则验证机制，可以灵活定义哪些消费操作是允许的。</li></ul></li><li><strong>支持供应量管理</strong>:<ul><li>消费的余额会被记录在 <code>TokenPolicy.spent_balance</code> 中。</li><li>只有 <code>TreasuryCap</code> 的所有者可以通过 <code>flush</code> 函数减少供应量，从而实现对 <code>Token</code> 总供应量的精细管理。</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> move智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2024/12/25/hou-duan/springmvc/"/>
      <url>/2024/12/25/hou-duan/springmvc/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p><strong>Spring MVC</strong>（Spring Model-View-Controller）是一个基于 <strong>Java</strong> 的 Web 应用框架，是 <strong>Spring Framework</strong> 的一部分。Spring MVC 的设计灵感来源于传统的 <strong>MVC（Model-View-Controller）</strong> 设计模式，它用于构建 web 应用程序，并且将应用程序的表现层与业务逻辑层分开，促进了松耦合的开发。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ol><li><strong>Model（模型）</strong></li></ol><ul><li>表示应用程序的数据和业务逻辑，通常由 <strong>JavaBeans</strong> 或 <strong>POJO（Plain Old Java Object）</strong> 组成。</li><li>负责处理数据并返回给视图层（View）。</li></ul><ol start="2"><li><strong>View（视图）</strong></li></ol><ul><li>负责呈现数据的界面层，通常是 <strong>JSP（JavaServer Pages）</strong>、<strong>Thymeleaf</strong> 或 <strong>FreeMarker</strong> 等模板。</li><li>视图层将显示由模型层提供的数据，并响应用户请求。</li></ul><ol start="3"><li><strong>Controller（控制器）</strong></li></ol><ul><li>作为请求的入口点，接收并处理用户的请求，协调模型和视图之间的交互。</li><li><strong>Controller</strong> 接收来自用户的请求，调用相应的业务逻辑（如服务层），并决定应该呈现哪个视图。</li></ul><h2 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h2><ol><li><p>用户通过浏览器发送请求到 <strong>DispatcherServlet</strong>（前端控制器）。</p></li><li><p><strong>DispatcherServlet</strong> 将请求委派给合适的 <strong>Controller</strong>，该控制器处理业务逻辑。</p></li><li><p>控制器与 <strong>Model</strong> 交互，并将数据填充到 <strong>Model</strong> 中。</p></li><li><p>控制器返回一个逻辑视图名（例如 “home”），<strong>DispatcherServlet</strong> 根据视图解析器的配置，选择正确的视图（如 JSP 或 Thymeleaf）进行渲染。</p></li><li><p>最终，<strong>View</strong> 将数据呈现给用户。</p><p><img src="/2024/12/25/hou-duan/springmvc/image.png" alt="image-20241225141556768"></p></li></ol><h2 id="关键组件："><a href="#关键组件：" class="headerlink" title="关键组件："></a>关键组件：</h2><ul><li><strong>DispatcherServlet</strong>：作为前端控制器，所有请求都由它进行统一的分发。</li><li><strong>HandlerMapping</strong>：根据请求的 URL 映射到对应的控制器方法。</li><li><strong>Controller</strong>：处理业务逻辑，响应用户请求。</li><li><strong>ViewResolver</strong>：视图解析器，根据视图名称选择并渲染具体的视图。</li><li><strong>ModelAndView</strong>：封装了模型数据和视图信息的对象。</li></ul><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li><strong>松耦合</strong>：Spring MVC 使用配置文件和注解解耦，便于灵活配置和扩展。</li><li><strong>RESTful 支持</strong>：支持构建 RESTful Web 服务。</li><li><strong>易于集成</strong>：Spring MVC 可以与其他技术（如 Hibernate、MyBatis、JPA 等）集成，支持多种视图技术（JSP、Thymeleaf、FreeMarker 等）。</li><li><strong>灵活性</strong>：通过注解驱动的方式，可以简化开发，减少 XML 配置。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SprintBoot - IOC|AOP</title>
      <link href="/2024/12/24/hou-duan/sprintboot-ioc-aop/"/>
      <url>/2024/12/24/hou-duan/sprintboot-ioc-aop/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-boot-IOC-AOP"><a href="#Spring-boot-IOC-AOP" class="headerlink" title="Spring boot-IOC|AOP"></a>Spring boot-IOC|AOP</h1><h2 id="IOC（控制反转）"><a href="#IOC（控制反转）" class="headerlink" title="IOC（控制反转）"></a><strong>IOC（控制反转）</strong></h2><p>IOC 是一种设计原则，指的是控制权的反转。它的核心思想是将对象的创建和管理的控制权从程序中转移给外部容器或框架。这意味着，传统上程序中类之间的依赖关系是由程序代码手动创建和管理的，而在使用IOC时，框架或容器负责这些对象的创建和管理。通过IOC，程序的控制流程被反转，程序员不再显式地控制对象的创建和生命周期，而是交由容器（如Spring容器）来管理。</p><h3 id="DI（依赖注入）"><a href="#DI（依赖注入）" class="headerlink" title="DI（依赖注入）"></a><strong>DI（依赖注入）</strong></h3><p>DI 是实现IOC的一种方式，是一种将依赖关系（即对象之间的依赖）注入到对象中的设计模式。DI 通过将一个对象的依赖（例如，它需要使用的服务、数据库连接等）传递给它的构造函数、字段或方法，来实现对象间的解耦。DI 是IOC的具体实现手段之一。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>1、调用程序：不指定对象如何生成，通过标准（接口）使用。<br>2、配置文件：配置文件中需要注明哪些bean被注入，以及引用关系。<br>3、程序执行：由Spring容器通过配置文件生成所有的bean对象，从容器中取出对象进行执行。</p><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><ul><li><p>在传统的编程方式中，一个类A需要依赖类B，这时类A会自己创建类B的实例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codepublic class A {</span><br><span class="line">    private B b = new B();  // 类A自己创建类B的实例</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>而使用IOC和DI的方式，类A不会自己创建类B的实例，而是由外部容器（比如Spring）来将B的实例注入到类A中：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codepublic class A {</span><br><span class="line">    private B b;</span><br><span class="line">    </span><br><span class="line">    // 通过构造函数注入B</span><br><span class="line">    public A(B b) {</span><br><span class="line">        this.b = b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在Spring中，Spring容器会创建类A和类B的实例，并负责将B的实例注入到类A中，完成依赖注入。这样，类A不再直接依赖于类B的具体实现，而只依赖于接口或抽象类，从而实现了更松散的耦合。</p></li></ul><h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP(面向切面编程)"></a>AOP(面向切面编程)</h2><p>其编程思想是把散布于不同业务但功能相同的代码从业务逻辑中抽取出来，封装成独立的模块，这些独立的模块被称为切面，切面的具体功能方法被称为切入点。<br>在业务逻辑执行过程中，AOP会把分离出来的切面和切入点动态切入到业务流程中，这样做的好处是提高了功能代码的重用性和可维护性。</p><h3 id="核心概念："><a href="#核心概念：" class="headerlink" title="核心概念："></a>核心概念：</h3><ol><li><strong>切面（Aspect）</strong>：横切关注点的模块化，它包含了代码的增强逻辑，比如日志、事务等。一个切面通常会定义在特定的点（切入点）插入逻辑。</li><li><strong>连接点（Join Point）</strong>：程序执行过程中可以插入切面的位置，通常是方法的调用、方法的执行、构造函数的调用等。</li><li><strong>通知（Advice）</strong>：切面所执行的具体操作，表示在连接点执行的代码。通知可以分为以下几种类型：<ul><li><strong>前置通知（Before）</strong>：在目标方法执行前执行。</li><li><strong>后置通知（After）</strong>：在目标方法执行后执行（不管目标方法是否抛出异常）。</li><li><strong>返回通知（AfterReturning）</strong>：目标方法执行成功后执行。</li><li><strong>异常通知（AfterThrowing）</strong>：目标方法抛出异常后执行。</li><li><strong>环绕通知（Around）</strong>：包围目标方法的执行，允许在方法前后做增强，并且可以决定是否执行目标方法。</li></ul></li><li><strong>切入点（Pointcut）</strong>：定义在哪些连接点应用通知。通常是通过方法签名、注解等方式来指定的。</li><li><strong>目标对象（Target Object）</strong>：被增强的对象，也叫做被代理的对象。</li><li><strong>代理（Proxy）</strong>：AOP 会为目标对象创建一个代理对象，代理对象会在目标对象方法执行之前或之后插入增强的代码。</li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="1-注解定义切面类"><a href="#1-注解定义切面类" class="headerlink" title="1.注解定义切面类"></a>1.注解定义切面类</h4><p>添加切面和通知的注解<br>@Aspect – 定义切面类的注解<br>通知类型（注解的参数是切入点的表达式）<br>@Before – 前置通知<br>@AfterReturning – 后置通知<br>@Around – 环绕通知<br>@After – 最终通知<br>@AfterThrowing – 异常抛出通知</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspectXml</span> {</span><br><span class="line">    <span class="comment">// 定义通知</span></span><br><span class="line">    <span class="meta">@Before("execution(public * com.zhong.aopdemo.CustomDaoImpl.save(..))")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"记录日志..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-修改配置文件pom-xml，加入扫描生成相关的bean"><a href="#2-修改配置文件pom-xml，加入扫描生成相关的bean" class="headerlink" title="2. 修改配置文件pom.xml，加入扫描生成相关的bean"></a>2. 修改配置文件pom.xml，加入扫描生成相关的bean</h4><p>示例代码</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.zhong.aopdemo"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在配置文件中开启自动代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="常用依赖项说明"><a href="#常用依赖项说明" class="headerlink" title="常用依赖项说明"></a>常用依赖项说明</h4><h5 id=""><a href="#" class="headerlink" title="<aop:aspectj-autoproxy>"></a><code>&lt;aop:aspectj-autoproxy&gt;</code></h5><p>它会扫描容器中的 bean,检查是否有与切面相关的注解或配置，如果有，则会自动为这些 bean 创建代理对象，并将切面逻辑织入到代理对象中。</p><h5 id="spring-context"><a href="#spring-context" class="headerlink" title="spring-context"></a><code>spring-context</code></h5><p><code>spring-context</code>是Spring框架的核心模块之一，提供了与Spring IoC容器（控制反转容器）相关的功能。它包括了创建、管理、注入bean（对象）的功能。Spring容器用于管理应用程序的生命周期，提供了依赖注入（DI）等功能，是开发Java应用的基础模块。</p><h6 id="作用："><a href="#作用：" class="headerlink" title="作用："></a><strong>作用</strong>：</h6><ul><li>提供Spring核心的功能，如<code>ApplicationContext</code>、<code>BeanFactory</code>、事件发布、环境配置等。</li><li>支持XML和注解配置方式。</li><li>提供了对组件的生命周期管理（例如，单例bean、原型bean等）。</li></ul><h6 id="依赖示例："><a href="#依赖示例：" class="headerlink" title="依赖示例："></a><strong>依赖示例</strong>：</h6><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="spring-beans"><a href="#spring-beans" class="headerlink" title="spring-beans"></a><code>spring-beans</code></h5><p><code>spring-beans</code>模块提供了Spring的基础Bean管理功能，允许我们在Spring容器中创建、初始化、管理和销毁Java对象。它是Spring框架中最基础的模块，几乎所有的Spring应用都需要这个模块。</p><h6 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a><strong>作用</strong>：</h6><ul><li>处理bean的创建、依赖注入和生命周期管理。</li><li>负责bean的配置和管理，通常与<code>spring-context</code>模块一起使用。</li></ul><h6 id="依赖示例：-1"><a href="#依赖示例：-1" class="headerlink" title="依赖示例："></a><strong>依赖示例</strong>：</h6><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="spring-aop"><a href="#spring-aop" class="headerlink" title="spring-aop"></a><code>spring-aop</code></h5><p><code>spring-aop</code>模块是Spring框架的面向切面编程（AOP）模块，它为Spring应用提供了AOP支持，允许通过声明性事务管理、日志记录等功能来增强应用的功能。</p><h6 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a><strong>作用</strong>：</h6><ul><li>提供面向切面编程（AOP）的支持，使得可以在不修改源代码的情况下，向现有代码中添加功能（如日志记录、事务管理等）。</li><li>允许通过切面（Aspect）定义横切关注点（如日志、性能监控等），然后应用于目标方法。</li></ul><h6 id="依赖示例：-2"><a href="#依赖示例：-2" class="headerlink" title="依赖示例："></a><strong>依赖示例</strong>：</h6><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="spring-aspects"><a href="#spring-aspects" class="headerlink" title="spring-aspects"></a><code>spring-aspects</code></h5><p><code>spring-aspects</code>模块包含了Spring AOP的相关功能，并且在实际使用时需要<code>spring-aop</code>模块。它包含了Spring框架所需的切面功能的具体实现，如切面（Aspect）定义、增强（Advice）等。</p><h6 id="作用：-3"><a href="#作用：-3" class="headerlink" title="作用："></a><strong>作用</strong>：</h6><ul><li>这是一个专门用于与AOP相关的库，通常用于处理切面（Aspect）相关的功能，允许开发者将事务管理、日志等功能应用到Spring beans中。</li><li>通过<code>@Aspect</code>注解或配置文件配置切面和通知（Advice），以控制程序的某些行为。</li></ul><h6 id="依赖示例：-3"><a href="#依赖示例：-3" class="headerlink" title="依赖示例："></a><strong>依赖示例</strong>：</h6><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="junit"><a href="#junit" class="headerlink" title="junit"></a><code>junit</code></h5><p><code>junit</code>是一个流行的Java单元测试框架，广泛用于测试Java应用的功能。JUnit提供了一种规范化的方式来编写和运行测试用例，确保代码的正确性和稳定性。JUnit用于编写测试类，测试项目中的功能模块。</p><h6 id="作用：-4"><a href="#作用：-4" class="headerlink" title="作用："></a><strong>作用</strong>：</h6><ul><li>用于编写自动化的单元测试，帮助开发者验证代码功能。</li><li>提供了断言（assertions）功能来验证方法的行为是否符合预期。</li><li>常与其他测试框架结合使用，如Mockito。</li></ul><h6 id="依赖示例：-4"><a href="#依赖示例：-4" class="headerlink" title="依赖示例："></a><strong>依赖示例</strong>：</h6><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> <span class="comment">&lt;!-- 说明这个依赖只在测试环境中需要 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="常用的4种创建Bean的注解："><a href="#常用的4种创建Bean的注解：" class="headerlink" title="常用的4种创建Bean的注解："></a>常用的4种创建Bean的注解：</h4><h5 id="1-Component"><a href="#1-Component" class="headerlink" title="1. @Component"></a>1. <strong>@Component</strong></h5><ul><li><strong>作用</strong>：通用的组件注解，用于标识当前类是一个 Spring 的组件。</li><li><strong>功能</strong>：Spring 会将标注了 <code>@Component</code> 的类识别为一个 Bean，并将其实例化并加入到 Spring 的容器中。</li><li><strong>适用场景</strong>：当某个类不属于特殊的功能分类（如控制器、服务层、数据访问层）时，可以使用 <code>@Component</code>。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"执行组件逻辑..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h5 id="2-Controller"><a href="#2-Controller" class="headerlink" title="2. @Controller"></a>2. <strong>@Controller</strong></h5><ul><li><strong>作用</strong>：用于标注控制层组件，专门处理用户请求。</li><li>功能<ul><li>在 MVC 架构中，<code>@Controller</code> 是用来定义控制器的，负责处理 HTTP 请求。</li><li>配合 <code>@RequestMapping</code> 注解定义 URL 映射。</li></ul></li><li><strong>适用场景</strong>：适用于处理前端发来的请求（如 Web 应用开发中的 RESTful API）。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> {</span><br><span class="line">    <span class="meta">@RequestMapping("/hello")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, Spring!"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h5 id="3-Service"><a href="#3-Service" class="headerlink" title="3. @Service"></a>3. <strong>@Service</strong></h5><ul><li><p><strong>作用</strong>：用于标注服务层组件，表示该类主要负责业务逻辑。</p></li><li><p>功能</p><p>：</p><ul><li>通常与业务逻辑相关的类会使用 <code>@Service</code> 注解。</li><li>与 <code>@Component</code> 功能相同，但语义化更强，表明这是一个“服务层”组件。</li></ul></li><li><p><strong>适用场景</strong>：适用于包含核心业务逻辑的类。</p></li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGreeting</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"欢迎来到服务层!"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h5 id="4-Repository"><a href="#4-Repository" class="headerlink" title="4. @Repository"></a>4. <strong>@Repository</strong></h5><ul><li><strong>作用</strong>：用于标注数据访问层（DAO）的组件，专门处理数据库操作。</li><li>功能<ul><li>表示当前类是用于与数据库交互的类。</li><li>可以将数据访问层的异常转换为 Spring 的统一异常（<code>DataAccessException</code>）。</li></ul></li><li><strong>适用场景</strong>：适用于与数据库直接交互的类，如 DAO（Data Access Object）类。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRepository</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"保存数据到数据库..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><table><thead><tr><th><strong>注解</strong></th><th><strong>作用</strong></th><th><strong>典型使用场景</strong></th></tr></thead><tbody><tr><td><code>@Component</code></td><td>通用组件注解</td><td>非特定功能分类的组件类</td></tr><tr><td><code>@Controller</code></td><td>控制器，处理用户请求</td><td>Web 层，负责处理 HTTP 请求</td></tr><tr><td><code>@Service</code></td><td>服务层，处理业务逻辑</td><td>服务层，包含核心业务逻辑</td></tr><tr><td><code>@Repository</code></td><td>数据访问层，处理数据库操作</td><td>数据层，与数据库交互的类</td></tr></tbody></table><blockquote><p>💡**@Bean注解**是用在配置类（@Configuration）中声明一个Bean的，通常用在配置类中的方法上，将方法的返回值对象注入到Spring的ioc容器中。通过bean注解，我们可以创建和配置Bean的初始化过程，包括Bean的名称、作用域、依赖关系等。</p></blockquote><h4 id="JoinPoint-类"><a href="#JoinPoint-类" class="headerlink" title="JoinPoint 类"></a>JoinPoint 类</h4><p><code>JoinPoint</code> 是 AOP 提供的一个接口，用于表示连接点（Join Point）。通过它可以获取以下信息：</p><ul><li><strong>代理对象</strong>：即调用切面逻辑的对象。</li><li><strong>被代理对象</strong>：即实际被拦截的目标对象。</li><li><strong>方法签名</strong>：即被拦截方法的详细信息（如方法名、参数类型、返回类型等）。</li><li><strong>方法参数</strong>：目标方法所接收到的参数。</li></ul><h5 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a><strong>主要方法</strong></h5><ol><li><p><strong><code>Object getTarget()</code></strong></p><ul><li>返回被代理的目标对象。</li><li>例如：通过此方法可以访问原始对象以执行额外逻辑。</li></ul></li><li><p><strong><code>Object[] getArgs()</code></strong></p><ul><li>返回目标方法的参数列表（作为一个 <code>Object</code> 数组）。</li><li>可以通过此方法获取调用方法时传递的具体参数。</li></ul></li><li><p><strong><code>Signature getSignature()</code></strong></p><ul><li><p>返回当前执行方法的签名（<code>Signature</code> 是一个接口，常用实现类是 <code>MethodSignature</code>）。</p></li><li><p>通过签名可以获取方法的详细信息，例如方法名、参数类型、返回类型等。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeSignature signature = joinPoint.getSignature();</span><br><span class="line">System.out.println("方法名: " + signature.getName());</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong><code>String getKind()</code></strong></p><ul><li>返回当前连接点的类型，例如是方法执行、异常抛出等。</li></ul></li><li><p><strong><code>Object getThis()</code></strong></p><ul><li>返回当前代理对象本身。</li></ul></li></ol><h5 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a><strong>适用范围</strong></h5><p><code>JoinPoint</code> 通常用于以下通知：</p><ul><li><strong>前置通知</strong>（<code>@Before</code>）：在目标方法执行之前运行。</li><li><strong>后置通知</strong>（<code>@After</code>）：在目标方法执行之后运行。</li><li><strong>异常通知</strong>（<code>@AfterThrowing</code>）：在目标方法抛出异常后运行。</li><li><strong>最终通知</strong>（<code>@AfterReturning</code>）：在目标方法正常返回后运行。</li></ul><h4 id="ProceedingJoinPoint-类"><a href="#ProceedingJoinPoint-类" class="headerlink" title="ProceedingJoinPoint 类"></a><strong>ProceedingJoinPoint 类</strong></h4><p><code>ProceedingJoinPoint</code> 是 <code>JoinPoint</code> 的子接口，它在 <code>JoinPoint</code> 的基础上增加了一个非常重要的方法：<code>proceed()</code>。它仅在<strong>环绕通知</strong>（<code>@Around</code>）中使用。</p><h5 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a><strong>核心方法</strong></h5><ol><li><p><strong><code>Object proceed()</code></strong></p><ul><li>作用：启动目标方法的执行。</li><li>环绕通知逻辑中通常会调用此方法来执行被拦截的目标方法。</li><li>可以将其看作是 AOP 的核心，用于控制目标方法的实际调用。</li></ul></li><li><p><strong><code>Object proceed(Object[] args)</code></strong></p><ul><li><p>作用：与 <code>proceed()</code> 类似，但允许传递新的参数来改变目标方法的行为。</p></li><li><p>通过修改参数列表，可以改变目标方法所接收到的参数。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Copy code</span><br><span class="line">Object result = proceedingJoinPoint.proceed(newArgs);</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><h6 id="环绕通知的使用"><a href="#环绕通知的使用" class="headerlink" title="环绕通知的使用"></a><strong>环绕通知的使用</strong></h6><p>环绕通知包含前置、目标方法执行、后置通知的组合，通过 <code>proceed()</code> 方法控制目标方法的执行。以下是环绕通知的典型实现：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code@Around("execution(* com.example.service.*.*(..))")</span><br><span class="line">public Object aroundAdvice(ProceedingJoinPoint pjp) throws Throwable {</span><br><span class="line">    System.out.println("前置通知：方法执行前");</span><br><span class="line"></span><br><span class="line">    // 获取方法名</span><br><span class="line">    String methodName = pjp.getSignature().getName();</span><br><span class="line">    System.out.println("方法名：" + methodName);</span><br><span class="line"></span><br><span class="line">    // 执行目标方法</span><br><span class="line">    Object result = pjp.proceed();</span><br><span class="line"></span><br><span class="line">    System.out.println("后置通知：方法执行后");</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sui-move学习笔记</title>
      <link href="/2024/09/30/qu-kuai-lian/sui-move-xue-xi-bi-ji/"/>
      <url>/2024/09/30/qu-kuai-lian/sui-move-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<hr><p>参考资料：</p><ul><li><p>基本语法 ：<a href="https://www.bilibili.com/video/BV1Rm42177Kx/">https://www.bilibili.com/video/BV1Rm42177Kx/</a></p></li><li><p>相关书籍：</p><ul><li>轻松入门：<a href="https://easy.sui-book.com/chapter_1.html">https://easy.sui-book.com/chapter_1.html</a> </li><li>Move参考手册：<a href="https://reference.sui-book.com/introduction.html">https://reference.sui-book.com/introduction.html</a></li></ul></li></ul><hr><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量这一章比较简单， <a href="https://reference.sui-book.com/packages.html">轻松入门sui</a>: <a href="https://reference.sui-book.com/packages.html">https://reference.sui-book.com/packages.html</a> 中写得也非常详细！</p><p>let _a = 10u32;//下划线开头，表示后续没有使用</p><h1 id="包-模块-方法"><a href="#包-模块-方法" class="headerlink" title="包-模块-方法"></a>包-模块-方法</h1><p><strong>包</strong>：包是同一个合约地址包含的全部代码的集合，由很多模块组成，也就是<code>sui move new &lt;name&gt;</code>生成的文件夹</p><p>a_move_package<br>├── Move.toml      (必需)<br>├── Move.lock      (生成的)<br>├── sources        (必需)<br>├── doc_templates  (可选)<br>├── examples       (可选，测试和开发模式)<br>└── tests          (可选，测试模式)</p><blockquote><p>有关包下具体的配置信息，可以参见 </p></blockquote><p><strong>模块</strong>-module：代码模块是代码划分访问权限和代码的组织方式</p><p>创建格式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &lt;address&gt;::&lt;name&gt;{</span><br><span class="line">  use sui::tx_context::TxContext;</span><br><span class="line">  fun init(ctx: &amp;mut TxContext) {</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="方法访问权限控制"><a href="#方法访问权限控制" class="headerlink" title="方法访问权限控制"></a><strong>方法访问权限控制</strong></h2><p>我把这里的方法理解为其他语言中的函数</p><table><thead><tr><th>方法签名</th><th>调用范围</th><th>返回值</th></tr></thead><tbody><tr><td>fun  call()</td><td>只能模块内调用</td><td>可以有</td></tr><tr><td>public fun call()</td><td>全部合约能调用</td><td>可以有</td></tr><tr><td>public entry fun call()</td><td>全部合约和Dapp(RPC)能调用</td><td>无</td></tr><tr><td>entry fun call()</td><td>只能Dapp(RPC)调用</td><td>无</td></tr><tr><td>public(package) fun call()</td><td>只能当前的包能调用</td><td>可以有</td></tr></tbody></table><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun a(){</span><br><span class="line">}</span><br><span class="line">//全局可调用</span><br><span class="line">public fun b(){</span><br><span class="line">}</span><br><span class="line">//只能声明package的包可调用（当前包也可调用） </span><br><span class="line">public(package) fun c(){}</span><br><span class="line">//全部合约和Dapp(RPC)能调用</span><br><span class="line">public entry fun d(){</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public  fun f(a:u32, b:u32): bool{</span><br><span class="line">   a &gt; b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>init 方法</strong></p><p>只能是私有的</p><p>会在发布合约的是时候自动调用一次</p><p>只有两种形式</p><ul><li><p><strong>fun</strong> <strong>init (ctx: &amp;mut TxContext){}</strong></p></li><li><p><strong>fun init (witness: Struct, ctx: &amp;mut TxContext) {}</strong></p></li></ul><h1 id="引用-注释"><a href="#引用-注释" class="headerlink" title="引用-注释"></a>引用-注释</h1><p>mut: 可变引用 </p><p>&amp;：不可变引用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let mut a: u32 = 32;//mut表示 后续会改变它</span><br><span class="line">a = 64;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>这里比较简单，与其他语言差不多，结合代码学习很快就能上手</p><p>if-条件语句</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (condition) true_branch // implied default: else ()</span><br><span class="line">if (condition) true_branch else ()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// x and y must be u64 integers</span><br><span class="line">//这里意思为 x&gt;y时,返回x; x&lt;y时,返回y</span><br><span class="line">let maximum: u64 = if (x &gt; y) x else y;</span><br><span class="line"></span><br><span class="line">// ERROR! branches different types</span><br><span class="line">let z = if (maximum &lt; 10) 10u8 else 100u64;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>while-循环语句</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun sum(n: u64): u64 {</span><br><span class="line">   let mut sum = 0;</span><br><span class="line">   let mut i = 1;</span><br><span class="line">   while (i &lt;= n) {</span><br><span class="line">       sum = sum + i;</span><br><span class="line">       i = i + 1</span><br><span class="line">   };</span><br><span class="line"></span><br><span class="line">   sum</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>break-跳出循环</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun min_factor(n: u64): u64 {</span><br><span class="line">   let mut i = 2;</span><br><span class="line">   while (i &lt;= n) {</span><br><span class="line">       if (n % i == 0) break;</span><br><span class="line">       i = i + 1</span><br><span class="line">   };</span><br><span class="line"></span><br><span class="line">   i</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>continue-跳过当前条件的循环，直接进入下一个<code>应该进入循环</code>的值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun sum(n: u64): u64 {</span><br><span class="line">   let mut sum = 0;</span><br><span class="line">   let mut i = 0;</span><br><span class="line">   while (i &lt; n) {</span><br><span class="line">       i = i + 1;</span><br><span class="line">       if (i % 20 == 0) continue;</span><br><span class="line">       sum = sum + i;</span><br><span class="line">   };</span><br><span class="line"></span><br><span class="line">   sum</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>loop-只有遇到break时才跳出循环</p><p>相当于 c语言中的while(1)，这里等价于while(true)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun sum(n: u64): u64 {</span><br><span class="line">   let mut sum = 0;</span><br><span class="line">   let mut i = 0;</span><br><span class="line">   loop {</span><br><span class="line">       i = i + 1;</span><br><span class="line">       if (i &gt; n) break;</span><br><span class="line">       sum = sum + i</span><br><span class="line">   };</span><br><span class="line">   sum</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="结构体-所有权-对象"><a href="#结构体-所有权-对象" class="headerlink" title="结构体-所有权-对象"></a>结构体-所有权-对象</h1><h2 id="struct-结构体"><a href="#struct-结构体" class="headerlink" title="struct-结构体"></a>struct-结构体</h2><p>结构体是自定义类型，由字段组成，可以简单地理解成”key-value”存储，其中 key 是字段的名称，而 value 是存储的内容，使用关键字 struct 定义，可以为空。</p><p>注：结构体只能在模块内部定义，并且以关键字 <strong>public</strong> <strong>struct</strong> 开头，结构体名称首字母需要大写</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public struct NAME {</span><br><span class="line">    FIELD1: TYPE1,</span><br><span class="line">    FIELD2: TYPE2,</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="UTXO"><a href="#UTXO" class="headerlink" title="*UTXO"></a>*UTXO</h2><p>每个交易产生一个或多个UTXO，每一个UTXO都对应者一个ID，代表未花费的金额，可以简单理解为你的零钱。</p><p>sui基于UTXO模型</p><h2 id="object-对象"><a href="#object-对象" class="headerlink" title="object-对象"></a>object-对象</h2><p>对象在Sui上存储，维护了一个全局的Map数据结构 Map&lt;ID,object&gt;， id 是唯一的，通过这个唯一的id 查找到object。</p><p>sui上的<strong>资产</strong>都是对象，对象可以相互嵌套，所有的对象都是全局存储。</p><h3 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h3><ul><li><p><strong>必须有</strong> <strong>key</strong> <strong>能力</strong></p></li><li><p>必须第一个字段 是id,而且类型为<strong>sui::object::UID</strong></p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module book::obj {</span><br><span class="line">    use sui::object::UID;</span><br><span class="line">    public struct Obj has key {</span><br><span class="line">        id:UID,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h1><h2 id="定义资产"><a href="#定义资产" class="headerlink" title="定义资产"></a>定义资产</h2><p>资产也就是个人拥有所有权的物品合集</p><p> <strong>常见资产</strong>：银行余额，支付宝微信余额，房产等。</p><h2 id="资产所有权"><a href="#资产所有权" class="headerlink" title="资产所有权"></a>资产所有权</h2><p>资产所有权可以分为：独有资产和共有资产，拥有所有权，则可以改变、删除、增加资产内容。</p><p>在Object中可以用关键字来标记所有权的类型，也就是<strong>能力</strong>，具体在下一章</p><p>分为：</p><ul><li>key</li><li>copy </li><li>drop</li><li>store</li></ul><h2 id="所有权在函数之间的三种传递方式"><a href="#所有权在函数之间的三种传递方式" class="headerlink" title="所有权在函数之间的三种传递方式"></a>所有权在函数之间的三种传递方式</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun f(consume: T, write: &amp;mut T, read: &amp;T)</span><br><span class="line">T: transfer, delete, write, read//权限最高</span><br><span class="line">&amp;mut T: write, read</span><br><span class="line">&amp;T: read</span><br><span class="line">//示例</span><br><span class="line">    public fun del(dog:Dog){</span><br><span class="line">        let Dog{id,gender,age} = dog;</span><br><span class="line">        object::delete(id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public fun transfer(dog: &amp;mut Dog,age:u8){</span><br><span class="line">        dog.age = 18</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public fun view_dog(dog:Dog){</span><br><span class="line">        dog.age</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="所有权的方法"><a href="#所有权的方法" class="headerlink" title="所有权的方法"></a>所有权的方法</h2><table><thead><tr><th>方法</th><th>生成的方法</th><th>属性</th></tr></thead><tbody><tr><td>transfer</td><td>独享对象</td><td>key</td></tr><tr><td>public_transfer</td><td>独享对象</td><td>key + store</td></tr><tr><td>freeze_object</td><td>共享对象 - 常量</td><td>key</td></tr><tr><td>public_freeze_object</td><td>共享对象 - 常量</td><td>key + store</td></tr><tr><td>share_object</td><td>共享对象</td><td>key</td></tr><tr><td>public_share_object</td><td>共享对象</td><td>key + store</td></tr></tbody></table><h1 id="能力-Event-常量错误处理"><a href="#能力-Event-常量错误处理" class="headerlink" title="能力-Event-常量错误处理"></a>能力-Event-常量错误处理</h1><h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><p>四种能力可以相互组合</p><ul><li>key - 被值修饰的键可以对全局进行访问。</li><li>copy - 被修改的值可以被复制。</li><li>drop - 被成员函数在作用域结束时被丢弃。</li><li>store被修改的建议 存储在紧急情况下</li></ul><p>没有任何能力：只能存活在同一个交易中</p><p>只有key：对象，自定义转移规则，对象有全局ID，可以被全局存储和查找（实现灵魂绑定）</p><p>只有drop：被修饰的值在离开作用域的时候会被自动解构 (删除)，基本数据类型默认实现了drop</p><p>只有store：没法使用所有权，可以通过放在其他结构体中来实现所有权的使用，实现结构体的嵌套</p><p>key + store：对象，可以被任意转移，不被转移规则限定，对象有全局ID，可以被全局存储和查找</p><p><font color="red">注</font></p><p><font color="red">：</font></p><font color="red"><ul><li>key 和 dorp 不能同时存在，也就是对资产进行操作后，不会销毁资产</li><li>key 和 copy不能同时存在，也就是资产不可复制</li></ul><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>打印日志：copy+drop</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>不会更改的量即为常量，创建常量<code>const Name : Type = Value</code></p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li><p>abort 配合if语句来终止程序</p></li><li><p>assert!(num&gt;10,ErrMustGet10) 断言，不满足条件时报错</p></li><li><p>debug 调试代码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module std::debug {</span><br><span class="line">//打印数值</span><br><span class="line">   native public fun print&lt;T&gt;(x: &amp;T);</span><br><span class="line">//打印当前堆栈</span><br><span class="line">   native public fun print_stack_trace();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型是具体类型或其他属性的抽象替代品，使得在编写 Move 代码时提供更强的灵活性，并避免逻辑重复。</p><p>我理解的泛型，就是在起初定义结构体/方法时<strong>不定义其类型</strong>，在后续使用时再定义类型。这样一个语句就能被多次使用，从而避免了重复定义类似的结构体。</p><p>结构体泛型示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module generics::obj_generics {</span><br><span class="line">    public struct Box&lt;T&gt; {</span><br><span class="line">        value: T</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">//定义多个泛型</span><br><span class="line">public struct Box&lt;T,Y,X&gt; {</span><br><span class="line">        value1: T,</span><br><span class="line">        value2: Y,</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line"> //使用泛型</span><br><span class="line"> fun init(ctx:&amp;mut TxContext){</span><br><span class="line"> </span><br><span class="line"> let box = Box&lt;u8,u16&gt;{</span><br><span class="line"> value1:23,</span><br><span class="line"> value2:45,</span><br><span class="line"> };</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>方法泛型示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module generics::generics {</span><br><span class="line"></span><br><span class="line">   public struct Box&lt;T&gt; {</span><br><span class="line">       value: T</span><br><span class="line">   }</span><br><span class="line">  </span><br><span class="line">   public fun create_box&lt;T&gt;(value: T): Box&lt;T&gt; {</span><br><span class="line">       Box&lt;T&gt; { value }</span><br><span class="line">   }</span><br><span class="line">   //伪代码</span><br><span class="line">   let box:Box&lt;u32&gt; = create_box&lt;u32&gt;{value:1u32}</span><br><span class="line">   let box:Box&lt;u32&gt; = create_box&lt;_&gt;{value:1u32}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="泛型的能力限制"><a href="#泛型的能力限制" class="headerlink" title="泛型的能力限制"></a>泛型的能力限制</h2><p>通过store、drop、key、copy，对泛型进行约束(区别一下泛型的约束和能力的约束)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public struct Box3&lt;T: store + drop，Y:store&gt; has key, store {</span><br><span class="line">   id:UID,</span><br><span class="line">   value: T,</span><br><span class="line">   value2:X,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="泛型如何传参"><a href="#泛型如何传参" class="headerlink" title="泛型如何传参"></a>泛型如何传参</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sui client call --package $PACKAGE --module $MODULE --function "create_box" --args $OBJECT_ID --type-args "0x2::coin::Coin&lt;0x2::sui::SUI&gt;" --gas-budget 100000000</span><br></pre></td></tr></tbody></table></figure><h2 id="phanton-泛型"><a href="#phanton-泛型" class="headerlink" title="phanton 泛型"></a>phanton 泛型</h2><p>申明一个类型参数但并不使用它，用于区分或者约束</p><p>(这个我还不是很清晰，后续会补充一下)</p><p>使用场景：</p><ul><li><p>泛型未被使用</p></li><li><p>容器能力规则不满足</p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public struct Box &lt;phanton T&gt; has store{</span><br><span class="line">value: u64</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote><p>这一节主要结合代码学习：<a href="https://github.com/404ll/letsmove/tree/main/tutorial/bootcamp/08_design_pattern">https://github.com/404ll/letsmove/tree/main/tutorial/bootcamp/08_design_pattern</a></p><p>我没有将过多的代码放上来，建议自己手搓学，多写注释。</p></blockquote><h2 id="Capability-权限设计模式"><a href="#Capability-权限设计模式" class="headerlink" title="Capability 权限设计模式"></a>Capability 权限设计模式</h2><p><code>public struct AdminCap has key { id: UID }</code></p><p>当你需要对结构体进行一些操作时，必须由传入这个结构体的实例来<strong>验证你是不是有这个权限</strong>，这个权限一般来说是一个有key能力的object，同时可以适当加上store能力，可以多次使用。</p><p>实际上就是实施权限控制，有权限的人才可以调用该操作</p><p>具体示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module design_pattern::capability {</span><br><span class="line">    use std::string::{Self,String};</span><br><span class="line">    use sui::transfer</span><br><span class="line">    use sui::object::{Self, UID};</span><br><span class="line">    use sui::tx_context::{Self,TxContext};</span><br><span class="line">    </span><br><span class="line">//生成管理员权限结构体</span><br><span class="line">    public struct AdminCap has key { id: UID }</span><br><span class="line">//类似于NFT的类型</span><br><span class="line">    public struct Item has key, store { id: UID, name: String }</span><br><span class="line">//创建一个管理员权限，并传递给发行者</span><br><span class="line">    fun init(ctx: &amp;mut TxContext) {</span><br><span class="line">        let my_address =  ctx.sender();</span><br><span class="line">        let addmin_cap = AdminCap {</span><br><span class="line">            id: object::new(ctx)</span><br><span class="line">        };</span><br><span class="line">        //将权限转移transfer::transfer(addmin_cap, my_address);</span><br><span class="line">        let addmin_cap2 = AdminCap {</span><br><span class="line">            id: object::new(ctx)</span><br><span class="line">        };        transfer::transfer(addmin_cap2, @0x1111);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    //运行示例</span><br><span class="line">    public fun create_and_send(</span><br><span class="line">    //检验</span><br><span class="line">        _: &amp;AdminCap, name: vector&lt;u8&gt;, to: address, ctx: &amp;mut TxContext</span><br><span class="line">    ) {</span><br><span class="line">        transfer::transfer(Item {</span><br><span class="line">            id: object::new(ctx),</span><br><span class="line">            name: name.to_string()</span><br><span class="line">        }, to)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="witness-见证者设计模式"><a href="#witness-见证者设计模式" class="headerlink" title="witness 见证者设计模式"></a>witness 见证者设计模式</h2><p><code>public struct Name has drop {}</code></p><p>简单理解为 这个结构体（资源）创建出来的实例是为了<code>见证</code>另一个资源的创建，类似于做标记。</p><p><font color="red">注<font>：此结构体没有字段，只有drop（销毁）能力，实例只能使用一次</font></font></p><p>示例代码:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module design::guardian {</span><br><span class="line"></span><br><span class="line">    public struct Guardian&lt;phantom T: drop&gt; has key, store {</span><br><span class="line">        id: UID</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public fun create_guardian&lt;T: drop&gt;(</span><br><span class="line">    //做标记，见证Guardian资源的创建</span><br><span class="line">        _witness: T, ctx: &amp;mut TxContext</span><br><span class="line">    ): Guardian&lt;T&gt; {</span><br><span class="line">        Guardian { id: object::new(ctx) }</span><br><span class="line">    }</span><br><span class="line">    //结束后删除</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">module design::peace_guardian {</span><br><span class="line">    use design::guardian;</span><br><span class="line"></span><br><span class="line">    public struct PEACE has drop {}</span><br><span class="line"></span><br><span class="line">    fun init(ctx: &amp;mut TxContext) {</span><br><span class="line">//生成对应的示例</span><br><span class="line">        let peace = PEACE{};</span><br><span class="line">        transfer::public_transfer(</span><br><span class="line">            guardian::create_guardian(peace, ctx),</span><br><span class="line">            ctx.sender()</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="one-time-witness-见证者模式"><a href="#one-time-witness-见证者模式" class="headerlink" title="one-time-witness 见证者模式"></a>one-time-witness 见证者模式</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public struct OTW has drop {}</span><br><span class="line">types::is_one_time_witness(&amp;witness)</span><br></pre></td></tr></tbody></table></figure><p>该结构体是一个特殊的见证者：同一个包下面的同一个结构体，只能创建出来一个实例来做 ‘见证’ ，同一个结构体只能用一次，不然会报错。例如创建一个<code>Coin</code>，一条链对应一个<code>Coin</code></p><p><font color="red">注<font>：名称必须与包的名字完全相同，并且全部大写；没有字段，只有drop（销毁）能力；通过<code>fun init (witness: Struct, ctx: &amp;mut TxContext) {}</code> 传入</font></font></p><h3 id="Transferable-Witness-可以转移见证者模式"><a href="#Transferable-Witness-可以转移见证者模式" class="headerlink" title="Transferable Witness 可以转移见证者模式"></a>Transferable Witness 可以转移见证者模式</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public struct WITNESS has store, drop {}</span><br><span class="line">public struct WitnessBox has key { id: UID, witness: WITNESS }</span><br></pre></td></tr></tbody></table></figure><p>这见证者结构体可以创建后放在一个容器里面，随着容器转移所有权，需要用到的时候在取出来做见证</p><p><font color="red">注<font>： 结构体没有字段，只有drop（销毁）和store（实现存储）和能力，需要一个object的容器来包装，存储在链上。</font></font></p><h2 id="hot-potato-设计模式"><a href="#hot-potato-设计模式" class="headerlink" title="hot-potato 设计模式"></a>hot-potato 设计模式</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public struct Receipt { price: u64 }</span><br><span class="line"></span><br><span class="line">public fun create(xx:XX,...):(Receipt{},Coin&lt;x&gt;)</span><br><span class="line"></span><br><span class="line">public fun burn(rece:Receipt,...)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>用这个结构体<code>public struct Receipt { price: u64 }</code>来检测是否符合交易的条件，防止别人盗走资源。</p><p>简单理解就是烫手的山芋，你拿到手里肯定处理不了，所以你只能还回去 </p><p><font color="red">注<font>：结构体没有任何能力，提供对外方法来<strong>创建</strong>结构体和<strong>销毁</strong>结构体。</font></font></p><h3 id="hot-potato具体例子-闪电贷"><a href="#hot-potato具体例子-闪电贷" class="headerlink" title="hot-potato具体例子-闪电贷"></a>hot-potato具体例子-闪电贷</h3><p>闪电贷的特点</p><ul><li><p>在一个交易里面必须完成借和还</p></li><li><p>无需抵押</p></li><li><p>不还款一定会报错</p></li><li><p>主要用于套利和加杠杆</p></li></ul><p>借款人通过智能合约请求贷款，在同一交易中利用这笔贷款进行各种操作，如投资、交易或其他金融活动，同时借款人必须在同一交易中将贷款金额与利息（gas fee)还清。如果借款人未能按时还款或不按协议还款，整个交易将被取消，贷款金额将被返还给贷款提供方，这时借款人仍然需要支付<code>gas fee</code></p><blockquote><p>闪电贷的具体研究可以看看这篇文章：</p><p>[闪电贷详解]: <a href="https://academy.binance.com/zh/articles/what-are-flash-loans-in-defi#how-does-a-flash-loan-work">https://academy.binance.com/zh/articles/what-are-flash-loans-in-defi#how-does-a-flash-loan-work</a>“什么是defi中的闪电贷？”</p></blockquote><h1 id="Sui-framework"><a href="#Sui-framework" class="headerlink" title="Sui_framework"></a>Sui_framework</h1><p>建议去官方的库中查看学习</p><blockquote></blockquote><p>Sui_framework，是Sui-move编程功能的合集，有很多相关的库</p><ul><li>deepbook</li><li>move-stdlib 标准库</li><li>sui-framework</li><li>sui-system</li></ul><h2 id="Balance-Coin-Token-定义及特点"><a href="#Balance-Coin-Token-定义及特点" class="headerlink" title="Balance/Coin/Token-定义及特点"></a>Balance/Coin/Token-定义及特点</h2><ul><li>Balance：一个通用的余额可存储处理程序。在Coin 模块中用于允许余额操作，并可用于实现具有Supply 和 Balance 的自定义货币。</li><li>Coin：定义了 Coin类型-表示可互换的令牌和货币的平台范围内的表示。Coin 可以被描述为围绕Balance 类型的安全包装器。</li><li>Token: Token 模块实现了一个可配置的闭环令牌系统。该策略由一组规则定义，必须满足这些规则才能对令牌执行操作。</li></ul><p>Token的产生是由Coin抽象出来，限制<code>Coin的自由转发</code></p><table><thead><tr><th>Module</th><th>Main type</th><th>Capability</th><th>Abilities</th></tr></thead><tbody><tr><td>sui::balance</td><td>Balance<t></t></td><td>Supply<t></t></td><td>store</td></tr><tr><td>sui::coin</td><td>Coin<t></t></td><td>TreasuryCapT&gt;</td><td>key + store</td></tr><tr><td>sui:: token</td><td>Token<t></t></td><td>TreasuryCap<t></t></td><td>key</td></tr></tbody></table><h2 id="display-standard-NFT"><a href="#display-standard-NFT" class="headerlink" title="display standard -NFT"></a>display standard -NFT</h2><ul><li><p><strong>name（名称）</strong> - 对象的名称。用户查看对象时显示此名称。</p></li><li><p><strong>description（描述）</strong> - 对象的描述。用户查看对象时显示此描述。</p></li><li><p><strong>link（链接）</strong> - 用于应用程序中的对象链接。</p></li><li><p><strong>image_url（图片链接）</strong> - 对象的图像链接，可以是URL或者图像的二进制数据。</p></li><li><p><strong>thumbnail_url（缩略图链接）</strong> - 用作钱包、浏览器和其他产品中的预览的小图像的URL。</p></li><li><p><strong>project_url（项目链接）</strong> - 与对象或创建者相关联的网站链接。</p></li><li><p><strong>creator（创建者）</strong> - 表示对象创建者的字符串信息。</p></li></ul><p>NFT = Object + Display</p><p>Sui Object Display 是一种模板引擎，可以实现对类型的链上管理与链下表示（显示）的模板化。通过它，你可以将对象的数据替换为模板字符串。该标准不限制你可以设置的字段。你可以使用｛property｝语法访问所有对象属性，然后将它们作为模板字符串的一部分插入其中。</p><h3 id="Kiosk"><a href="#Kiosk" class="headerlink" title="Kiosk"></a>Kiosk</h3><blockquote><p>具体介绍：<a href="https://docs.sui.io/standards/kiosk">https://docs.sui.io/standards/kiosk</a></p></blockquote><h2 id="Unit-Test-单元测试"><a href="#Unit-Test-单元测试" class="headerlink" title="Unit Test(单元测试)"></a>Unit Test(单元测试)</h2><ul><li>#[test]-只跑一遍某个函数</li><li>#[test_only]-工具函数，只在测试的时候才被编译</li><li>#[expect_failure(abort_code = test_sui_hello ::my_coin::ENotlmplemented)]-测试指定函数，报出指定的错误，可以理解为用错误条件来检验程序是否正确</li></ul><p>使用前文的Print()来调试</p><h1 id="Coin协议"><a href="#Coin协议" class="headerlink" title="Coin协议"></a>Coin协议</h1><p>Coin有两种所有权：</p><ul><li>独有所有权：<code>public_transfer(treasury_cap,sender(ctx))</code></li><li>共享所有权： <code>public_share_object(treasury_cap)</code></li></ul><p>ps: 代码来自官方标准库</p><p>生成一个Coin</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module examples::my_coin {</span><br><span class="line">    use sui::coin::{Self, TreasuryCap};</span><br><span class="line"></span><br><span class="line">    public struct MY_COIN has drop {}</span><br><span class="line">//采用一次见证</span><br><span class="line">    fun init(witness: MY_COIN, ctx: &amp;mut TxContext) {</span><br><span class="line">        let (treasury, metadata) = coin::create_currency(witness, 6, b"MY_COIN", b"", b"", option::none(), ctx);</span><br><span class="line">        //所有权共享 不可变共享</span><br><span class="line">        transfer::public_freeze_object(metadata);</span><br><span class="line">        //向合约发布者共享所有权</span><br><span class="line">        transfer::public_transfer(treasury, ctx.sender())</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>接下来我们一步一步的认识这个函数</p><p>使用<code>coin::create_currency</code>时，创建硬币的智能合约的发布者会收到一个<code>TreasuryCap</code>对象和<code>Coin元数据</code>。该<code>TreasuryCap</code>对象是铸造新硬币或销毁现有硬币所必需的。</p><p>同时<code>TreasuryCap</code>对象是可转让的，因此如果您转让该对象，第三方可以接管您创建的代币的管理<code>TreasuryCap</code>。但是，在转让该功能后，您将无法再自行铸造和销毁代币。</p><p>还有很多其他功能：这里就不一一列举了，建议用文档学习 </p></font><p></p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> move智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTB &amp; 快速开始dapp</title>
      <link href="/2024/09/30/qu-kuai-lian/sui-move-xue-xi-bi-ji-jin-jie-ban/"/>
      <url>/2024/09/30/qu-kuai-lian/sui-move-xue-xi-bi-ji-jin-jie-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="sui-move"><a href="#sui-move" class="headerlink" title="sui -move"></a>sui -move</h1><h2 id="Sui-PTB-（可编程交易模块）"><a href="#Sui-PTB-（可编程交易模块）" class="headerlink" title="Sui-PTB （可编程交易模块）"></a>Sui-PTB （可编程交易模块）</h2><p>官方文档地址：<a href="https://docs.sui.io/concepts/transactions/prog-txn-blocks">https://docs.sui.io/concepts/transactions/prog-txn-blocks</a></p><h3 id="PTB概述"><a href="#PTB概述" class="headerlink" title="PTB概述"></a>PTB概述</h3><p>PTB 全称 Programmable Transaction Block（可编程交易模块），在Sui上，交易不仅仅是资产流动的基本记录，交易由多个命令组成，这些命令在输入上执行，定义交易的结果。</p><p>PTB允许用户在单个交易中调用多个Move函数，管理其对象和管理其代币，而无需发布新的Move包，是生成交易的一种轻量灵活的方式，同时其执行组合的交易模式减少了gas fee 。</p><h3 id="PTB-的组成"><a href="#PTB-的组成" class="headerlink" title="PTB 的组成"></a>PTB 的组成</h3><p>每个PTB由单独的交易命令组成，这里的交易命令有：</p><ol><li><p><strong>TransferObjects</strong></p><ul><li>将一组对象转移到指定地址。</li></ul></li><li><p><strong>SplitCoins</strong></p><ul><li>将一个硬币拆分成多个硬币。</li></ul></li><li><p><strong>MakeMoveVec</strong></p><ul><li>构建一个 Move 类型的向量。</li></ul></li><li><p><strong>MoveCall</strong></p><ul><li>调用指定的 Move 函数。</li></ul></li><li><p><strong>Publish</strong></p><ul><li>发布指定的模块。</li></ul></li><li><p><strong>Upgrade</strong></p><ul><li>升级已有的模块或包。</li></ul></li></ol><p>每个交易命令按顺序执行，您可以在任何后续交易命令中使用前一个交易命令的结果。所有交易命令在一个块中的效果，特别是对象修改或转移，会在事务结束时以原子方式应用。如果一个交易命令失败，整个块都会失败，并且命令的任何效果都不会被应用</p><p>主要通过前端来整合并连续实施多个操作，即操作前端来实现交易的添加和合约的调用</p><h3 id="PTB的使用"><a href="#PTB的使用" class="headerlink" title="PTB的使用"></a>PTB的使用</h3><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建可编程事务块 (PTB)</span></span><br><span class="line"><span class="keyword">const</span> txb = <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line"><span class="comment">//设置输入参数</span></span><br><span class="line"><span class="keyword">const</span> arg1 = txb.<span class="title function_">object</span>(objectId0);</span><br><span class="line"><span class="keyword">const</span> arg2 = txb.<span class="title function_">object</span>(objectId1);</span><br><span class="line"><span class="keyword">const</span> arg3 = txb.<span class="property">pure</span>.<span class="title function_">u8</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> arg4 = txb.<span class="property">pure</span>.<span class="title function_">bool</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> arg5 = txb.<span class="title function_">pure</span>(bcs.<span class="title function_">vector</span>(bcs.<span class="property">U64</span>).<span class="title function_">serialize</span>([<span class="number">123</span>, <span class="number">456</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCoin = txb.<span class="title function_">object</span>(myCoinId);</span><br><span class="line"> <span class="comment">//通过命令调用 Move 函数拿到输出的资产</span></span><br><span class="line"><span class="keyword">const</span> coinOut = txb.<span class="title function_">moveCall</span>({</span><br><span class="line">  <span class="attr">target</span>: <span class="string">'${packageId}::${moduleName}::${funcName}*'</span>,</span><br><span class="line">  <span class="attr">typeArguments</span>: [type1, type2],</span><br><span class="line">  <span class="attr">arguments</span>: [arg1, arg2, arg3, arg4, arg5]</span><br><span class="line">});</span><br><span class="line"><span class="comment">// 拆分Coin为coinOut0和 coinOut1</span></span><br><span class="line"><span class="keyword">const</span> [coinOut0, coinOut1] = txb.<span class="title function_">splitCoins</span>(coinOut, [<span class="number">100</span>, <span class="number">200</span>]);</span><br><span class="line"><span class="comment">// 将coin合并到自己的资产中</span></span><br><span class="line">txb.<span class="title function_">mergeCoins</span>(myCoin, [coinOut]);</span><br><span class="line"><span class="comment">// 转移对象</span></span><br><span class="line"><span class="keyword">if</span> (coinOut0) txb.<span class="title function_">transferObjects</span>([coinOut0], recipient);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (coinOut1) txb.<span class="title function_">transferObjects</span>([coinOut1], recipient1);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="terminal"><a href="#terminal" class="headerlink" title="terminal"></a>terminal</h4><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sui client ptb </span><br><span class="line"><span class="literal">--assign</span> kapy @<span class="number">0</span>xa8f224924c9570c0bed020606be889fd46373e80c3a6b9547aeb33e646b4d540 </span><br><span class="line"><span class="literal">--assign</span> cfg @<span class="number">0</span>x80ff28774e3056f00e130a2dedda8be83c04acf3ab0697395bd37ee022001d15 </span><br><span class="line"><span class="literal">--move-call</span> <span class="number">0</span>xf61cffb662dda6c8ac484f299361b0d85464d06e46603321ad0b7311f0594490::exercise_3::buy_with_kapy kapy </span><br><span class="line"><span class="literal">--assign</span> dv </span><br><span class="line"><span class="literal">--move-call</span> <span class="number">0</span>xf61cffb662dda6c8ac484f299361b0d85464d06e46603321ad0b7311f0594490::exercise_3::pay <span class="string">"&lt;sui::sui::SUI&gt;"</span> @<span class="number">0</span>xd4fb85849ac089d5df317663b818dda0cf35a9f8b3c68ec81f941d010019bf7d cfg dv @<span class="number">0</span>x5617dbcfdea83576ae108ce03ea4fdebf2c505c53eec6e8c1130366f5bbb2eac </span><br><span class="line"><span class="literal">--assign</span> org </span><br><span class="line"><span class="literal">--move-call</span> <span class="number">0</span>xcbfbdaaa8e8a70556c0cf1a038ddb3d9cc86cdaeb1add61abf7ebd2becac7b9d::kapy::carry kapy org <span class="literal">--gas-budget</span> <span class="number">10000000</span> </span><br></pre></td></tr></tbody></table></figure><h2 id="Sui-client-命令速查"><a href="#Sui-client-命令速查" class="headerlink" title="Sui -client 命令速查"></a>Sui -client 命令速查</h2><ul><li><a href="https://docs.sui.io/references/cli/cheatsheet">https://docs.sui.io/references/cli/cheatsheet</a></li></ul><h2 id="Sui-Dapp-kit-套件"><a href="#Sui-Dapp-kit-套件" class="headerlink" title="Sui-Dapp kit 套件"></a>Sui-Dapp kit 套件</h2><ul><li><a href="https://sdk.mystenlabs.com/dapp-kit">https://sdk.mystenlabs.com/dapp-kit</a></li></ul><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i <span class="literal">--save</span> @mysten/dapp<span class="literal">-kit</span> @mysten/sui @tanstack/react<span class="literal">-query</span></span><br><span class="line">npm creat @mysten/dapp </span><br><span class="line">npm install <span class="literal">--legacy-peer-deps</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></tbody></table></figure><h2 id="创建-Dapp"><a href="#创建-Dapp" class="headerlink" title="创建 Dapp"></a>创建 Dapp</h2><p><a href="https://sdk.mystenlabs.com/dapp-kit/create-dapp">https://sdk.mystenlabs.com/dapp-kit/create-dapp</a></p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm create @mysten/dapp</span><br><span class="line">选择<span class="number">1</span>：react<span class="literal">-client-dapp</span> - 一个基本的 React dApp，用于获取连接的钱包所拥有的对象列表。</span><br><span class="line">选择<span class="number">2</span>：react<span class="literal">-e2e-counter</span> - 包含 <span class="built_in">Move</span> 代码和简单计数器应用程序 UI 的端到端示例</span><br><span class="line">输入Dapp<span class="literal">-name</span></span><br><span class="line"><span class="built_in">cd</span> Dapp<span class="literal">-name</span></span><br><span class="line">npm install  // 产生冲突 npm install <span class="literal">--legacy-peer-deps</span></span><br><span class="line">npm run dev - 运行</span><br></pre></td></tr></tbody></table></figure><h3 id="Typescript-SDK"><a href="#Typescript-SDK" class="headerlink" title="Typescript SDK"></a>Typescript SDK</h3><ul><li><a href="https://sdk.mystenlabs.com/typescript">https://sdk.mystenlabs.com/typescript</a></li></ul><h4 id="coin-value-和-coin-into-balance-不同："><a href="#coin-value-和-coin-into-balance-不同：" class="headerlink" title="coin::value 和 coin::into_balance 不同："></a><strong><code>coin::value</code> 和 <code>coin::into_balance</code> 不同</strong>：</h4><ol><li><p><strong><code>coin::value</code></strong>:</p><ul><li><p>用于获取一个 <code>Coin</code> 的<strong>数值</strong>。</p></li><li><p>它是一个公共的 getter 函数，可以返回 <code>Coin</code> 的具体数值。</p></li><li><p>代码签名为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public fun value&lt;T&gt;(self: &amp;coin::Coin&lt;T&gt;): u64</span><br></pre></td></tr></tbody></table></figure></li><li><p>这个函数不会改变 <code>Coin</code> 的状态，只是读取其数值。</p></li></ul></li><li><p><strong><code>coin::into_balance</code></strong>:</p><ul><li><p>用于将一个 <code>Coin</code> 解构为 <code>Balance</code>。</p></li><li><p>这个函数会消耗 <code>Coin</code> 对象，并返回其内部的 <code>Balance</code>。</p></li><li><p>代码签名为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public fun into_balance&lt;T&gt;(coin: coin::Coin&lt;T&gt;): balance::Balance&lt;T&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用这个函数后，**<code>Coin</code> 不再存在，而是转换为了 <code>Balance</code>**。</p></li></ul></li></ol><p>这两个函数的主要区别在于一个是读取操作（<code>value</code>），另一个是转换操作（<code>into_balance</code>）。如果你想获取 <code>Coin</code> 的数值而不改变其状态，使用 <code>value</code>；如果你需要将 <code>Coin</code> 转换为 <code>Balance</code>，使用 <code>into_balance</code>。</p><h4 id="和直接传参和-mut-的区别"><a href="#和直接传参和-mut-的区别" class="headerlink" title="&amp; 和直接传参和&amp;mut 的区别"></a><strong>&amp; 和直接传参和&amp;mut 的区别</strong></h4><p>在 Move 中，<code>&amp;</code>、直接传参和 <code>&amp;mut</code> 的区别主要在于所有权和可变性：</p><ol><li><p><strong>引用（&amp;）</strong>：</p><ul><li>传递的是对象的不可变引用。</li><li>允许在函数中读取对象，但不能修改。</li><li>不会转移对象的所有权。</li></ul></li><li><p><strong>直接传参</strong>：</p><ul><li>传递的是对象本身。</li><li>转移对象的所有权到函数中。</li><li>函数可以消耗对象（例如，销毁或转移）。</li></ul></li><li><p><strong>可变引用（&amp;mut）</strong>：</p><ul><li>传递的是对象的可变引用。</li><li>允许在函数中读取和修改对象。</li><li>不会转移对象的所有权，但允许修改其状态。</li></ul></li></ol><p>选择使用哪种方式取决于你的具体需求：</p><ul><li>使用 <code>&amp;</code> 当你只需要读取对象而不修改。</li><li>使用 <code>&amp;mut</code> 当你需要在函数中修改对象。</li><li>使用直接传参当你需要转移对象的所有权或消耗它。</li></ul><h2 id="各类transfer的区别与使用"><a href="#各类transfer的区别与使用" class="headerlink" title="各类transfer的区别与使用"></a>各类transfer的区别与使用</h2><table><thead><tr><th>方法</th><th>生成的方法</th><th>属性</th></tr></thead><tbody><tr><td>transfer</td><td>独享对象</td><td>key</td></tr><tr><td>public_transfer</td><td>独享对象</td><td>key + store</td></tr><tr><td>freeze_object</td><td>共享对象-常量</td><td>key</td></tr><tr><td>public_freeze_object</td><td>共享对象-常量</td><td>key + store</td></tr><tr><td>share_object</td><td>共享对象</td><td>key</td></tr><tr><td>public_share_object</td><td>共享对象</td><td>key + store</td></tr></tbody></table><p>源码地址：<a href="https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/transfer.move">https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/transfer.move</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> move智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React</title>
      <link href="/2024/09/18/qian-duan/react-bi-ji/"/>
      <url>/2024/09/18/qian-duan/react-bi-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习视频</p><p><a href="https://www.bilibili.com/video/BV1is4y167yY/?p=41&amp;spm_id_from=pageDriver&amp;vd_source=7815abf75f25008fd075daf46f5ff072">12. Props, Immutability, and One-Way Data Flow_哔哩哔哩_bilibili</a></p></blockquote><h1 id="React笔记"><a href="#React笔记" class="headerlink" title="React笔记"></a>React笔记</h1><hr><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>这里写了常用到的 js知识 </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象解构赋值（Object Destructuring），允许你从对象中提取属性，并将它们赋值给变量</span></span><br><span class="line"><span class="keyword">const</span> { title,author,publicationDate,hasMovieAdaptation,genres,reviews,translations } = book; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(title, author);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组解构赋值允许你将数组中的值提取到单独的变量中，语法类似于对象解构赋值，但使用的是方括号 []；</span></span><br><span class="line"><span class="keyword">const</span> [firstBook, secondBook, ...otherBooks ] = books; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstBook, secondBook, otherBooks);</span><br><span class="line"><span class="comment">//添加新元素  在解构赋值中，... 操作符可以用来收集剩余的元素。它可以用于数组解构时将剩余的元素赋值给一个新数组</span></span><br><span class="line"><span class="keyword">const</span> newGenres = [...book.<span class="property">genres</span>, <span class="string">"horror"</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newGenres);</span><br><span class="line"></span><br><span class="line"><span class="comment">//adding new genre to books可以覆盖原数组，也可以添加新的元素</span></span><br><span class="line"><span class="comment">//先展开</span></span><br><span class="line"><span class="keyword">const</span> updateBook = { ...books, <span class="attr">data</span>:<span class="string">"123"</span> };</span><br><span class="line">updateBook;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板字符串</span></span><br><span class="line"><span class="keyword">const</span> summary = <span class="string">`<span class="subst">${title}</span> is a book,and published in <span class="subst">${publicationDate.split(<span class="string">"-"</span>)[<span class="number">0</span>]}</span>`</span>;</span><br><span class="line">summary;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三元运算符</span></span><br><span class="line"><span class="keyword">const</span> hasMovie = books.<span class="property">hasMovieAdaptation</span> ? <span class="string">"Yes"</span> : <span class="string">"No"</span>;</span><br><span class="line">hasMovie;</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数 split() 方法用于分割字符串，并返回一个包含分割后的子字符串的数组。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">publicationDateYear</span> = (<span class="params">str</span>) =&gt; str.<span class="property">publicationDate</span>.<span class="title function_">split</span>(<span class="string">"-"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">publicationDateYear</span>(book));</span><br><span class="line"><span class="comment">//运算符</span></span><br><span class="line"><span class="comment">// &amp;&amp; 短路逻辑与 || 短路逻辑</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">true</span> &amp;&amp; <span class="string">"nihao"</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">false</span> || <span class="string">"nihao"</span>);</span><br><span class="line"><span class="comment">// console.log( true || "nihao");</span></span><br><span class="line"><span class="comment">// console.log( false &amp;&amp; "nihao");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//?? false短路逻辑 总评</span></span><br><span class="line"><span class="keyword">const</span> count = book.<span class="property">reviews</span>.<span class="property">librarything</span> ?? <span class="number">0</span>;</span><br><span class="line">count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//falsy values: false, null, undefined, 0, NaN, ""</span></span><br><span class="line"><span class="comment">//truthy values: true, non-empty string, non-empty array, object, function </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//optonal chaining  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTotalReviewcount</span>(<span class="params">book</span>){</span><br><span class="line">  <span class="keyword">const</span> goodreads = book.<span class="property">reviews</span>?.<span class="property">goodreads</span>;</span><br><span class="line">  <span class="keyword">const</span> librarything = book.<span class="property">reviews</span>?.<span class="property">librarything</span> ?? <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> goodreads + librarything;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> totalReviewCount = <span class="title function_">getTotalReviewcount</span>(book);</span><br><span class="line">totalReviewCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map会遍历数组中的每一个元素，并按照函数式，对原数组的每一项进行操作，返回一个新的数组</span></span><br><span class="line"><span class="keyword">const</span> x =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce 的效果 是将数组中的元素合并成一个值 相较于 filter、map</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//filer 过滤数组中的元素，返回一个新的数组</span></span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> filteredArr = arr3.<span class="title function_">filter</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line">filteredArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort 会改变原数组，返回排序后的数组</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> sortedArr = arr1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">sortedArr;</span><br><span class="line">arr1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 可以返回一个新数组，不会改变原数组</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> slicedArr2 = arr2.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">5</span>).<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(slicedArr2);</span><br><span class="line">arr2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数 为了延迟执行 onDeleteItem(item.id)，即在点击时才调用它</span></span><br><span class="line">onClick={<span class="function">() =&gt;</span> <span class="title function_">onDeleteItem</span>(item.<span class="property">id</span>)} </span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数 作为参数传递给另一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Hello!"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(greet, <span class="number">2000</span>);  <span class="comment">// 2秒后调用greet函数</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>React</strong> 是用于构建用户界面的 JavaScript 库。</p><p>它提供了组件、状态管理、生命周期方法等功能来帮助开发者构建复杂的前端应用</p><p>其主要功能是实现后端数据与前端页面的即时更新，同时减少单一使用<code>js</code>时的繁冗工作量</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h4 id="创建项目："><a href="#创建项目：" class="headerlink" title="创建项目："></a>创建项目：</h4><h5 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h5><p>a. 安装 Node.js 和 npm（Node.js 包管理器）。</p><p>b. 打开终端或命令提示符。</p><p>c. 运行以下命令来创建一个新的 React 应用程序：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></tbody></table></figure><h5 id="方法2：使用-Vite"><a href="#方法2：使用-Vite" class="headerlink" title="方法2：使用 Vite"></a>方法2：使用 Vite</h5><p>Vite 是一个轻量级的构建工具，它提供了快速的冷启动和热更新。它支持 TypeScript、CSS 预处理器和许多其他功能。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm init vite@latest my-app -- --template react</span><br><span class="line">cd my-app</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></tbody></table></figure><p>文件结构如下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">my-app/</span><br><span class="line">├── node_modules/         <span class="comment"># 项目依赖的第三方库</span></span><br><span class="line">├── public/</span><br><span class="line">│   ├── favicon.ico       <span class="comment"># 网站图标</span></span><br><span class="line">│   ├── index.html        <span class="comment"># HTML 入口文件</span></span><br><span class="line">│   ├── manifest.json     <span class="comment"># PWA 应用配置文件</span></span><br><span class="line">│   └── robots.txt        <span class="comment"># 爬虫协议文件</span></span><br><span class="line">├── src/</span><br><span class="line">│   ├── App.css           <span class="comment"># 应用的样式文件</span></span><br><span class="line">│   ├── App.tsx           <span class="comment"># 应用的主组件文件 (或 .js)</span></span><br><span class="line">│   ├── App.test.tsx      <span class="comment"># 测试文件，使用 Jest 测试框架</span></span><br><span class="line">│   ├── index.css         <span class="comment"># 全局样式文件</span></span><br><span class="line">│   ├── index.tsx         <span class="comment"># 应用入口文件 (或 .js)</span></span><br><span class="line">│   ├── logo.svg          <span class="comment"># 应用 logo 图标</span></span><br><span class="line">│   ├── reportWebVitals.ts <span class="comment"># 性能报告 (可选)</span></span><br><span class="line">│   └── setupTests.ts     <span class="comment"># 设置测试环境的配置文件</span></span><br><span class="line">├── .gitignore            <span class="comment"># Git 忽略文件配置</span></span><br><span class="line">├── package.json          <span class="comment"># 项目配置文件，包含依赖信息和脚本</span></span><br><span class="line">├── README.md             <span class="comment"># 项目的 README 文件</span></span><br><span class="line">├── tsconfig.json         <span class="comment"># TypeScript 配置文件（如果使用 TypeScript）</span></span><br><span class="line">└── yarn.lock / package-lock.json  <span class="comment"># 锁定依赖版本的文件</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="React-三要素"><a href="#React-三要素" class="headerlink" title="React 三要素"></a>React 三要素</h2><h3 id="1-组件（Component）"><a href="#1-组件（Component）" class="headerlink" title="1. 组件（Component）"></a>1. <strong>组件（Component）</strong></h3><p>组件是 React 的基础构建块，每个 React 应用都是由一个个组件组合而成的。React为每一个组件渲染一个视图，这些视图组成UI。每个组件都拥有自己的 “<strong>数据</strong>”  “<strong>（js）逻辑</strong>”  “<strong>外观</strong>”</p><ul><li><img src="/2024/09/18/qian-duan/react-bi-ji/react.png" alt="react笔记/react"><strong>类组件</strong>：通过 ES6 的类来定义，包含状态（state)和生命周期方法。</li><li><strong>函数组件</strong>：React 16.8 之后推荐的方式，使用函数定义组件并结合钩子（Hooks）来管理状态和生命周期。</li></ul><p>组件不可嵌套</p><p><strong>示例</strong>：</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, {props.name}<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><h4 id="什么是-JSX"><a href="#什么是-JSX" class="headerlink" title="什么是 JSX ?"></a>什么是 JSX ?</h4><p>jsx是一种声明语法，用来描述组件的外观，根据数据和逻辑工作。通常与 React 一起使用，允许在 JavaScript 代码中编写类似 HTML 的标签</p><ol><li><strong>类 HTML 的语法</strong>：</li></ol><ul><li>JSX 允许在 JavaScript 代码中嵌入类似 HTML 的标签，使得编写用户界面时更加直观和简洁。虽然看起来像 HTML，但 JSX 实际上会被编译成 JavaScript 函数调用。</li></ul><ol start="2"><li><strong>支持表达式</strong>：</li></ol><ul><li><p>JSX 中可以使用 JavaScript 表达式，通过{}包裹</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = 'Alice';</span><br><span class="line">const element = &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="3"><li><strong>必须返回一个父元素</strong>：</li></ol><ul><li><p>在 JSX 中，所有标签必须被一个父级元素包裹。例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Description&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="4"><li><strong>样式和属性的处理</strong>：</li></ol><ul><li><p>在 JSX 中，class属性被替换为<code>className</code>，style属性接受一个对象。例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className="container" style={{ color: 'red' }}&gt;Hello&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul></blockquote><h3 id="2-状态（State）"><a href="#2-状态（State）" class="headerlink" title="2. 状态（State）"></a>2. <strong>状态（State）</strong></h3><p>状态是组件内部的数据，它决定了组件的行为和显示的内容。</p><p>状态是可变的，随着用户的交互或其他事件触发，它会发生变化并<strong>重新渲染</strong>组件。</p><p>在类组件中，状态通过 <code>this.state</code> 来管理，在函数组件中使用 <code>useState</code> <strong>钩子</strong>来管理。</p><blockquote><p>什么是钩子？</p><p>在 React 中，钩子就是use开头的状态组件，允许你在函数组件中使用状态和其他 React 特性，而不需要编写类组件。</p><p>常见的 React 钩子有：</p><ul><li><code>useState</code>：用于在函数组件中添加状态变量。</li><li><code>useEffect</code>：用于执行副作用操作（如数据获取、订阅或手动更改 DOM）。</li><li><code>useContext</code>：用于在组件树中共享数据，而无需逐层传递 props。</li></ul></blockquote><h4 id="怎么使用状态"><a href="#怎么使用状态" class="headerlink" title="怎么使用状态"></a>怎么使用状态</h4><p><strong>什么时候创建状态？</strong></p><ol><li><p>需要存储数据？</p></li><li><p>数据会发生变化吗 </p><ul><li>不会 =&gt; const 常量即可</li></ul></li><li><p>是否可以从现有的道具/状态中计算？</p><ul><li>会 =&gt; 派生状态(derive state)</li></ul></li><li><p>更新状态是否需要重新渲染组件？</p></li></ol><ul><li>不会 =&gt; 使用Ref （像普通状态一样持久的保持数据，但无需重新渲染组件）</li></ul><ol start="5"><li>使用useState创建一个状态，并放置在组件中</li></ol><p><strong>在哪里使用状态？</strong></p><p><strong>当前组件</strong>、通过道具传递给<strong>子组件</strong>、将状态传递给同级组件的<strong>公共父组件</strong>中去（状态上移）、所有组件使用（<strong>全局状态</strong>）</p><h4 id="派生状态"><a href="#派生状态" class="headerlink" title="派生状态"></a>派生状态</h4><p>派生状态就是简单地从一个现有状态或者道具中计算出来的状态</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [total,setTotal] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> tip = total /<span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="3-属性（Props）"><a href="#3-属性（Props）" class="headerlink" title="3. 属性（Props）"></a>3. <strong>属性（Props）</strong></h3><p><code>props</code> 是组件之间传递数据的方式。</p><p>父组件可以通过 <code>props</code> 向子组件传递数据，子组件无法修改 <code>props</code>，它们是只读的。<code>props</code> 的主要作用是让组件的渲染更加灵活和<strong>可复用</strong>。</p><p>在传递中，我们可以使用 js 中的<code>重构</code>来传递对象的名称而不是<code>props</code>，但是不要忘记使用<code>{}</code></p><p color="red">注 : React是单向数据流，数据只能从父组件流向子组件</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 父组件向子组件传递数据</span><br><span class="line">function Menu() {</span><br><span class="line">  return (</span><br><span class="line">      &lt;main className="menu"&gt;</span><br><span class="line">        &lt;h2&gt;our pizzas&lt;/h2&gt;</span><br><span class="line">        &lt;Pizza name= "Focaccia" </span><br><span class="line">        ingredients= "Bread with italian olive oil and rosemary" </span><br><span class="line">        price="6" </span><br><span class="line">        photoName="pizzas/focaccia.jpg"/&gt;</span><br><span class="line">       &lt;/main&gt;</span><br><span class="line"></span><br><span class="line">function Pizza(props) {</span><br><span class="line">  return (</span><br><span class="line">      &lt;div className="pizza"&gt;</span><br><span class="line">        &lt;img src={props.photoName} alt={props.name} /&gt;</span><br><span class="line">        &lt;div className="pizzas"&gt;</span><br><span class="line">        &lt;h3&gt;{props.name}&lt;/h3&gt;</span><br><span class="line">        &lt;p&gt;{props.ingredients}&lt;/p&gt;</span><br><span class="line">        &lt;span&gt;{props.price}&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="子代道具"><a href="#子代道具" class="headerlink" title="子代道具"></a>子代道具</h4><p>在 React 中，<strong>子代道具（Children Props）</strong> 是指通过 <code>props.children</code> 传递的内容，它允许父组件将嵌套在其内部的 JSX 代码或组件传递给子组件。它提供了一种灵活的方式来构建可复用的组件，使得父组件可以决定子组件的内部内容，而不需要在子组件中明确指定。</p><p>示例：</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Wrapper</span>(<span class="params">props</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"wrapper"</span>&gt;</span>{props.children}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Wrapper</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph inside the Wrapper component.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Wrapper</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="三要素关系总结："><a href="#三要素关系总结：" class="headerlink" title="三要素关系总结："></a>三要素关系总结：</h3><ul><li><strong>组件</strong> 是 UI 的基本单元，通过组合形成完整的应用。</li><li><strong>状态</strong> 是组件内部的动态数据，控制着组件的行为和显示。</li><li><strong>属性（props）</strong> 用于在组件间传递数据，通常是父组件传递给子组件的数据。</li></ul><blockquote><p>状态与道具有什么区别？</p><p><strong>状态（state）</strong>：状态是组件内部管理的数据，数据归创建他的组件所有，它可以看作组件的存储，可以用来长期保存数据。状态可以在组件内部被修改（通过<code>setState</code>或<code>useState</code>），并会在变化时触发组件重新渲染，用来控制组件的行为、渲染和交互。</p><ul><li>用于存储组件内部<strong>动态变化的数据</strong>，比如用户输入的表单值、加载数据的结果、组件的交互状态（如打开或关闭某个UI元素）。</li><li>当状态发生变化时，React会自动触发两个组件的重新渲染</li></ul><p><strong>道具（props）</strong>：道具是从父组件传递给子组件的数据，数据被父组件所有，可以把它想象函数参数。因为它是只读的，<strong>子组件无法直接修改它</strong>。当子组件收到更新的props时，也会重新渲染组件</p><ul><li>道具主要用来让组件间进行<strong>静态数据传</strong>递，通常是父组件将数据通过道具传递给子组件，子组件根据道具的值渲染。</li><li>当道具的值在父组件中发生变化时，子组件会重新渲染。</li></ul></blockquote><h2 id="怎么渲染列表（rendering-a-list）"><a href="#怎么渲染列表（rendering-a-list）" class="headerlink" title="怎么渲染列表（rendering a list）"></a>怎么渲染列表（rendering a list）</h2><p>概念：可以理解为创建一个数组，并为数组里的每个元素创建组件</p><p>通常我们会使用数组的 <code>map()</code> 方法来生成列表项。每个列表项需要一个唯一的 <code>key</code> 属性，以帮助 React 识别和优化列表中的元素</p><p>示例：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const pizzaData = [{...}]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Menu</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">main</span> <span class="attr">className</span>=<span class="string">"menu"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>our pizzas<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        {pizzaData.map((pizzas) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Pizza</span> <span class="attr">pizzaObj</span>=<span class="string">{pizzas}</span> <span class="attr">key</span>=<span class="string">{pizzas.name}</span> /&gt;</span> ))}</span></span><br><span class="line"><span class="language-xml">  {/*这一段代码是 React 中通过数组的 map() 方法渲染列表的常用方式。它的作用是遍历 pizzaData 数组，为数组中的每个对象生成一个对应的 Pizza 组件*/}</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Pizza</span>(<span class="params">props</span>) {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"pizza"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">{props.pizzaObj.photoName}</span> <span class="attr">alt</span>=<span class="string">{props.pizzaObj.name}</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"pizzas"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>{props.pizzaObj.name}<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>{props.pizzaObj.ingredients}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>{props.pizzaObj.price}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>方法一：使用 &amp;&amp; 运算符的<strong>短路逻辑</strong>，在特定条件下选择内容</p><p>示例：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Footer</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getHours</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  <span class="keyword">const</span> open = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">const</span> close = <span class="number">22</span>;</span><br><span class="line">  <span class="keyword">const</span> isOpen = data &gt;= open &amp;&amp; data &lt; close;</span><br><span class="line">  <span class="keyword">return</span> ( </span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">className</span>=<span class="string">"footer"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        {isOpen &amp;&amp; <span class="tag">&lt;<span class="name">p</span>&gt;</span> Open<span class="tag">&lt;/<span class="name">p</span>&gt;</span> }</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>方法2：使用<strong>三元运算符</strong></p><p>示例：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Footer</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getHours</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  <span class="keyword">const</span> open = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">const</span> close = <span class="number">22</span>;</span><br><span class="line">  <span class="keyword">const</span> isOpen = data &gt;= open &amp;&amp; data &lt; close;</span><br><span class="line">  <span class="keyword">return</span> ( </span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">className</span>=<span class="string">"footer"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        {isOpen = true ?(<span class="tag">&lt;<span class="name">p</span>&gt;</span>Open<span class="tag">&lt;/<span class="name">p</span>&gt;</span>): null}</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>方法三：多重返回</p><p>示例：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Footer</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getHours</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  <span class="keyword">const</span> open = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">const</span> close = <span class="number">22</span>;</span><br><span class="line">  <span class="keyword">const</span> isOpen = data &gt;= open &amp;&amp; data &lt; close;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isOpen) {</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Close<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ( </span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">className</span>=<span class="string">"footer"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        {/* {isOpen &amp;&amp;  */}</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"order"</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span> We're open for orders from {open} to {close}. Call us at 123-456-7890.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"btn"</span> <span class="attr">style</span>=<span class="string">{{color:</span> '<span class="attr">yellow</span>'}} &gt;</span>Order<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="React-Fragment-react-片段"><a href="#React-Fragment-react-片段" class="headerlink" title="React Fragment(react 片段)"></a>React Fragment(react 片段)</h2><p>概念：<code>React.Fragment</code> 是 React 中用于<strong>包裹多个子元素</strong>而不额外生成 HTML 元素的组件。</p><p>通常在 JSX 中，如果你返回多个元素，它们需要被一个父级元素<code>&lt;div&gt;&lt;/div&gt;</code>包裹，而 <code>React.Fragment</code> 可以在不生成额外 DOM 节点的情况下包裹这些元素。</p><p>示例：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">react.fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Menu</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Footer</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">react.fragment</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Menu</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Footer</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="如何在React中使用表单？"><a href="#如何在React中使用表单？" class="headerlink" title="如何在React中使用表单？"></a>如何在React中使用表单？</h2><h4 id="怎么判断是否需要使用表单？"><a href="#怎么判断是否需要使用表单？" class="headerlink" title="怎么判断是否需要使用表单？"></a>怎么判断是否需要使用表单？</h4><ol><li><strong>用户输入</strong>：如果你需要用户输入数据，比如添加待办事项，那么你需要一个表单。表单可以包含输入框、文本域、选择框等元素，让用户输入信息。</li><li><strong>提交操作</strong>：如果你需要用户提交数据，比如添加待办事项后保存到列表中，那么你需要一个表单。表单通常包含一个提交按钮，用户点击后触发数据提交。</li><li><strong>数据验证</strong>：如果你需要对用户输入的数据进行验证，比如检查待办事项是否为空，那么你需要一个表单。表单可以包含验证逻辑，确保用户输入的数据符合要求。</li><li><strong>状态管理</strong>：如果你需要管理用户输入的状态，比如输入框的值，那么你需要一个表单。表单可以包含状态管理逻辑，确保用户输入的数据能够被正确处理。</li><li><strong>事件处理</strong>：如果你需要处理用户输入的事件，比如输入框的 <code>onChange</code> 事件，那么你需要一个表单。表单可以包含事件处理逻辑，响应用户的操作。</li></ol><p>表单完整代码（以ToDoList为例）：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Form</span> (<span class="params"></span>){</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> [description, setDescription] = <span class="title function_">useState</span>(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [quantity, setQuantity] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleSubmit</span>(<span class="params">e</span>){</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  }</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">className</span>=<span class="string">"add-form"</span> <span class="attr">onSubmit</span>=<span class="string">{handleSubmit}</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>What do you need for your trip<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">select</span> <span class="attr">value</span>=<span class="string">{quantity}</span> <span class="attr">onChange</span>=<span class="string">{(e)</span> =&gt;</span> setQuantity(Number(e.target.value)} &gt;</span></span><br><span class="line"><span class="language-xml">        {Array.from({length: 20}, (_, i) =&gt; i+1).map</span></span><br><span class="line"><span class="language-xml">        ((num) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">option</span>  <span class="attr">value</span>=<span class="string">{num}</span> <span class="attr">key</span>=<span class="string">{num}</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            {num}</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">option</span>&gt;</span>))}</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">placeholder</span>=<span class="string">"Item..."</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">{description}</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">{(e)</span> =&gt;</span> setDescription(e.target.value)}/&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>渲染列表</p><p><code> {Array.from({length: 20}, (_, i) =&gt; i+1).map         ((num) =&gt; (           &lt;option value={num} key={num}&gt;             {num}             &lt;/option&gt;))}</code>:</p><p>利用<code>Array.from()</code>生成一个数组，并通过<code>map()</code>来遍历数组，动态生成一组<code>&lt;option&gt;</code>标签</p><p><code>onChange</code>：当用户在输入框中输入内容时，<code>onChange</code>事件会触发，更新React状态，从而动态更新表单值</p><h3 id="如何将表单中的数据导入事件"><a href="#如何将表单中的数据导入事件" class="headerlink" title="如何将表单中的数据导入事件?"></a>如何将表单中的数据导入事件?</h3><blockquote><h4 id="常见的React事件类型："><a href="#常见的React事件类型：" class="headerlink" title="常见的React事件类型："></a>常见的React事件类型：</h4><ul><li>**<code>onClick</code>**：点击事件</li><li>**<code>onChange</code>**：表单元素（如输入框、选择框）的值改变事件</li><li>**<code>onSubmit</code>**：表单提交事件</li><li>**<code>onKeyDown</code><strong>、</strong><code>onKeyUp</code>**：键盘按下、松开事件</li><li>**<code>onMouseEnter</code><strong>、</strong><code>onMouseLeave</code>**：鼠标进入、离开事件</li></ul></blockquote><h3 id="受控元素"><a href="#受控元素" class="headerlink" title="受控元素"></a>受控元素</h3><p>在React中，使用受控组件可以将HTML表单中的数据与组件的状态（<code>state</code>）直接绑定，从而避免直接操作DOM。这样做的好处是表单数据的更新和管理完全交由React来处理，无需手动获取DOM元素的值</p><p>三个步骤：</p><ul><li><p>设置状态  <code>const [description, setDescription] = useState('');</code></p><ul><li><strong>目的</strong>：创建一个变量来存储用户输入的值，并在用户与表单交互时，React能够追踪和管理这个值。</li></ul></li><li><p>绑定变量   通过<code>value</code>属性，将表单元素（例如<code>&lt;input&gt;</code>或<code>&lt;textarea&gt;</code>）的值与刚刚创建的状态变量绑定。这样，表单的值由状态控制，React状态和UI之间建立了双向绑定关系。</p><ul><li><strong>操作</strong>：在表单元素上使用<code>value={description}</code>，使输入框的值与<code>description</code>状态保持同步</li></ul></li><li><p>更新状态   <code> onChange={(e) =&gt; setDescription(e.target.value)}</code>，当用户在表单元素中输入内容时，<code>onChange</code>事件会触发。此时，你可以使用<code>setDescription</code>函数更新状态，确保状态随用户输入的变化而改变。事件处理函数将接收事件对象，通过<code>e.target.value</code>获取表单元素的新值。</p><ul><li><p><strong>操作</strong>：在<code>onChange</code>事件处理函数中调用<code>setDescription(e.target.value)</code>，将表单的新值更新到状态中</p></li><li><blockquote><h4 id="js小知识"><a href="#js小知识" class="headerlink" title="js小知识"></a>js小知识</h4><p>在 <code>onChange={(e) =&gt; setDescription(e.target.value)}</code> 这段代码中，<code>e</code> 是一个事件对象（Event Object），它代表了当前正在发生的事件。在 JavaScript 中，当事件（如点击、输入等）发生时，浏览器会创建一个事件对象，该对象包含了与该事件相关的所有信息。</p><p>在这个特定的例子中，<code>e</code> 是一个合成事件（Synthetic Event）对象，它是 React 为了兼容不同浏览器而创建的一个抽象层。合成事件对象封装了原生浏览器事件，并提供了一个统一的接口，使得开发者可以编写跨浏览器的代码。</p><p><code>e.target</code> 是事件的目标元素（Event Target），即触发事件的 DOM 元素。在这个例子中，<code>e.target</code> 是输入框（input）元素。</p><p><code>e.target.value</code> 是输入框元素的当前值（Value），即用户输入的内容。</p></blockquote></li></ul></li></ul><hr><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p><code>React Router</code> 是一个用于 React 应用的库，用于管理应用的路由和导航。它的主要作用是帮助开发者构建单页面应用（SPA），通过动态加载组件而不是每次跳转都重新加载整个页面。</p><h3 id="React-Router-的作用和意义"><a href="#React-Router-的作用和意义" class="headerlink" title="React Router 的作用和意义"></a>React Router 的作用和意义</h3><ol><li><p><strong>单页面应用（SPA）支持</strong>：</p><ul><li>React Router <strong>允许应用在不刷新页面的情况下切换视图</strong>，提升用户体验。</li><li>通过动态加载组件，减少页面加载时间，提升性能。</li></ul></li><li><p><strong>URL 与 UI 同步</strong>：</p><ul><li>React Router 保持 URL 与 UI 同步，用户可以通过 URL 直接访问特定页面，便于分享和书签。</li></ul></li><li><p><strong>嵌套路由</strong>：</p><ul><li>支持嵌套路由，允许在父组件中嵌套子组件，便于构建复杂的 UI 结构。</li></ul></li><li><p><strong>动态路由</strong>：</p><ul><li>支持动态路由，允许根据 URL 参数动态加载不同内容。</li></ul></li><li><p><strong>编程式导航</strong>：</p><ul><li>提供编程式导航，开发者可以通过代码控制页面跳转，而不是依赖用户点击链接。</li></ul></li><li><p><strong>路由守卫</strong>：</p><ul><li>支持路由守卫，可以在用户访问特定路由前进行权限检查或数据加载。</li></ul></li></ol><h3 id="为什么不直接用链接"><a href="#为什么不直接用链接" class="headerlink" title="为什么不直接用链接"></a>为什么不直接用链接</h3><ol><li><p><strong>页面刷新</strong>：</p><ul><li>使用普通链接会导致页面刷新，破坏 SPA 的无刷新体验。</li></ul></li><li><p><strong>状态丢失</strong>：</p><ul><li>页面刷新会导致应用状态丢失，而 React Router 可以在不刷新页面的情况下保持状态。</li></ul></li><li><p><strong>复杂路由管理</strong>：</p><ul><li>普通链接无法处理复杂的路由逻辑，如嵌套路由、动态路由等。</li></ul></li><li><p><strong>编程式导航</strong>：</p><ul><li>普通链接无法实现编程式导航，React Router 提供了更多控制权。</li></ul></li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span>, <span class="title class_">Switch</span>, <span class="title class_">Link</span> } <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Home</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">About</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>About<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/"</span> <span class="attr">exact</span> <span class="attr">component</span>=<span class="string">{Home}</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/about"</span> <span class="attr">component</span>=<span class="string">{About}</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Root</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Root</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><h3 id="什么是useEffact"><a href="#什么是useEffact" class="headerlink" title="什么是useEffact?"></a>什么是useEffact?</h3><p><strong><code>useEffect</code> 是 React 的一个 Hook，用于在函数组件中处理副作用</strong>。</p><p><code>useEffect</code> 让函数组件能在<strong>渲染后</strong>执行副作用，并通过依赖项和清理函数<strong>精准控制执行时机</strong>，替代类组件的生命周期方法（如 <code>componentDidMount</code> / <code>componentDidUpdate</code> / <code>componentWillUnmount</code>）。它的核心作用是：</p><h6 id="1-什么是副作用？"><a href="#1-什么是副作用？" class="headerlink" title="1. 什么是副作用？"></a><strong>1. 什么是副作用？</strong></h6><ul><li><strong>副作用</strong>是指那些可能影响其他组件或与外部世界交互的操作，例如：<ul><li>数据获取（API 请求）</li><li>手动修改 DOM</li><li>订阅事件（如 <code>window.addEventListener</code>）</li><li>定时器（<code>setTimeout</code> / <code>setInterval</code>）</li></ul></li></ul><h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="comment">// 副作用代码（组件渲染后执行）</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// 清理函数（组件卸载或依赖项变化前执行）</span></span><br><span class="line">  };</span><br><span class="line">}, [依赖项数组]); <span class="comment">// 控制副作用触发的条件</span></span><br></pre></td></tr></tbody></table></figure><p>依赖项数组这一列中，不用纠结太多，一般把所有的外部值都添加进来就可以。</p><ul><li><strong>无依赖数组（<code>[]</code>）</strong>：只在组件<strong>首次渲染后</strong>执行一次（类似 <code>componentDidMount</code>）。</li><li><strong>有依赖项（<code>[a, b]</code>）</strong>：当 <code>a</code> 或 <code>b</code> 变化时重新执行。</li><li><strong>无第二个参数</strong>：<strong>每次组件更新后</strong>都执行（谨慎使用！）。</li><li><strong>清理函数</strong>：用于取消订阅、清除定时器等（类似 <code>componentWillUnmount</code>）。</li></ul><h3 id="为什么需要useEffect"><a href="#为什么需要useEffect" class="headerlink" title="为什么需要useEffect?"></a>为什么需要useEffect?</h3><p>以获取数据为例：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> { useState } = <span class="built_in">require</span>(<span class="string">"react"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">backend</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">const</span> [isLoading,setIsLoading] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> [list,setList] = <span class="title function_">useState</span>([]);</span><br><span class="line">    <span class="title function_">fetch</span>(</span><br><span class="line">        <span class="string">'https://react-getting-started-48dec-default-rtdb,firebaseio.com/meetups.json'</span></span><br><span class="line">    ).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>{</span><br><span class="line">        <span class="keyword">return</span> response.<span class="title function_">json</span>()</span><br><span class="line">    }).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>{</span><br><span class="line">        <span class="title function_">setIsLoading</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="title function_">setLoadedMeetups</span>(data);})</span><br><span class="line">        <span class="keyword">if</span> (isLoading){</span><br><span class="line">            <span class="keyword">return</span>(</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            )</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">List</span> <span class="attr">date</span>=<span class="string">{list}</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> backend;</span><br></pre></td></tr></tbody></table></figure><p>这样的写法会<strong>陷入死循环</strong>，原因是 <code>fetch</code> 请求被放在了函数组件的顶层作用域中，而每次组件渲染时都会重新执行 <code>fetch</code> 请求，导致状态更新（<code>setIsLoading</code> 和 <code>setList</code>），进而触发组件重新渲染，然后再次执行 <code>fetch</code> 请求，形成无限循环。</p><p>采用useEffct:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> { useState } = <span class="built_in">require</span>(<span class="string">"react"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">backend</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">const</span> [isLoading,setIsLoading] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> [list,setList] = <span class="title function_">useState</span>([]);</span><br><span class="line">  </span><br><span class="line">    <span class="title function_">useEffect</span>()=&gt;{</span><br><span class="line">       <span class="title function_">fetch</span>(</span><br><span class="line">        <span class="string">'https://react-getting-started-48dec-default-rtdb,firebaseio.com/meetups.json'</span></span><br><span class="line">    ).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>{</span><br><span class="line">        <span class="keyword">return</span> response.<span class="title function_">json</span>()</span><br><span class="line">    }).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>)=&gt;</span>{</span><br><span class="line">        <span class="title function_">setIsLoading</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="title function_">setLoadedMeetups</span>(data);</span><br><span class="line">       });</span><br><span class="line">   },[isLoading])</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">List</span> <span class="attr">date</span>=<span class="string">{list}</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> backend;</span><br></pre></td></tr></tbody></table></figure><h2 id="Context-上下文"><a href="#Context-上下文" class="headerlink" title="Context - 上下文"></a>Context - 上下文</h2><p><strong>上下文（Context）</strong> 是 React 提供的一种 <strong>跨组件层级传递数据</strong> 的机制，用于避免繁琐的逐层 props 传递（俗称“props 钻取”）。它特别适合全局共享的数据（如主题、用户登录状态、多语言配置等）。</p><ol><li><strong>核心 API</strong><ul><li><code>React.createContext()</code>：创建一个 Context 对象（包含 <code>Provider</code> 和 <code>Consumer</code>）。</li><li><code>Context.Provider</code>：提供数据的组件，通过 <code>value</code> 属性传递数据。</li><li><code>useContext()</code>：函数组件中消费 Context 数据的 Hook（替代 <code>Consumer</code>）</li></ul></li></ol><p>使用示例：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { createContext, useContext,useState } <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建初始 Context（建议命名以 Context/Provider 结尾）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TestContext</span> = <span class="title function_">createContext</span>({</span><br><span class="line">     <span class="attr">favorites</span>: userFavorites,</span><br><span class="line">     <span class="attr">number</span>: userFavorites.<span class="property">length</span>,</span><br><span class="line">}); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提供/更新数据的 Provider 组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TestProvider</span>(<span class="params">{ children }</span>) {</span><br><span class="line">  <span class="comment">//const sharedData = "这是要共享的数据"; // 通常用 useState 管理动态数据</span></span><br><span class="line">  <span class="keyword">const</span> [userFavorites,setUserFavorites] = <span class="title function_">useState</span>([]);</span><br><span class="line">  <span class="keyword">const</span> context = {</span><br><span class="line">      <span class="attr">favorites</span>: userFavorites,</span><br><span class="line">      <span class="attr">number</span>: userFavorites.<span class="property">length</span>,</span><br><span class="line">  };</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">TestContext.Provider</span> <span class="attr">value</span>=<span class="string">{context}</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      {children}</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">TestContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 自定义 Hook 简化（可选）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useTest</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useContext</span>(<span class="title class_">TestContext</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">TestProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">TestProvider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ChildComponent</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">useTest</span>(); <span class="comment">// 或直接 useContext(TestContext)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>{data}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>; <span class="comment">// 输出: "这是要共享的数据"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当多个页面都需要使用当前上下文时，可以用一个provider文件专门封装：</p><figure class="highlight tsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use client'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">QueryClient</span>, <span class="title class_">QueryClientProvider</span> } <span class="keyword">from</span> <span class="string">"@tanstack/react-query"</span>;</span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">SuiClientProvider</span>, <span class="title class_">WalletProvider</span> } <span class="keyword">from</span> <span class="string">"@mysten/dapp-kit"</span>;</span><br><span class="line"><span class="keyword">import</span> { networkConfig, network } <span class="keyword">from</span> <span class="string">"@/contracts"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"@mysten/dapp-kit/dist/index.css"</span>;</span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">ThemeProvider</span> } <span class="keyword">from</span> <span class="string">"next-themes"</span>;</span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">UserProfileProvider</span> } <span class="keyword">from</span> <span class="string">"@/contexts/user-profile-context"</span>;</span><br><span class="line"><span class="keyword">import</span> { <span class="title class_">AppProvider</span> } <span class="keyword">from</span> <span class="string">"@/contexts/app-context"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queryClient = <span class="keyword">new</span> <span class="title class_">QueryClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Providers</span>(<span class="params">{ children }: { children: React.ReactNode }</span>) {</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">attribute</span>=<span class="string">"class"</span> <span class="attr">defaultTheme</span>=<span class="string">"system"</span> <span class="attr">enableSystem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">QueryClientProvider</span> <span class="attr">client</span>=<span class="string">{queryClient}</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">SuiClientProvider</span> <span class="attr">networks</span>=<span class="string">{networkConfig}</span> <span class="attr">defaultNetwork</span>=<span class="string">{network}</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">AppProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">UserProfileProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">WalletProvider</span> <span class="attr">autoConnect</span> <span class="attr">stashedWallet</span>=<span class="string">{</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  {</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">name:</span> "<span class="attr">Sui</span> <span class="attr">Passport</span>",</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">network:</span> <span class="attr">network</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  }</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                }&gt;</span></span></span><br><span class="line"><span class="language-xml">                  {children}</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">WalletProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">UserProfileProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">AppProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">SuiClientProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">QueryClientProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="🤔-那什么时候不用全局包裹？"><a href="#🤔-那什么时候不用全局包裹？" class="headerlink" title="🤔 那什么时候不用全局包裹？"></a>🤔 那什么时候不用全局包裹？</h3><p>如果 profile 只在某些特定路由中使用，比如 <code>/profile/*</code>，那你可以只在某个 layout 里包裹：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tsxCopyEdit// app/profile/layout.tsx</span><br><span class="line">import { UserProfileProvider } from '@/contexts/UserProfileProvider';</span><br><span class="line"></span><br><span class="line">export default function ProfileLayout({ children }) {</span><br><span class="line">  return (</span><br><span class="line">    &lt;UserProfileProvider&gt;</span><br><span class="line">      {children}</span><br><span class="line">    &lt;/UserProfileProvider&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL入门学习笔记</title>
      <link href="/2024/08/11/ji-suan-ji-wang-luo-ji-chu/mysql-ru-men-xue-xi-bi-ji/"/>
      <url>/2024/08/11/ji-suan-ji-wang-luo-ji-chu/mysql-ru-men-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>学习视频链接</p><ul><li></li></ul><hr><h1 id="MYSQL入门学习笔记"><a href="#MYSQL入门学习笔记" class="headerlink" title="MYSQL入门学习笔记"></a>MYSQL入门学习笔记</h1><p>关联式数据库 =&gt; tables and keys</p><p>**primary key (主键)**：可以唯一区分资料</p><p><span class="github-emoji"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>当有重复时，可以设定多个主键来唯一区分资料</p><p>**foreign key(外键)**：实现table的互相关联(也可以和自己关联)    </p><p> <span class="github-emoji"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>但是只能关联table的主键</p><blockquote><p>可以将一个属性同时设定为不同table的主键和外键</p></blockquote><h2 id="SQL基础语法"><a href="#SQL基础语法" class="headerlink" title="SQL基础语法"></a>SQL基础语法</h2><p> <span class="github-emoji"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  后文中的” &lt;&gt; “ 代表 “ ` “，同时SQL中遵循属性名用  ``包裹，值用 ‘’ 或者 “” 包裹的潜规则</p><h3 id="数据库相关操作"><a href="#数据库相关操作" class="headerlink" title="数据库相关操作"></a>数据库相关操作</h3><p>创建数据库 <code>CREATE DATABASE  &lt;name&gt; </code>；</p><p>展示数据库 <code>SHOW DATABASES;</code></p><p>关键字用大写，命名用``包裹</p><p>删除数据库 <code>DROP DATABASE &lt;db_name&gt;;</code></p><h3 id="数据库常见类型"><a href="#数据库常见类型" class="headerlink" title="数据库常见类型"></a>数据库常见类型</h3><ul><li><p>INT    –整数</p></li><li><p>DECYMAL(m,n)    –有小数点的数，m=几个数字，n=几个小数</p></li><li><p>VARCHAR(n)    –字串，n=最多可以容纳几个字</p></li><li><p>BLOB    –(Binary Large Object) 图片 影片 档案等二进制资料</p></li><li><p>DATE    –’YYYY-MM-DD’ 记录日期</p></li><li><p>TIMESTAMP    –’YYYY-MM-DD HH:MM:SS’ 记录时间</p></li></ul><h3 id="表格操作"><a href="#表格操作" class="headerlink" title="表格操作"></a>表格操作</h3><p>选择数据库 <code>USE &lt;db_name&gt;; </code></p><p>创建表格</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span>(</span><br><span class="line">    `属性名<span class="number">1</span>` 类型 限制类型,</span><br><span class="line">    `属性名<span class="number">2</span>` 类型 限制类型</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>删除表格 <code>DROP TABLE &lt;table_name&gt;;</code></p><p>新增属性 <code>ALTER TABLE &lt;name&gt; ADD &lt;属性名&gt; 类型;</code></p><p>删除属性 <code>ALTER TABLE &lt;name&gt; DROP &lt;属性名&gt; 类型;</code></p><p>查看表格属性 <code>DECRIBE &lt;table_name&gt;;</code></p><p>加入内容 <code>INSERT INTO &lt;table_name&gt; VALUES(属性1-内容,属性2-内容);</code></p><p>查找表格 <code>SELECT * FROM &lt;table_name&gt;;</code> 此条命令为查找当前数据库内所有名为table_name的表格，并完全展示出来</p><h4 id="限制和限制的类型"><a href="#限制和限制的类型" class="headerlink" title="限制和限制的类型"></a>限制和限制的类型</h4><ul><li>UNIQUE    –不允许重名</li><li>AUTO_INCREMENT    –增加内容时自动加一，无需手动填写 （用于序号）</li><li>DEFAULT    –预设值，不填写内容时，按照预设的填写</li></ul><h4 id="修改资料"><a href="#修改资料" class="headerlink" title="修改资料"></a>修改资料</h4><p>语法</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `table_name`</span><br><span class="line"><span class="keyword">SET</span> `属性名` <span class="operator">=</span> <span class="string">'目标值'</span>;</span><br><span class="line"><span class="keyword">WHERE</span> 条件 (可以不写);</span><br></pre></td></tr></tbody></table></figure><p>示例</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `student`</span><br><span class="line"><span class="keyword">SET</span> `major` <span class="operator">=</span> <span class="string">'历史'</span>;</span><br><span class="line"><span class="keyword">WHERE</span> `major` <span class="operator">=</span> <span class="string">'生物'</span> <span class="keyword">OR</span> `major` <span class="operator">=</span> <span class="string">'物理'</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>将major为生物和物理的值，更新为历史</span><br></pre></td></tr></tbody></table></figure><h4 id="删除资料"><a href="#删除资料" class="headerlink" title="删除资料"></a>删除资料</h4><p>语法</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `table_name`</span><br><span class="line"><span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></tbody></table></figure><p>示例</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `student`</span><br><span class="line"><span class="keyword">WHERE</span> `score` <span class="operator">&gt;</span> <span class="number">60</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除 score小于<span class="number">60</span>的方式</span><br></pre></td></tr></tbody></table></figure><p><em>不写WHERE语句时，代表删除表格的所有资料</em></p><h4 id="搜寻资料"><a href="#搜寻资料" class="headerlink" title="搜寻资料"></a>搜寻资料</h4><p><code>SELECT * FROM &lt;table_name&gt;;</code>  =&gt; <code>*</code> 代表取得所有属性的意思</p><p><code>SELECT * FROM &lt;table_name&gt; LIMIT n;</code> =&gt; 仅仅显示前 n 笔资料</p><p><code>SELECT * FROM &lt;table_name&gt; WHERE &lt;属性名&gt; ;</code>  =&gt; 仅仅显示属性名为属性1的内容</p><p><em>WHERE &lt;属性名&gt; IN (‘1’,’2’)  = WHERE &lt;属性名&gt; = ‘1’ OR &lt;属性名&gt; = ‘2’</em>  </p><p><code>SELECT &lt;属性1&gt; FROM &lt;table_name&gt;;</code> =&gt;  代表取得属性名为属性1的内容，取得多个属性的时候用  <code>,</code> 隔开</p><p><code>SELECT DISTINCT &lt;属性1&gt; FROM &lt;table_name&gt;;</code> =&gt;去掉重复属性</p><p><code>SELECT * FROM &lt;table_name&gt; ORDER BY  &lt;属性1&gt; DESC;</code> =&gt;以属性1来排序表格</p><blockquote><p><code>DESC</code> 表示由高到低排序；不写时默认为<code>ASC</code>，代表由低到高排序</p></blockquote><p>示例</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> `student`</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> `score`,`student_id`</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>排序时，优先以score对表格内容进行从低到高的排序；当score相同时，以student_id作为基准排序</span><br></pre></td></tr></tbody></table></figure><blockquote><p><span class="github-emoji"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 各种语句的条件可以混用</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="operator">&gt;</span><span class="keyword">FROM</span> `student`</span><br><span class="line"><span class="operator">&gt;</span><span class="keyword">WHERE</span> `major` <span class="operator">=</span> <span class="string">'英语'</span> <span class="keyword">OR</span> `score` <span class="operator">&lt;&gt;</span> <span class="number">70</span></span><br><span class="line"><span class="operator">&gt;</span>LIMIT <span class="number">2</span>;</span><br><span class="line"><span class="operator">&gt;</span><span class="operator">/</span><span class="operator">/</span>回传major为英语和score不等于<span class="number">70</span>的前两个数据</span><br></pre></td></tr></tbody></table></figure></blockquote><p><strong>增加外键</strong> </p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>将table2的对应属性名，设置为table1的外键</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(`table1`)</span><br><span class="line"><span class="keyword">REFERENCES</span> `table2`(`table2对应属性名`)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>ON DELETE CASCADE 是当“table2对应属性名”被删除后，将table1中对应的值删掉</p><p>ON DELETE SET NULL 是当“table2对应属性名”被删除后，将table1中对应的值设置为NULL</p><p>当该键为其他表的主键时，不可以使用 ON DELETE SET NULL</p></blockquote><p><strong>基本逻辑</strong></p><p>新建表格时，先创建各个表格，再添加外键的关联</p><p>增加资料时，先增加外键所在的表格的资料，再增加自己表格的资料</p><h3 id="聚合函数-aggregate-functions"><a href="#聚合函数-aggregate-functions" class="headerlink" title="聚合函数 (aggregate functions)"></a>聚合函数 (aggregate functions)</h3><p>取得成员数   </p><ul><li><code>SELECT COUNT(&lt;属性名&gt;) FROM  &lt;table_name&gt;;</code></li><li><code>SELECT COUNT(*) FROM  &lt;table_name&gt;;</code></li></ul><p>在限制条件下取数 示例</p><ul><li><pre><code class="sql">SELECT COUNT(*) FROM  `employee`WHERE `birth_date` &gt; '1980-01-02' AND `sex` = 'F';//在employee表中取得birth_date 大于1980-01-02的女性</code></pre></li></ul><p>取得员工的平均薪水 示例</p><ul><li>​<code>SELECT AVG (&lt;salary&gt;) FROM &lt;employee&gt;;</code></li></ul><p>取得所有员工的薪水总和 示例</p><ul><li><code>SELECT SUM(&lt;salary&gt;) FROM &lt;employee&gt;;</code></li></ul><p>取得最高薪水</p><ul><li><code>SELECT MAX(&lt;salary&gt;) FROM &lt;employee&gt;;</code></li></ul><p>取得最低薪水</p><ul><li><code>SELECT MIN(&lt;salary&gt;) FROM &lt;employee&gt;;</code></li></ul><h3 id="万用字元-wildcards"><a href="#万用字元-wildcards" class="headerlink" title="万用字元 wildcards"></a>万用字元 wildcards</h3><p><strong>% 代表多个字元，_代表一个字元</strong></p><p>取得电话号码是335连续的客户</p><ul><li><code>SELECT * FROM &lt;cient&gt; WHERE &lt;phone&gt; LIKE '%335%';</code></li></ul><p>取得姓艾的客户</p><ul><li><code>SELECT *FROM &lt;client&gt; WHERE &lt;phone&gt; LIKE '艾%';</code></li></ul><p>取得生日在12月的员工 生日格式YYYY-MM-DD</p><ul><li><code>SELECT * FROM &lt;employee&gt; WHERE &lt;birth_data&gt; LIKE '_________12%';</code></li></ul><h3 id="union-连接搜寻结果"><a href="#union-连接搜寻结果" class="headerlink" title="union 连接搜寻结果"></a>union 连接搜寻结果</h3><p><span class="github-emoji"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  <strong>连接的属性数目和资料类型必须相同</strong></p><p>员工名字 连接 客户名字</p><ul><li><pre><code class="sql">SELECT &lt;name&gt; FROM &lt;employee&gt;UNIONSELECT &lt;client_name&gt; FROM &lt;client&gt;;<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">员工id+员工名字 连接 客户id+客户名字</span><br><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  SELECT &lt;employee_id&gt;,&lt;name&gt; </span><br><span class="line">  FROM &lt;employee&gt;</span><br><span class="line">  UNION</span><br><span class="line">  SELECT &lt;client_id&gt;,&lt;client_name&gt; </span><br><span class="line">  FROM &lt;client&gt;;</span><br><span class="line">  </span><br><span class="line">  //改名</span><br><span class="line">  SELECT &lt;employee_id&gt; AS &lt;total_id&gt;,&lt;name&gt; AS &lt;total_name&gt;</span><br><span class="line">  FROM &lt;employee&gt;</span><br><span class="line">  UNION</span><br><span class="line">  SELECT &lt;client_id&gt;,&lt;client_name&gt; </span><br><span class="line">  FROM &lt;client&gt;;</span><br></pre></td></tr></tbody></table></figure></code></pre></li></ul><h3 id="Join-连接表格"><a href="#Join-连接表格" class="headerlink" title="Join 连接表格"></a>Join 连接表格</h3><p>取得所有部门经理的资料 </p><ul><li><pre><code class="sql">//返回结果包含两个表格的所有属性SELECT * FROM &lt;employee&gt; JOIN &lt;branch&gt; ON &lt;emp_id&gt; = &lt;manager_id&gt; //条件<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```sql </span><br><span class="line">  //返回结果只包含选中的属性</span><br><span class="line">  SELECT &lt;emp_id&gt;,&lt;branch_name&gt;,&lt;name&gt; </span><br><span class="line">  FROM &lt;employee&gt; </span><br><span class="line">  JOIN &lt;branch&gt; </span><br><span class="line">  ON &lt;emp_id&gt; = &lt;manager_id&gt;</span><br></pre></td></tr></tbody></table></figure></code></pre></li></ul><blockquote><p>可以用<code>&lt;table_name&gt;.&lt;属性名&gt;</code> 来区分不同表格的相同属性名</p></blockquote><h4 id="left-关键字"><a href="#left-关键字" class="headerlink" title="left 关键字"></a>left 关键字</h4><p>不管条件是否成立，都会将JOIN左边的表格属性全部回传；右边的表格没有对应的属性时，就填写NULL</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>employee<span class="operator">&gt;</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="operator">&lt;</span>branch<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>emp_id<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>manager_id<span class="operator">&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="right-关键字"><a href="#right-关键字" class="headerlink" title="right 关键字"></a>right 关键字</h4><p>和left正好相反，不在此赘述</p><h3 id="subquery-子查询"><a href="#subquery-子查询" class="headerlink" title="subquery 子查询"></a>subquery 子查询</h3><p>在一个查询语句中插入另外一个查询语句，对前一个查询的结果进行查询</p><p>示例  找出研发部门的经理名字</p><ul><li><pre><code class="sql">//从员工标准中查找其名字SELECT `name`FROM `employee`WHERE `emp_id` = (    //得到 研发部门经理的id    SELECT `manager_id`    FROM `branch`    WHERE `branch_name` = `研发`);</code></pre></li></ul><p><em>把 WHERE 后的第一个”=” 换为IN，可用于多个查询结果</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链概述</title>
      <link href="/2024/07/31/qu-kuai-lian/qu-kuai-lian-gai-shu/qu-kuai-lian-gai-shu/"/>
      <url>/2024/07/31/qu-kuai-lian/qu-kuai-lian-gai-shu/qu-kuai-lian-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="区块链概述"><a href="#区块链概述" class="headerlink" title="区块链概述"></a>区块链概述</h1><h2 id="互联网的发展趋势"><a href="#互联网的发展趋势" class="headerlink" title="互联网的发展趋势"></a>互联网的发展趋势</h2><p>互联网经历了2个阶段：</p><ul><li><p>Web1.0<br>起初的互联网只提供  “读”，数据流向是单向的，也就是只有输入没有输出</p></li><li><p>Web2.0<br>也正是目前的主流互联网，它 提供 “读” “写”的功能，但是用户没办法拥有自己的数据，即“谁存储谁拥有”并非“谁创造谁拥有”。</p></li><li><p>Web3.0<br>目标是创建一个用户 “可读、可写、可拥有信息”的世界，用户可以将自己的信息掌握在自己的手中</p></li></ul><h2 id="为什么需要Web3？"><a href="#为什么需要Web3？" class="headerlink" title="为什么需要Web3？"></a>为什么需要Web3？</h2><p>这里需要提及两个概念=&gt; 中心化和去中心化</p><hr><h3 id="中心化"><a href="#中心化" class="headerlink" title="中心化"></a>中心化</h3><p>概念：在中心化系统中，通常有一个或少数几个主要的决策者或实体负责管理和控制系统的运作和资源分配。</p><p>我们现在就处在一个中心化的社会之中，举最简单的例子来说：买房子有中介、在短视频平台上发布视频的收益需要分成给平台，这些<strong>并非用户与用户之间的直接接触，需要第三方的参与</strong>，除此之外，大家应该都经历过，在某个平台上填写了个人信息之后，就骚扰电话和垃圾信息不断，个人隐私问题难以得到保证。</p><p>中心化系统带来这些挑战：单点故障、信任问题、透明度不足以及对个人权利和隐私的侵犯。</p><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><p>概念：去中心化将权力、控制或决策权分散到多个节点或参与者之间，而不是集中在单一的中心化实体或个体手中，简单理解就是，去除中介。</p><p>去中心化通过这样的手段来解决中心化带来的问题，实现了安全性的增强、公平的权力分配、更高的透明度和抗审查等能力。</p><hr><blockquote><p>很多东西不是非黑即白的，因此中心化不是绝对的错，去中心化也不是绝对的好，大部分前辈们所奋斗的方向也只是在中心化没做好的地方进行改革，希望理性看待这些问题。</p></blockquote><p>去中心化引发了许多新技术产生，其中最引人注目的便是区块链技术</p><h2 id="Web3的新技术-区块链"><a href="#Web3的新技术-区块链" class="headerlink" title="Web3的新技术 - 区块链"></a>Web3的新技术 - 区块链</h2><p>区块链通过一定的技术手段 ，实现了 “去中心化、可溯源、不可篡改”的特点，成为一个分布式的账本模型，在此之中，所有参与者共享同一个数据账本，每个参与者都可以查看完整的交易记录。</p><p>根据使用权限、治理结构和应用范围等多个维度将区块链进行分类，可以分为以下几类：</p><ol><li><strong>公链（Public Blockchain）</strong>：<ul><li>公链是一种开放的区块链网络，任何人都可以加入和参与其中，查看数据、验证交易，并可以自由创建和验证交易。典型的公链包括比特币（Bitcoin）和以太坊（Ethereum）等。</li></ul></li><li><strong>私链（Private Blockchain）</strong>：<ul><li>私链是一种受限制的区块链网络，参与者必须获得许可才能加入，通常由单个实体或组织管理和控制。私链可以提供更高的性能和隐私保护，常见于企业内部或特定联盟中。</li></ul></li><li><strong>联盟链（Consortium Blockchain）</strong>：<ul><li>联盟链是一种由多个组织或实体共同管理的区块链网络，参与者必须获得许可才能加入，但参与者之间有明确的信任关系。联盟链通常用于跨组织间的合作和数据共享。</li></ul></li></ol><p>现在的区块链仍然处于探索和发展的初期阶段，正需要新鲜血液来创新和参与，区块链世界欢迎你们-未来的开拓者。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>http学习笔记</title>
      <link href="/2024/07/29/ji-suan-ji-wang-luo-ji-chu/http-xue-xi-bi-ji/"/>
      <url>/2024/07/29/ji-suan-ji-wang-luo-ji-chu/http-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP学习笔记"><a href="#HTTP学习笔记" class="headerlink" title="HTTP学习笔记"></a>HTTP学习笔记</h1><blockquote><p>推荐教程：<a href="https://juejin.cn/post/6844903673680789517">https://juejin.cn/post/6844903673680789517</a></p></blockquote><p>HTTP全称 <strong>超文本传输协议</strong>（HyperText Transfer Protocol），是一种用于在网络上进行数据传输的协议，可以通俗理解为 这是电脑与电脑之间的沟通方式，主要用于网页上。</p><h2 id="HTTP的组成和基本概念"><a href="#HTTP的组成和基本概念" class="headerlink" title="HTTP的组成和基本概念"></a><strong>HTTP的组成和基本概念</strong></h2><ul><li><strong>客户端和服务器</strong>：HTTP 通常工作在客户端（如网页浏览器）和服务器之间。客户端向服务器发送请求，服务器处理请求并返回响应。</li><li><strong>请求和响应</strong>：HTTP 的工作方式基于请求-响应模型。客户端发送一个请求（包括请求行、请求头和请求体），服务器处理请求并返回一个响应（包括状态行、响应头和响应体）。</li></ul><p><strong>示例：</strong><a href="http://www.google.com/">http://www.google.com</a>  </p><p><code>http</code>定义了选择的协议方式    <code>www.google.com  </code> 则对应需要访问的ip地址</p><p><em>ip地址可以理解为每个人的家庭住址</em></p><p><strong>过程</strong>：当我们在浏览器上输入一段网址后，浏览器就会发送请求到服务器，服务器接受请求后回传数据，这个数据经过电脑处理后就会返回我们通常看到的网页。</p><blockquote><p>❗️ 并不是只有网址才会触发请求</p><p>例如在购物平台购物时，当点击<code>购物</code>按钮时，就已经隐匿地向服务器发送了请求，此时架构是在应用中实现</p></blockquote><h2 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a><strong>HTTP 方法</strong></h2><p>HTTP 定义了一些常见的方法来执行不同的操作，包括：</p><ul><li><strong>GET</strong>：获取资料，通常用于从服务器获取数据。</li><li><strong>POST</strong>：上传资料，用于创建或更新资源。</li><li><strong>PUT</strong>：更新指定的资源。</li><li><strong>DELETE</strong>：删除指定的资源。</li><li><strong>PATCH：</strong>覆盖资料</li></ul><p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 区别GET和POST方法：</p><table><thead><tr><th>特性</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td><strong>目的</strong></td><td>从服务器获取数据或资源</td><td>向服务器提交数据以处理或存储</td></tr><tr><td><strong>数据位置</strong></td><td>数据附加在 URL 的查询字符串中</td><td>数据放在请求体（Body）中</td></tr><tr><td><strong>数据量</strong></td><td>数据量有限，受 URL 长度限制</td><td>数据量没有严格限制，可以传输大量数据</td></tr><tr><td><strong>安全性</strong></td><td>数据暴露在 URL 中，相对不安全</td><td>数据不暴露在 URL 中，相对较安全</td></tr><tr><td><strong>缓存</strong></td><td>请求可以被缓存</td><td>请求一般不被缓存</td></tr><tr><td><strong>书签</strong></td><td>URL 可以被书签保存</td><td>URL 不适合直接书签</td></tr><tr><td><strong>适用场景</strong></td><td>获取资源或数据，如读取页面或搜索内容</td><td>提交表单、上传文件、修改或创建资源</td></tr><tr><td><strong>示例请求</strong></td><td><code>GET /page?name=value</code></td><td><code>POST /submit</code> <br> <code>Content-Type: application/x-www-form-urlencoded</code> <br> <code>name=John&amp;age=30</code></td></tr></tbody></table><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a><strong>HTTP报文</strong></h2><p>报文就是客户端和服务器之间沟通所需要遵循的格式</p><ul><li><p><strong>请求结构</strong>：</p><ul><li><p><strong>请求行</strong>：包含请求方法（如 GET、POST）、请求目标（如 URL）和 HTTP 版本。</p></li><li><p><strong>请求头</strong>：包括客户端环境的信息，如浏览器类型、语言等。</p></li><li><p><strong>请求体</strong>：包含需要发送给服务器的数据。</p></li></ul><p><span class="github-emoji"><span>🌟</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>示例</strong>：<a href="http://api/shop.com/card">http://api/shop.com/card</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /card HTTP/1.1  *请求行</span><br><span class="line">---</span><br><span class="line">Host:api.shop.com  *传送的目标地址与请求行组合成网址</span><br><span class="line">User-Agent:Mozila/5.0(windows...)Chrome  *请求的发送地址</span><br><span class="line">Accept:text/plain  *可接受的回传档案类型</span><br><span class="line">Content-Type:text/plain  *传送的档案类型</span><br><span class="line">Con-Length:43  *内容长度</span><br><span class="line">---</span><br><span class="line">{"card":1234567890."total_price":8787}  *内容=&gt;可以推断为刷卡的请求</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>响应</strong>结构：</p><ul><li><strong>状态行</strong>：包含 HTTP 版本、状态码（如 200、404）和状态消息。</li><li><strong>响应头</strong>：包含服务器的信息和响应的元数据，如内容类型、长度等。</li><li><strong>响应体</strong>：实际返回给客户端的数据，如网页内容、图片等。</li></ul><p><span class="github-emoji"><span>🌟</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>示例：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">---</span><br><span class="line">Server:nginx  *服务器软体类型</span><br><span class="line">Content-Type:text/plain  *回传信息的类型</span><br><span class="line">Content-Length:7  *回传信息的长度</span><br><span class="line">Date:Fri,27 Aug 2021 20:09:07 GMT  *回传回去的时间</span><br><span class="line">---</span><br><span class="line">success</span><br></pre></td></tr></tbody></table></figure></li></ul><p><span class="github-emoji"><span>👀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f440.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>因此我们可以将请求和相应简单理解为两个人在相互写信，当然写信是需要遵循信的格式的 !</p><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a><strong>HTTP 状态码</strong></h2><p>HTTP 状态码用于表示请求的结果，常见的状态码包括：</p><ul><li><strong>200 OK</strong>：请求成功，服务器返回请求的数据。</li><li><strong>201 Creat</strong>: 创建成功</li><li><strong>301 Moved Permanently</strong>：请求的资源已被永久移动到新位置。</li><li><strong>400 Bad Request</strong>: 发送的格式错误力</li><li><strong>401 Unauthorized</strong>：请求的资源比较敏感，需要验证</li><li><strong>403 Forbidden</strong>: 验证身份不合格</li><li><strong>404 Not Found</strong>：请求的资源未找到。</li><li><strong>500 Internal Server Error</strong>：服务器内部错误，无法完成请求。</li></ul><h2 id="✅-HTTP-与-HTTPS-的区别总结"><a href="#✅-HTTP-与-HTTPS-的区别总结" class="headerlink" title="✅ HTTP 与 HTTPS 的区别总结"></a>✅ HTTP 与 HTTPS 的区别总结</h2><h3 id="一、📖-本质区别"><a href="#一、📖-本质区别" class="headerlink" title="一、📖 本质区别"></a>一、📖 本质区别</h3><table><thead><tr><th>项目</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>全称</td><td>HyperText Transfer Protocol</td><td>HyperText Transfer Protocol Secure</td></tr><tr><td>是否加密</td><td>❌ 明文传输，存在安全风险</td><td>✅ 加密传输，安全性高</td></tr><tr><td>默认端口</td><td>80</td><td>443</td></tr><tr><td>加密机制</td><td>无</td><td>使用 SSL/TLS 协议实现加密</td></tr><tr><td>证书</td><td>不需要</td><td>需要向 CA 申请数字证书验证身份</td></tr></tbody></table><hr><h3 id="二、🔐-安全机制"><a href="#二、🔐-安全机制" class="headerlink" title="二、🔐 安全机制"></a>二、🔐 安全机制</h3><h4 id="1-加密方式：混合加密"><a href="#1-加密方式：混合加密" class="headerlink" title="1. 加密方式：混合加密"></a>1. <strong>加密方式：混合加密</strong></h4><p>HTTPS 使用 <strong>混合加密</strong>，结合对称加密和非对称加密：</p><table><thead><tr><th>加密类型</th><th>说明</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>对称加密</td><td>通信双方使用相同密钥</td><td>加密速度快</td><td>密钥交换不安全</td></tr><tr><td>非对称加密</td><td>使用一对公钥和私钥</td><td>密钥交换安全</td><td>加密解密速度慢</td></tr></tbody></table><blockquote><p>👉 解决方案：<strong>先用非对称加密交换“会话密钥”，再用对称加密传输数据</strong>，即混合加密。</p></blockquote><hr><h3 id="三、🔗-建立连接的过程"><a href="#三、🔗-建立连接的过程" class="headerlink" title="三、🔗 建立连接的过程"></a>三、🔗 建立连接的过程</h3><h4 id="📡-HTTP："><a href="#📡-HTTP：" class="headerlink" title="📡 HTTP："></a>📡 HTTP：</h4><ul><li>建立 TCP 连接（三次握手）→ 直接发送 HTTP 请求</li></ul><h4 id="🔐-HTTPS："><a href="#🔐-HTTPS：" class="headerlink" title="🔐 HTTPS："></a>🔐 HTTPS：</h4><ul><li>TCP 三次握手</li><li><strong>TLS/SSL 握手过程（建立安全连接）：</strong><ul><li>客户端发起请求，携带支持的加密算法</li><li>服务器返回证书和公钥</li><li>客户端验证证书合法性，用公钥加密生成的对称密钥并发送给服务器</li><li>服务器用私钥解密获取会话密钥</li></ul></li><li>建立完成后，使用 <strong>对称加密</strong> 传输数据</li></ul><hr><h3 id="四、📃-数字证书的作用"><a href="#四、📃-数字证书的作用" class="headerlink" title="四、📃 数字证书的作用"></a>四、📃 数字证书的作用</h3><ul><li>HTTPS 需要向 <strong>CA（Certificate Authority）申请数字证书</strong></li><li>数字证书包含：网站身份、公钥、签名、有效期等信息</li><li>作用：<ul><li>✅ 确认服务器身份是否可信（防止中间人攻击）</li><li>✅ 公钥分发，确保密钥交换安全</li></ul></li></ul><hr><h3 id="五、📌-为什么-HTTPS-更安全？"><a href="#五、📌-为什么-HTTPS-更安全？" class="headerlink" title="五、📌 为什么 HTTPS 更安全？"></a>五、📌 为什么 HTTPS 更安全？</h3><ol><li><strong>数据加密</strong>（防窃听）</li><li><strong>身份验证</strong>（防伪装）</li><li><strong>数据完整性校验</strong>（防篡改，使用摘要算法如 SHA-256）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sui-学习路径</title>
      <link href="/2024/07/18/qu-kuai-lian/sui-xue-xi-lu-jing/"/>
      <url>/2024/07/18/qu-kuai-lian/sui-xue-xi-lu-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h1><h2 id="步骤一：前置安装"><a href="#步骤一：前置安装" class="headerlink" title="步骤一：前置安装"></a>步骤一：前置安装</h2><h3 id="安装Sui-Wallet"><a href="#安装Sui-Wallet" class="headerlink" title="安装Sui Wallet"></a>安装Sui Wallet</h3><p>采用Google插件<br><a href="https://chromewebstore.google.com/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil">https://chromewebstore.google.com/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil</a></p><h3 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h3><p>具体安装过程需要自行探索<br><a href="https://nodejs.org/en">https://nodejs.org/en</a>  </p><h3 id="安装编译器"><a href="#安装编译器" class="headerlink" title="安装编译器"></a>安装编译器</h3><p>VSCODE 和 RustRover 二选一即可</p><h4 id="RustRover"><a href="#RustRover" class="headerlink" title="RustRover"></a>RustRover</h4><p>RustRover的报错和提示比较友好，也有成熟的插件<br><a href="https://www.jetbrains.com.cn/rust/">https://www.jetbrains.com.cn/rust/</a></p><h4 id="VSCODE"><a href="#VSCODE" class="headerlink" title="VSCODE"></a>VSCODE</h4><p>容易上手，通用性强<br><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><h3 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h3><p><a href="https://docs.sui.io/guides/developer/getting-started/sui-install">https://docs.sui.io/guides/developer/getting-started/sui-install</a><br>建议采用从Github下载二进制文件，对小白更友好</p><h2 id="步骤二：基本语法学习"><a href="#步骤二：基本语法学习" class="headerlink" title="步骤二：基本语法学习"></a>步骤二：基本语法学习</h2><p><a href="https://www.bilibili.com/video/BV1Rm42177Kx/">bilibili教学视频</a> (视频包括基本语法的学习和实战演练  )<br>课程相关代码库:</p><ul><li><a href="https://github.com/404ll/letsmove/tree/main/tutorial/bootcamp">https://github.com/404ll/letsmove/tree/main/tutorial/bootcamp</a></li><li>Swap以及Coin的代码库 <a href="https://github.com/uvd/sui-swap-course">https://github.com/uvd/sui-swap-course</a></li></ul><p>完整入门手册，非常详细</p><ul><li><a href="https://easy.sui-book.com/">轻松入门move</a></li></ul><h2 id="步骤三：深入学习以及完成task"><a href="#步骤三：深入学习以及完成task" class="headerlink" title="步骤三：深入学习以及完成task"></a>步骤三：深入学习以及完成task</h2><p>区块链浏览器：<a href="https://suivision.xyz/">https://suivision.xyz/</a></p><p>由于教学视频的时间限制，手把手教学来完成每一个task基本是不现实的，同时已有的学习资料已经完全足够从入门到熟练掌握<br>因此需要学员有强大的内驱力和学习能力，从已有的文档和代码库中，寻找和学习所需的知识点  </p><p>基于官方标准库，可以查询和了解每一个函数的功能及使用方法</p><ul><li><a href="https://github.com/MystenLabs/sui/tree/main/crates/sui-framework">https://github.com/MystenLabs/sui/tree/main/crates/sui-framework</a></li></ul><p>探索官方文档（包括Coin协议等等）</p><ul><li><a href="https://docs.sui.io/">https://docs.sui.io</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> sui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apots - move 课程笔记</title>
      <link href="/2024/07/12/qu-kuai-lian/apots-move-xue-xi-bi-ji/"/>
      <url>/2024/07/12/qu-kuai-lian/apots-move-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/aptos-labs/aptos-core/">https://github.com/aptos-labs/aptos-core/</a></p></blockquote><blockquote><p>github代码参考：<a href="https://github.com/aptos-labs/aptos-core/">https://github.com/aptos-labs/aptos-core/</a></p></blockquote><h2 id="模块交互与发布"><a href="#模块交互与发布" class="headerlink" title="模块交互与发布"></a>模块交互与发布</h2><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>生成账户地址：aptos init</p><p>领水：aptos account fund-with-faucet –account de fault </p><p>编译：aptos move compile</p><p>测试:  aptos move test</p><p>发布：aptos move publish</p><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>Aptos 区块链浏览器:<a href="https://explorer.aptoslabs.com/">https://explorer.aptoslabs.com/</a></p><p>生成的<code>sender</code>来搜索（记得切换对应网络）</p><p>点击 Modules-run 实施交互，进行基本调试</p><h2 id="Vector-向量解析"><a href="#Vector-向量解析" class="headerlink" title="Vector 向量解析"></a>Vector 向量解析</h2><p>特性：vector 可以理解为其他语言的数组</p><h3 id="查询功能"><a href="#查询功能" class="headerlink" title="查询功能"></a>查询功能</h3><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>vector::is_empty<t>(): bool</t></td><td>查询是否是空数组</td></tr><tr><td>vector::length<t>(v: &amp;vector<t>): u64</t></t></td><td>查询数组长度</td></tr><tr><td>vector::borrow<t>(v: &amp;vector<t>, i: u64): &amp;T</t></t></td><td>返回数组第n项的数据</td></tr><tr><td>vector::borrow_mut<t>(v: &amp;mut vector<t>, i: u64): &amp;mut T</t></t></td><td>返回数组第n项的可变引用</td></tr><tr><td>vector::contains<t>(v: &amp;vector<t>, e: &amp;T): bool</t></t></td><td>如果元素e在数组中，则返回true</td></tr><tr><td>vector::index_of<t>(v: &amp;vector<t>, e: &amp;T): (bool, u64)</t></t></td><td>如果元素e在数组中，则返回true和索引位置</td></tr></tbody></table><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><table><thead><tr><th><strong>语法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>vector::push_back<t>(v: &amp;mut vector<t>, t: T)</t></t></td><td>添加尾部1个元素</td></tr><tr><td>vector::append<t>(v1: &amp;mut vector<t>, v2: vector<t>)</t></t></t></td><td>添加尾部1个数组</td></tr><tr><td>vector::reverse_append<t>(lhs: &amp;mut vector<t>, other: vector<t>)</t></t></t></td><td>添加尾部1个数组，并进行排序</td></tr><tr><td>vector::pop_back<t>(v: &amp;mut vector<t>): T</t></t></td><td>删掉尾部1个元素</td></tr><tr><td>vector::destroy_empty<t>(v: vector<t>)</t></t></td><td>删除数组</td></tr><tr><td>vector::swap<t>(v: &amp;mut vector<t>, i: u64, j: u64)</t></t></td><td>交换数组中两个元素的位置</td></tr><tr><td>vector::reverse<t>(v: &amp;mut vector<t>)</t></t></td><td>反转数组中元素的顺序</td></tr><tr><td>vector::insert<t>(v: &amp;mut vector<t>, i: u64, e: T)</t></t></td><td>在长度为i-1处插入一个元素</td></tr><tr><td>vector::remove<t>(v: &amp;mut vector<t>, i: u64): T</t></t></td><td>删除索引为i处的元素</td></tr></tbody></table><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">module 0x42::lesson4{</span><br><span class="line">    use std::debug;</span><br><span class="line">    use std::vector;</span><br><span class="line">//create a vector of u64</span><br><span class="line">    const ARR:vector&lt;u64&gt; = vector[1,2,3,4,5,6];</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fun test_vector(){</span><br><span class="line">        debug::print(&amp;ARR);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fun test_empty_vector(){</span><br><span class="line">        let bools:bool = vector::is_empty(&amp;ARR);</span><br><span class="line">        debug::print(&amp;bools);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    #[test]</span><br><span class="line">    fun test_vector_length(){</span><br><span class="line">        let len:u64 = vector::length(&amp;ARR);</span><br><span class="line">        debug::print(&amp;len);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fun test_vector_borrow(){</span><br><span class="line">        let val = vector::borrow(&amp;ARR,3);</span><br><span class="line">        debug::print(val);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    #[test]</span><br><span class="line">    fun test_vector_borrow_mut(){</span><br><span class="line">        //change vector value</span><br><span class="line">        let arr:vector&lt;u64&gt; = vector[1,2,3,4,5];</span><br><span class="line">        let val = vector::borrow_mut(&amp;mut arr,3);</span><br><span class="line">        *val = 100;</span><br><span class="line">        debug::print(&amp;arr); </span><br><span class="line">    }</span><br><span class="line">    #[test]</span><br><span class="line">    fun test_vector_contains(){</span><br><span class="line">        let n2:u64 = 11;</span><br><span class="line">        let n:u64 = 3;</span><br><span class="line">        let bools:bool = vector::contains(&amp;ARR,&amp;n);</span><br><span class="line">        let bools2:bool = vector::contains(&amp;ARR,&amp;n2);</span><br><span class="line">        debug::print(&amp;bools);</span><br><span class="line">        debug::print(&amp;bools2);</span><br><span class="line">    }</span><br><span class="line">    #[test]</span><br><span class="line">    fun test_vector_index_of(){</span><br><span class="line">        let n2:u64 = 11;</span><br><span class="line">        let n:u64 = 3;</span><br><span class="line">        let (isIndex,index) = vector::index_of(&amp;ARR,&amp;n);</span><br><span class="line">        let (isIndex2,index2) = vector::index_of(&amp;ARR,&amp;n2);</span><br><span class="line">        debug::print(&amp;index);</span><br><span class="line">        debug::print(&amp;index2);</span><br><span class="line">        debug::print(&amp;isIndex);</span><br><span class="line">        debug::print(&amp;isIndex2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>函数修饰符是用来赋予函数特殊能力的一组关键字。</p><p><strong>主要有以下几类</strong></p><p>可见性</p><ul><li><p>无public，私有函数，仅限module内部调用</p></li><li><p>friend (public)，模块内部函数，同包模块之间可以调用</p></li><li><p>public，模块公开函数，所有模块都可以调用</p></li></ul><p>全局存储引用</p><ul><li>acquires，当需要使用<code>move_from</code>、<code>borrow_global</code>、<code>borrow_global_mut</code> 访问地址下的资源的时候，需要用其修饰</li></ul><p>链下</p><ul><li><p>entry，修饰后，该方法可由链下脚本调用</p><h4 id="代码示例1"><a href="#代码示例1" class="headerlink" title="代码示例1"></a>代码示例1</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">address 0x42{</span><br><span class="line">    module m{</span><br><span class="line">        friend 0x42::m3;</span><br><span class="line"></span><br><span class="line">        fun f1() : u64{</span><br><span class="line">            1</span><br><span class="line">        }</span><br><span class="line">        //public 可以被外部访问</span><br><span class="line">        public fun f2() : u64{</span><br><span class="line">            2</span><br><span class="line">        }</span><br><span class="line">        //外部模块无法直接调用，需要声明friend</span><br><span class="line">        public(friend) fun f3() : u64{</span><br><span class="line">            3</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    module m2{</span><br><span class="line">        fun f1() : u64{</span><br><span class="line">            0x42::m::f2()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    //view f2 f3</span><br><span class="line">    module m3{</span><br><span class="line">        fun f1() : u64{</span><br><span class="line">            0x42::m::f3()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="代码示例2"><a href="#代码示例2" class="headerlink" title="代码示例2"></a>代码示例2</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module 0x42::Demo{</span><br><span class="line">    use std::debug;</span><br><span class="line">   // 每个账户在 move 中都有一个唯一的 Signer，它通常是账户的创建者或者拥有者。</span><br><span class="line">    use std::signer;</span><br><span class="line"></span><br><span class="line">    struct Coin has key{</span><br><span class="line">        value:u64</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">//可以被链下调用</span><br><span class="line">    public entry fun mint(account: &amp;signer, value: u64){</span><br><span class="line">    //将Coin移动到用户的地址中去</span><br><span class="line">        move_to(account, Coin{value});</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    #[test(account = @0x42)]</span><br><span class="line">    //acquires</span><br><span class="line">    public fun test_mint(account: &amp;signer)acquires Coin{</span><br><span class="line">    </span><br><span class="line">    //获取account的地址</span><br><span class="line">        let addr = signer::address_of(account);</span><br><span class="line">        mint(account, 10);</span><br><span class="line">        </span><br><span class="line">     //从全局资源中借用指定地址addr处的Coin类型资源，并获取其value</span><br><span class="line">        let coin = borrow_global&lt;Coin&gt;(addr).value;</span><br><span class="line">        debug::print(&amp;coin)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="struct-结构体"><a href="#struct-结构体" class="headerlink" title="struct 结构体"></a>struct 结构体</h2><h4 id="核心概念-1"><a href="#核心概念-1" class="headerlink" title="核心概念"></a>核心概念</h4><p>  Struct 结构体，用来存储具有结构化的数据，sturct可以相互嵌套（不能递归）可存储地址下作为资源，默认情况下，结构声明是线性且短暂的（也就是没办法引用）</p><ol><li>命名必须以大写字母开头</li><li>可以通过has 关键词赋与能力</li></ol><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>-Copy   值能够被复制<br>-Drop  值可以在作用域结束时删除<br>-Key   值可以用作全局存储操作的key，可以索引到相关结构体<br>-Store   值可以被全局存储，结合key使用，实现嵌套</p><p>  除struct类型外，其他的类型默认具备 store,drop,copy 的能力，sturct 最终是存储在用户的地址上（或者被销毁），不存在aptos合约里，aptos合约是一个全纯的函数（相较于Solidity）</p><h3 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h3><ol><li>对象是单个地址的资源容器，用于储存资源；</li><li>对象提供了一种集中式资源控制与所有权管理的方法；</li></ol><h3 id="创建并转移对象案例"><a href="#创建并转移对象案例" class="headerlink" title="创建并转移对象案例"></a>创建并转移对象案例</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module my_addr::object_playgoud{</span><br><span class="line">use std::signer;</span><br><span class="line">use aptos_framework::object::{self,ObjectCore};</span><br><span class="line"></span><br><span class="line">entry fun create_and_transfer(caller:&amp;signer,destination:address){</span><br><span class="line">//接受拥有者地址</span><br><span class="line">let caller_adsress = signer::address_of(caller);</span><br><span class="line">//绑定地址和对象</span><br><span class="line">let constructor_ref = object::create_object(caller_address);</span><br><span class="line"></span><br><span class="line">//Set up the object</span><br><span class="line">    </span><br><span class="line">    //transfer to destination</span><br><span class="line">    //转移所有权</span><br><span class="line">    let object = object::object_from_constructor_ref&lt;ObjectCore&gt;(</span><br><span class="line">    &amp;constructor_ref</span><br><span class="line">    );</span><br><span class="line">    object::transfer(caller,object,destination);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="三种对象类型"><a href="#三种对象类型" class="headerlink" title="三种对象类型"></a>三种对象类型</h4><ul><li>普通对象<strong>。</strong>可删除，且具有随机地址<code>object::create_object(owner_address: address)</code></li><li>命名对象。不可删除，通过固定的signer和特定的seed生成唯一地址的对象，1个地址只能生成1个，具有确定性地址<code>object::create_named_object(creator: &amp;signer, seed: vector&lt;u8&gt;)</code></li><li>粘性对象。不可删除，通过signer生成的对象，1个地址可以生成多个，具有随机地址<code>object::create_sticky_object(owner_address: address)</code></li></ul><p>示例代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">module 0x42::demo{</span><br><span class="line">    use std::debug::print;</span><br><span class="line">    use aptos_framework::object;</span><br><span class="line">    use aptos_framework::object::{Object, ConstructorRef, ObjectCore};</span><br><span class="line"></span><br><span class="line">    use std::signer;</span><br><span class="line"></span><br><span class="line">    const NAME:vector&lt;u8&gt; = b"myObject";</span><br><span class="line"> //can_delet</span><br><span class="line">    public fun createDeleteableObject(caller: &amp;signer):ConstructorRef{</span><br><span class="line">       let caller_addr = signer::address_of(caller);</span><br><span class="line">       let obj = object::create_object(caller_addr);</span><br><span class="line">       obj</span><br><span class="line">    }   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    //aptos-labs/examples</span><br><span class="line"></span><br><span class="line">//cannt</span><br><span class="line">   public fun createNamedObject(caller: &amp;signer):ConstructorRef{</span><br><span class="line">       let obj = object::create_named_object(caller, NAME);</span><br><span class="line">       obj</span><br><span class="line">    }   </span><br><span class="line">   public fun createStickyObject(caller: &amp;signer):ConstructorRef{</span><br><span class="line">        let caller_addr = signer::address_of(caller);</span><br><span class="line">       let obj = object::create_sticky_object(caller_addr);</span><br><span class="line">       obj</span><br><span class="line">    }   </span><br><span class="line"> #[test(caller = @0x88)]</span><br><span class="line">    fun test2(caller: &amp;signer){</span><br><span class="line">       let obj = createNamedObject(caller);</span><br><span class="line">       print(&amp;obj);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       #[test(caller = @0x88)]</span><br><span class="line">    fun test(caller: &amp;signer){</span><br><span class="line">      let obj = createDeleteableObject(caller);</span><br><span class="line">       print(&amp;obj);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">      #[test(caller = @0x88)]</span><br><span class="line">    fun test3(caller: &amp;signer){</span><br><span class="line">      let obj = createStickyObject(caller);</span><br><span class="line">      print(&amp;obj);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Object-配置"><a href="#Object-配置" class="headerlink" title="Object  配置"></a>Object  配置</h4><p>一旦您创建了对象，您将收到一个<code>ConstructorRef</code>可用于生成其他<code>Ref</code>s 。<code>Refs</code>可在将来用于启用/禁用/执行某些对象功能，例如传输资源、传输对象本身或删除对象。</p><ol><li><p>允许删除对象 ( <code>DeleteRef</code>)</p><p>对于使用默认方法（允许删除）创建的对象，您可以生成一个<code>DeleteRef</code>稍后可以使用的对象。这可以帮助消除混乱并获得存储退款。<code>DeleteRef</code>您不能为不可删除的对象创建。</p></li><li><p>一次性转账 ( <code>LinearTransferRef</code>)</p><p>此外，如果创建者想要控制所有传输，以提供一次性使用的传输功能。这可用于通过从对象创建者到接收者的一次性传输来创建“灵魂绑定”对象。必须<code>LinearTransferRef</code>由对象的所有者使用。</p></li><li><p>禁用/切换传输 ( <code>TransferRef</code>)</p><p>默认情况下，所有对象都是可转让的。这可以通过 来更改，<code>TransferRef</code>来生成<code>object::generate_transfer_ref</code>。</p></li><li><p>添加可扩展性（<code>ExtendRef</code>)</p></li></ol><p>  将对象变成可动态配置的，可以往里面添置新的 struct 资源。生成一个<code>ExtendRef</code>和<code>object::generate_extend_ref</code>。此引用可用于为该对象生成签名者。</p><ol start="5"><li><p>添加资源</p><p>使用<code>ConstructorRef</code>和<code>object::generate_signer</code>创建一个签名者，允许您将资源转移到对象上。这使用<code>move_to</code>，与将资源添加到帐户的功能相同</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> move智能合约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aptos学习资源</title>
      <link href="/2024/06/22/qu-kuai-lian/aptos-xue-xi-zi-yuan/"/>
      <url>/2024/06/22/qu-kuai-lian/aptos-xue-xi-zi-yuan/</url>
      
        <content type="html"><![CDATA[<h1 id="Aptos学习资源"><a href="#Aptos学习资源" class="headerlink" title="Aptos学习资源"></a>Aptos学习资源</h1><h2 id="我的整理"><a href="#我的整理" class="headerlink" title="我的整理"></a>我的整理</h2><ul><li>Aptos入门研报 [<a href="https://404ll.github.io/2024/06/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Move-on-Aptos-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%85%A5%E9%97%A8/">Move on Aptos 初入门-研报 | Elemen的象牙塔 (404ll.github.io)</a>]</li></ul><h2 id="共学营学员资料"><a href="#共学营学员资料" class="headerlink" title="共学营学员资料"></a>共学营学员资料</h2><blockquote><p>以下收录了Move On Aptos 共学营的全部资料</p></blockquote><ul><li><a href="https://alcove-pro.notion.site/Move-on-Aptos-alcove-bc0e60f57caa4f2195e06f89bfaedf8e?pvs=4">Notion资料</a> 这个资料包括了新手入门的了解和各种文档，以及课程的代码</li><li><a href="https://drive.google.com/drive/folders/1-EmZXvuPuVH60XmbmFxUg1jDm6-uDDG2">Google 云盘共学视频</a> 视频包括了Move语法的学习和实战，节奏很慢，适合学习</li><li><a href="https://aptos.dev/">Aptos开发者文档</a> 文档比较详细的说明了如何安装环境和一些进阶语法，英文版可以配合谷歌浏览器的自动翻译</li></ul><p>还有一段共学老师说的话，我觉得很有道理，所以分享出来:</p><p>“刚学一门语言会遇到很多新的语法和新的库接口，这是一定的。</p><p>最好的方法是把代码逐行解读，把每一行弄懂（可以通过写注释，或者打印在纸上），这样坚持看 3 个项目的源码，就可以自己仿照着写项目了。</p><p>写项目的时候又会遇到一些新的需求，就需要去看文档/源码，等项目做出来了，这个时候你对一个语言的基本世界观就形成了。</p><p>学新语言，忌求快。</p><p>时刻牢记，慢就是快。”</p>]]></content>
      
      
      
        <tags>
            
            <tag> 资源收录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫盲小知识之 质押与再质押</title>
      <link href="/2024/05/21/qu-kuai-lian/2024-05-21-sao-mang-xiao-zhi-shi-zhi-zhi-ya-yu-zai-zhi-ya/"/>
      <url>/2024/05/21/qu-kuai-lian/2024-05-21-sao-mang-xiao-zhi-shi-zhi-zhi-ya-yu-zai-zhi-ya/</url>
      
        <content type="html"><![CDATA[<h1 id="质押-staking-与-再质押-restaking"><a href="#质押-staking-与-再质押-restaking" class="headerlink" title="质押(staking) 与 再质押(restaking)"></a>质押(staking) 与 再质押(restaking)</h1><h2 id="质押"><a href="#质押" class="headerlink" title="质押"></a>质押</h2><blockquote><p>质押（staking）是一种通过锁定一定数量的加密货币来支持区块链网络操作（例如验证交易和维护网络安全）的机制。作为回报，质押者可以获得奖励（通常是额外的加密货币），同时质押者通常拥有一定的投票权或参与网络治理的权利</p></blockquote><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a><strong>详细解释</strong>：</h3><ul><li><strong>Proof of Stake（PoS）</strong>：质押最常见于基于权益证明（Proof of Stake, PoS）共识机制的区块链中。在这种机制下，区块链通过质押者的投票选举出区块验证者（validators），而不是通过解决复杂的数学难题（如在工作量证明（Proof of Work, PoW）机制中）。</li><li><strong>奖励</strong>：质押者通常会根据他们所质押的加密货币数量和质押时间长度来获得奖励。这些奖励可以是新生成的加密货币或交易费用的一部分。</li><li><strong>风险</strong>：质押也有风险，例如质押的加密货币可能会被冻结一定时间，无法随时取出。此外，如果网络遭受攻击或质押者不遵守规则，可能会损失一部分或全部质押的加密货币。</li></ul><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a><strong>举例</strong>：</h3><ul><li><strong>以太坊2.0</strong>：以太坊2.0采用PoS机制，用户可以质押32个以太币（ETH）成为验证者，并获得奖励。</li></ul><h3 id="为什么ETH会存在质押的模式"><a href="#为什么ETH会存在质押的模式" class="headerlink" title="为什么ETH会存在质押的模式?"></a>为什么ETH会存在质押的模式?</h3><p>质押是权益证明（Proof of Stake, PoS）及其变种共识机制的核心概念.下面是我在网络上看到的有关文章的部分节选,完整版请参照</p><blockquote><p>[<strong>白话区块链</strong>]    <a href="https://www.hellobtc.com/kp/du/09/4703.html">https://www.hellobtc.com/kp/du/09/4703.html</a> 质押现状：以太坊合并一年后的 5 大看点</p><p>ps: 我觉得这个频道用来扫盲挺好的,不过不要仅仅局限于一篇文章</p></blockquote><img src="file://C:/Users/32423/AppData/Roaming/Typora/typora-user-images/image-20240605184045270.png?lastModify=1717592035?lastModify=1717592086" alt="image-20240605184045270" style="zoom:25%;"><h2 id="再质押"><a href="#再质押" class="headerlink" title="再质押"></a>再质押</h2><blockquote><p>「再质押」是一个将流动性质押代币资产用于在其他区块链的验证者进行质押，以获得更多收益，同时有助于提高新网络的安全性和去中心化的行为。也可理解为再质押是加密经济安全中的一个新概念，它使以太坊既定的经济信任能够扩展到保护其他分布式系统，例如预言机、桥接器或侧链。      其使用从质押获得的奖励继续向该节点存款，以增加未来的利润。通过再质押，投资者可以从原始协议和再质押协议两方面获得多重收益。</p></blockquote><h3 id="再质押的实现方式"><a href="#再质押的实现方式" class="headerlink" title="再质押的实现方式"></a>再质押的实现方式</h3><p><strong>再质押主要是基于以太坊的安全框架来提升整个加密货币生态系统中的资金使用效率；质押者在能够支持一个网络安全性的同时还能够为多个网络提供验证服务，从而获得额外的奖励。</strong></p><ol><li><strong>衍生代币（Derivative Tokens）</strong>：<ul><li>当用户在某个平台上质押其资产后，平台可以为用户生成一种代表这些质押资产的衍生代币。</li><li>例如，用户在平台A上质押ETH，平台A会给用户发放一种代币，如stETH，代表用户在平台A上质押的ETH。</li><li>用户可以拿这些衍生代币（如stETH）去另一个平台B上进行再质押或参与其他DeFi活动。</li></ul></li><li><strong>合约层的再质押</strong>：<ul><li>一些区块链协议或智能合约平台允许直接将已经质押的资产再质押。</li><li>例如，通过跨链桥或跨协议的智能合约，用户可以将质押的资产从一个网络转移并质押到另一个网络。</li></ul></li><li><strong>流动性质押（Liquid Staking）</strong>：<ul><li>这种方式允许用户在质押其资产的同时，获取一种具有流动性的代币，这种代币可以在其他平台上进行交易或再质押。</li><li>流动性质押代币通常可以在市场上自由交易，使用户即使在质押期间，也能有一定的流动性来参与其他投资活动。</li></ul></li></ol><h3 id="再质押的风险"><a href="#再质押的风险" class="headerlink" title="再质押的风险"></a>再质押的风险</h3><ol><li><p><strong>智能合约风险</strong>：</p><ul><li>再质押涉及多个智能合约，每个智能合约都有可能存在漏洞或被攻击的风险。</li></ul></li><li><p><strong>流动性风险</strong>：</p><ul><li>衍生代币或流动性质押代币的市场流动性可能不足，导致在需要变现时价格波动较大。</li></ul></li><li><p><strong>复杂性风险</strong>：</p><ul><li>再质押增加了操作的复杂性，用户需要了解和管理多个平台和代币，可能会遇到操作失误或平台不兼容的问题。</li></ul></li></ol><h3 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h3><h4 id="1-提高收益率"><a href="#1-提高收益率" class="headerlink" title="1. 提高收益率"></a>1. <strong>提高收益率</strong></h4><h5 id="流动性质押（Liquid-Staking）"><a href="#流动性质押（Liquid-Staking）" class="headerlink" title="流动性质押（Liquid Staking）"></a>流动性质押（Liquid Staking）</h5><ul><li><strong>场景</strong>：用户质押ETH在Lido上，获得stETH。</li><li><strong>运用</strong>：用户可以将stETH再质押在其他DeFi协议中，如Aave或Compound，获取借贷利息或参与流动性挖矿，进一步提高收益率。</li></ul><h5 id="跨平台收益最大化"><a href="#跨平台收益最大化" class="headerlink" title="跨平台收益最大化"></a>跨平台收益最大化</h5><ul><li><strong>场景</strong>：用户质押资产在某个平台上获得收益，但发现另一个平台提供更高的收益率。</li><li><strong>运用</strong>：用户将质押资产转化为衍生代币后，转移到收益更高的平台进行再质押。</li></ul><h4 id="2-流动性增强"><a href="#2-流动性增强" class="headerlink" title="2. 流动性增强"></a>2. <strong>流动性增强</strong></h4><h5 id="跨链流动性提供"><a href="#跨链流动性提供" class="headerlink" title="跨链流动性提供"></a>跨链流动性提供</h5><ul><li><strong>场景</strong>：用户在以太坊上质押ETH，获得衍生代币。</li><li><strong>运用</strong>：用户将衍生代币通过跨链桥转移到其他区块链（如Polkadot或Binance Smart Chain），并在这些链上参与流动性池或借贷平台，提供流动性。</li></ul><h5 id="去中心化交易所（DEX）流动性挖矿"><a href="#去中心化交易所（DEX）流动性挖矿" class="headerlink" title="去中心化交易所（DEX）流动性挖矿"></a>去中心化交易所（DEX）流动性挖矿</h5><ul><li><strong>场景</strong>：用户质押资产获得流动性质押代币。</li><li><strong>运用</strong>：用户将这些流动性质押代币提供给去中心化交易所的流动性池，获得流动性挖矿奖励，同时保持资产流动性。</li></ul><h4 id="3-多重收益"><a href="#3-多重收益" class="headerlink" title="3. 多重收益"></a>3. <strong>多重收益</strong></h4><h5 id="合成资产生成"><a href="#合成资产生成" class="headerlink" title="合成资产生成"></a>合成资产生成</h5><ul><li><strong>场景</strong>：用户在某平台质押资产，获得衍生代币。</li><li><strong>运用</strong>：用户使用这些衍生代币在合成资产平台（如Synthetix）上生成合成资产（如sUSD或sBTC），再将合成资产用于交易或借贷，获得多重收益。</li></ul><h5 id="DeFi生态系统参与"><a href="#DeFi生态系统参与" class="headerlink" title="DeFi生态系统参与"></a>DeFi生态系统参与</h5><ul><li><p><strong>场景</strong>：用户质押ETH在Lido上，获得stETH。</p></li><li><p><strong>运用</strong>：用户使用stETH在Curve、Yearn等平台参与流动性挖矿、收益聚合等活动，获得平台奖励和交易费。</p></li></ul><h4 id="4-风险对冲"><a href="#4-风险对冲" class="headerlink" title="4. 风险对冲"></a>4. <strong>风险对冲</strong></h4><h5 id="衍生品交易"><a href="#衍生品交易" class="headerlink" title="衍生品交易"></a>衍生品交易</h5><ul><li><strong>场景</strong>：用户质押资产获得流动性质押代币。</li><li><strong>运用</strong>：用户使用这些代币在衍生品平台（如dYdX或Perpetual Protocol）进行杠杆交易或期权交易，对冲价格波动风险。</li></ul><h5 id="稳定币生成"><a href="#稳定币生成" class="headerlink" title="稳定币生成"></a>稳定币生成</h5><ul><li><p><strong>场景</strong>：用户质押ETH获得stETH。</p></li><li><p><strong>运用</strong>：用户在MakerDAO等稳定币生成平台上将stETH作为抵押品，生成DAI等稳定币，用于其他DeFi操作或风险对冲。</p></li></ul><h4 id="5-去中心化自治组织（DAO）治理"><a href="#5-去中心化自治组织（DAO）治理" class="headerlink" title="5. 去中心化自治组织（DAO）治理"></a>5. <strong>去中心化自治组织（DAO）治理</strong></h4><h5 id="提高投票权重"><a href="#提高投票权重" class="headerlink" title="提高投票权重"></a>提高投票权重</h5><ul><li><strong>场景</strong>：用户质押资产获得治理代币。</li><li><strong>运用</strong>：用户将治理代币再质押在治理平台上，提高在去中心化自治组织中的投票权重，影响平台决策。</li></ul><h5 id="提案创建和支持"><a href="#提案创建和支持" class="headerlink" title="提案创建和支持"></a>提案创建和支持</h5><ul><li><strong>场景</strong>：用户质押资产参与某DAO获得治理代币。</li><li><strong>运用</strong>：用户将治理代币再质押以创建或支持新的提案，提高提案通过的几率，积极参与治理。</li></ul><h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><p>通俗来说流动性质押代币（<strong>LST</strong>）代表质押 ETH 和累积奖励的代币化版本，流动性再质押代币（<strong>LRT</strong>）代表再质押 ETH 和累积奖励的代币化版本。相关项目 我之前整理过一篇  <a href="https://404ll.github.io/2024/05/10/AVS%E4%BB%A5%E5%8F%8AEigenLayer%E8%A7%A3%E6%9E%90/">Eigenlayer</a>的文章，有兴趣可以看看</p><p>具体深入了解,可以参考这篇(文章中还涉及了 质押与再质押的原理区别)</p><p> 📌<a href="https://foresightnews.pro/article/detail/55642">一文读懂「再质押 Restaking 」赛道</a></p><h2 id="比较好的信息网站"><a href="#比较好的信息网站" class="headerlink" title="比较好的信息网站"></a>比较好的信息网站</h2><p>📌<a href="https://foresightnews.pro/">foresight news</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫盲小知识之 Roll-up</title>
      <link href="/2024/05/21/qu-kuai-lian/roll-up/"/>
      <url>/2024/05/21/qu-kuai-lian/roll-up/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-Roll-up"><a href="#什么是-Roll-up" class="headerlink" title="什么是 Roll-up ?"></a>什么是 Roll-up ?</h1><blockquote><p>Roll-up是一种Layer 2扩展解决方案，旨在提高以太坊网络的吞吐量和效率。<strong>它通过将大量的交易数据压缩成少量的摘要信息，然后将这些摘要信息提交到以太坊主链上，以实现高性能的链上交易处理。</strong></p><p><strong>人话就是</strong> :  把以太坊上几百笔交易打包带走，并在验证通过后只向以太坊主网输出一笔交易。</p></blockquote><p> 具体可以看看这篇文章：<a href="https://foresightnews.pro/article/h5Detail/59078">https://foresightnews.pro/article/h5Detail/59078</a></p><p>Roll-up通常分为这几种类型：</p><ol><li><p><strong>Optimistic Roll-up（乐观 Roll-up）</strong>:  默认打包的这些交易每一笔都是准确无误的，因此会直接进入验证。但为了防止错误交易混入其中，乐观证明引入了挑战者机制，就是说在验证的一定期限内，其他人可以怀疑其中的交易并在以太坊上比对这笔交易是否合法。如果挑战成功，挑战者就可以获得收益，验证者就会被罚没质押在协议上的资金。</p></li><li><p><strong>ZK-Rollup（零知识 Roll-up）</strong></p><p>​     在ZK-Rollup中，交易的验证过程使用了零知识证明技术，可以在不暴露具体交易内容的情况下证明交易的有效性。这样可以进一步减少在主链上的数据量，并提高隐私性和效率.</p></li></ol><p>Roll-up技术的引入为以太坊网络提供了一种高效的扩展方案，可以大幅提升网络的吞吐量和性能，同时降低交易成本，并为更多的去中心化应用提供了支持。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫盲小知识之 L1 L2</title>
      <link href="/2024/05/21/qu-kuai-lian/shi-me-shi-layer1-layer2/"/>
      <url>/2024/05/21/qu-kuai-lian/shi-me-shi-layer1-layer2/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-Layer1-Layer2"><a href="#什么是-Layer1-Layer2" class="headerlink" title="什么是 Layer1  Layer2?"></a>什么是 Layer1  Layer2?</h1><p>Layer1是区块链的基础层，负责确认和记录交易；Layer2是用于扩容的解决方案，负责处理和记录高吞吐量的交易。</p><h2 id="什么是-Layer1"><a href="#什么是-Layer1" class="headerlink" title="什么是 Layer1?"></a>什么是 Layer1?</h2><p>第一层就是传统意义上的区块链，包括：比特币，以太坊，Aptos等</p><p>Layer1是区块链技术中的一个术语，指的是区块链协议中的基础层。它是指构成区块链网络基础架构的核心协议和数据结构，通常是一种完整的、独立的区块链网络，具有自己的共识机制和数据存储方式。Layer1协议负责处理交易验证、区块生成和链上数据存储等核心功能。</p><p>在Layer1层面，通常会涉及到底层的区块链技术和算法设计，如工作量证明（Proof of Work）或权益证明（Proof of Stake）等共识机制，以及区块链的数据结构、加密算法等。Layer1协议的设计决定了整个区块链网络的性能、安全性和去中心化程度。</p><h2 id="什么是-Layer2"><a href="#什么是-Layer2" class="headerlink" title="什么是 Layer2?"></a>什么是 Layer2?</h2><blockquote><p>本文只提供粗浅的定义，若想进一步了解，可以看看<a href="https://blog.chain.link/what-is-a-layer-2-zh/">一文读懂第 2 层</a> 🌟</p></blockquote><p>Layer 2的目的是通过在区块链之上引入额外的协议或机制，提供更高的吞吐量、低延迟和更便宜的交易，并解决Layer 1网络可能存在的扩展性和性能问题。</p><p>Layer 2解决方案通常可以分为两种主要类型：</p><ol><li><strong>状态通道（State Channels）</strong>：状态通道是一种通过在链外执行交易并最终将交易结果提交到区块链上的解决方案。在状态通道中，参与者可以直接在彼此之间进行多次交易，而不必在每次交易都提交到区块链上进行确认，从而大大提高了交易的速度和吞吐量。</li><li><strong>侧链（Sidechains）</strong>：侧链是与主区块链相互连接的独立区块链，可以处理与主链不同的交易逻辑和数据。通过侧链，用户可以将资产从主链转移到侧链上进行高速和低成本的交易，然后再将结果汇总提交到主链上，从而减轻了主链的负担，提高了整个系统的性能。</li></ol><p>有关扩容方案的文章 </p><p>[]: <a href="https://mp.weixin.qq.com/s?__biz=MzUyNzE4MDM2MA==&amp;mid=2247500009&amp;idx=2&amp;sn=aa68710cd3eb1758dff8776bbc1be70e&amp;chksm=fa01f7cecd767ed86a724a284233cca3cc0aec84d0a99ef126392305dd20f5c99976d37e6d27#rd">https://mp.weixin.qq.com/s?__biz=MzUyNzE4MDM2MA==&amp;mid=2247500009&amp;idx=2&amp;sn=aa68710cd3eb1758dff8776bbc1be70e&amp;chksm=fa01f7cecd767ed86a724a284233cca3cc0aec84d0a99ef126392305dd20f5c99976d37e6d27#rd</a>“一文看懂区块链的扩容方案和主要的二层网络（Layer 2）方案”</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML表单</title>
      <link href="/2024/04/25/qian-duan/html-biao-dan/"/>
      <url>/2024/04/25/qian-duan/html-biao-dan/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>表单（Form）是 HTML 中用于收集用户输入信息并将其提交到服务器的一种机制。它通常由包含表单元素的一组 HTML 元素组成，用户可以在表单中输入数据并通过提交按钮将数据发送到服务器进行处理=&gt;</p><p>我的理解: 就是C语言中的scanf()和getchar(),用来读取用户的输入 </p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><code>&lt;form&gt;</code> 元素用于创建表单，<code>action</code> 属性定义了表单数据提交的目标 URL，<code>method</code> 属性定义了提交数据的 HTTP 方法（这里使用的是 “post”）</p><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p><code>method</code> 属性用于定义 HTML 表单提交数据时所使用的 HTTP 方法。在 Web 开发中，常见的 HTTP 方法有两种：GET 和 POST。</p><ol><li><strong>GET 方法</strong>：</li></ol><ul><li>当使用 GET 方法提交表单时，表单数据会附加在 URL 的末尾，并作为查询字符串的一部分发送到服务器。</li><li>GET 方法通常用于请求资源，比如请求页面、提交搜索查询等。</li><li>使用 GET 方法提交的表单数据会在 URL 中可见，因此不适合传输敏感信息，且有长度限制。</li></ul><ol start="2"><li><strong>POST 方法</strong>：</li></ol><ul><li>当使用 POST 方法提交表单时，表单数据会作为 HTTP 请求的正文发送到服务器。</li><li>POST 方法通常用于向服务器提交较大量或敏感信息的数据，比如用户注册信息、登录凭证等。</li><li>使用 POST 方法提交的表单数据不会在 URL 中可见，因此更安全，并且没有长度限制。</li></ul><p>在 HTML 表单中，通过设置 <code>method</code> 属性为 “post”，表示表单数据将使用 POST 方法提交给服务器。这意味着用户填写的数据会作为 HTTP 请求的正文发送到服务器，而不会出现在 URL 中，从而保护了用户数据的隐私和安全性。</p><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>表单的动作属性 <strong>action</strong> 定义了服务端的文件名。</p><p><strong>action</strong> 属性会对接收到的用户输入数据进行相关的处理</p><p>例如 action=”html_form_action.php”，输入数据会传送到 <strong>html_form_action.php</strong> 文件，该页面将显示出输入的结果。</p><h3 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h3><p>文本域通过<code> &lt;input type="text"&gt;</code>标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域</p><h2 id="代码罗列"><a href="#代码罗列" class="headerlink" title="代码罗列"></a>代码罗列</h2><p><code>required</code>表示必填</p><p><code>label</code> 为了增强可读性</p><p><code>checked</code> 表示默认选中=&gt;进入就能看到的</p><p><code>value</code> 属性指定了用户输入的默认值或者在提交表单时发送到服务器的值。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>表单<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文本输入框 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!-- 密码输入框 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"password"</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!-- 单选按钮 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>性别:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"male"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"male"</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"male"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"female"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"female"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"female"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!-- 复选框  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"subscribe"</span> <span class="attr">name</span>=<span class="string">"subscribe"</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"subscribe"</span>&gt;</span>订阅推送信息<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!-- 下拉列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"country"</span>&gt;</span>国家:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"country"</span> <span class="attr">name</span>=<span class="string">"country"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"cn"</span>&gt;</span>CN<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"usa"</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"uk"</span>&gt;</span>UK<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>删去lable版本</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 省略了&lt;label&gt;元素 --&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">placeholder</span>=<span class="string">"请输入用户名"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 省略了&lt;label&gt;元素 --&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"请输入密码"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 省略了&lt;label&gt;元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript学习随笔</title>
      <link href="/2024/04/25/qian-duan/javascript-xue-xi-sui-bi/"/>
      <url>/2024/04/25/qian-duan/javascript-xue-xi-sui-bi/</url>
      
        <content type="html"><![CDATA[<h1 id="Javascript-学习随笔"><a href="#Javascript-学习随笔" class="headerlink" title="Javascript 学习随笔"></a>Javascript 学习随笔</h1><blockquote><p>学习网站是：<a href="https://www.runoob.com/">https://www.runoob.com/</a><br>因为在这之前我只系统学习了C,因此在学习Javascript的过程中主要采用了比较的方法.</p></blockquote><h2 id="代码小问题"><a href="#代码小问题" class="headerlink" title="代码小问题"></a>代码小问题</h2><h3 id="为什么使用“-”？"><a href="#为什么使用“-”？" class="headerlink" title="为什么使用“+”？"></a>为什么使用“+”？</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"demo"</span>).<span class="property">innerHTML</span> =</span><br><span class="line">            <span class="keyword">typeof</span> <span class="literal">false</span> + <span class="string">"&lt;br&gt;"</span> +</span><br><span class="line">            <span class="keyword">typeof</span> <span class="number">0</span> + <span class="string">"&lt;br&gt;"</span> +</span><br><span class="line">            <span class="keyword">typeof</span> <span class="string">""</span> + <span class="string">"&lt;br&gt;"</span> +</span><br><span class="line">            <span class="keyword">typeof</span> <span class="string">"hello"</span> + <span class="string">"&lt;br&gt;"</span> +</span><br><span class="line">            <span class="keyword">typeof</span> <span class="literal">null</span> + <span class="string">"&lt;br&gt;"</span> +</span><br><span class="line">            <span class="keyword">typeof</span> <span class="literal">undefined</span> + <span class="string">"&lt;br&gt;"</span> +</span><br><span class="line">            <span class="keyword">typeof</span> {} + <span class="string">"&lt;br&gt;"</span> +</span><br><span class="line">            <span class="keyword">typeof</span> [] + <span class="string">"&lt;br&gt;"</span> +</span><br><span class="line">            <span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>) {} + <span class="string">"&lt;br&gt;"</span> +</span><br><span class="line">            <span class="keyword">typeof</span> <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br></pre></td></tr></tbody></table></figure><p>在 JavaScript 中，<code>+</code> 运算符用于连接字符串。在这段代码中，<code>"&lt;br&gt;"</code> 是一个字符串，通过使用 <code>+</code> 运算符，我们将各种数据类型的类型输出连接成一个长字符串，然后将这个字符串设置为 <code>&lt;p&gt;</code> 元素的 <code>innerHTML</code>。这样可以确保每种数据类型的类型都输出到段落中，而不会覆盖之前的输出。</p><p>如果我们不使用 <code>+</code> 运算符，而是使用多个 <code>document.getElementById("demo").innerHTML</code> 进行赋值，只有最后一个赋值会生效，因为每次赋值都会覆盖之前的内容。通过使用 <code>+</code> 运算符，我们将每种类型的类型连接成一个字符串，然后一次性将整个字符串赋值给 <code>&lt;p&gt;</code> 元素的 <code>innerHTML</code>，这样就可以将所有类型都输出到段落中</p><h2 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">let</span> emptyArray = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指定长度的空数组</span></span><br><span class="line"><span class="keyword">let</span> arrayWithLength = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建包含元素的数组</span></span><br><span class="line"><span class="keyword">let</span> fruits = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'orange'</span>);</span><br><span class="line"><span class="comment">//直接</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></tbody></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript 中的对象是一种复合数据类型，用于存储多个<strong>键值对</strong> <em>在这里被称为<strong>对象属性</strong></em>。对象可以包含各种类型的数据，包括其他对象、数组、函数等</p><blockquote><p>关于键值对：我简单理解为名字和值一一对应的一种数据结构</p></blockquote><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p>就是属性值为函数</p><p><strong>特殊属性和方法</strong>：</p><ul><li><p><strong>原型（Prototype）</strong>：每个对象都有一个原型，它是一个指向另一个对象的引用，可以用于实现继承。</p></li><li><p><strong>构造函数（Constructor）</strong>：用于创建对象的函数。</p></li><li><p><strong>内置属性和方法</strong>：例如 <code>toString()</code>、<code>valueOf()</code> 等，这些方法和属性是 JavaScript 内置对象的一部分，可以直接使用</p></li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>因为C中没有这个概念，所以这里着重写一下</p><blockquote><p>在 JavaScript 中，事件是指在 HTML 文档中发生的某些事情或动作，比如用户的交互操作（例如点击、鼠标移动、键盘输入等）或者浏览器自身的操作（例如页面加载完成、窗口大小改变等）。</p><p>HTML文档:我单纯理解为这个页面中包含的所有东西</p></blockquote><p><strong>事件可以分为两类：内置事件和用户自定义事件。</strong></p><ol><li><h3 id="内置事件："><a href="#内置事件：" class="headerlink" title="内置事件："></a><strong>内置事件</strong>：</h3><ul><li><p>内置事件是浏览器或者特定 HTML 元素自身触发的事件，比如：</p><ul><li><p>页面加载完成事件 (<code>load</code>)</p></li><li><p>鼠标点击事件 (<code>click</code>)</p></li><li><p>鼠标移动事件 (<code>mousemove</code>)</p></li><li><p>键盘按键事件 (<code>keydown</code>, <code>keyup</code>, <code>keypress</code>)</p></li><li><p>表单提交事件 (<code>submit</code>)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;Event Examples&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Click Event Example --&gt;</span><br><span class="line">&lt;button onclick="alert('按钮被点击了！')"&gt;点击我&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Mousemove Event Example --&gt;</span><br><span class="line">&lt;div style="width: 100px; height: 100px; background-color: red;" onmousemove="alert('鼠标移动到了盒子上！')"&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Key Event Example --&gt;</span><br><span class="line">&lt;input type="text" </span><br><span class="line">       placeholder="按下按键或者松开按键" </span><br><span class="line">       onkeydown="alert('按键按下了！')" </span><br><span class="line">       onkeyup="alert('按键松开了！')" </span><br><span class="line">       onkeypress="alert('按键被按下并松开了！')"&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Load Event Example --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function pageLoaded() {</span><br><span class="line">        alert('页面加载完成！');</span><br><span class="line">    }</span><br><span class="line">    window.onload = pageLoaded;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li><li><h3 id="用户自定义事件："><a href="#用户自定义事件：" class="headerlink" title="用户自定义事件："></a><strong>用户自定义事件</strong>：</h3><ul><li>除了内置事件之外，开发者还可以自定义事件，以便在特定情况下触发 JavaScript 代码执行。这种自定义事件通常是通过 <code>Event</code> 对象的构造函数来创建，并且可以通过 <code>dispatchEvent()</code> 方法手动触发。</li></ul></li></ol><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p><code>===</code>:绝对相等=&gt;值类型都相等</p><p><code>!==</code>:不绝对相等</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>大体相同,还有一种比较特别的for循环</p><p><code>itCompanies</code> 是一个数组，<code>for...of</code> 循环用来遍历数组中的元素。<code>company</code> 是循环中的一个临时变量，每次迭代时，它会被赋值为数组中的一个元素。所以你的解释几乎正确，但是应该是将 <code>company</code> 赋值为 <code>itCompanies</code> 数组中的每个元素，而不是整个数组本身。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> itCompanies = [<span class="string">"Facebook"</span>, <span class="string">"Google"</span>, <span class="string">"Microsoft"</span>, <span class="string">"Apple"</span>, <span class="string">"IBM"</span>, <span class="string">"Oracle"</span>, <span class="string">"Amazon"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> company <span class="keyword">of</span> itCompanies) {<span class="comment">//让company赋值为itCompanies中的一个元素</span></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> company) {</span><br><span class="line">    <span class="keyword">if</span> (char.<span class="title function_">toLowerCase</span>() === <span class="string">"o"</span>) {</span><br><span class="line">      count++;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">1</span>) {</span><br><span class="line">    companiesWithMoreThanOneO.<span class="title function_">push</span>(company);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Companies with more than one 'o':"</span>, companiesWithMoreThanOneO);</span><br></pre></td></tr></tbody></table></figure><h2 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h2><p><strong>constructor</strong> 属性返回所有 JavaScript 变量的构造函数。</p><h2 id="Data-方法"><a href="#Data-方法" class="headerlink" title="Data()方法"></a>Data()方法</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getDate()</td><td align="left">从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td></tr><tr><td align="left">getDay()</td><td align="left">从 Date 对象返回一周中的某一天 (0 ~ 6)。</td></tr><tr><td align="left">getFullYear()</td><td align="left">从 Date 对象以四位数字返回年份。</td></tr><tr><td align="left">getHours()</td><td align="left">返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td align="left">getMilliseconds()</td><td align="left">返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td align="left">getMinutes()</td><td align="left">返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td align="left">getMonth()</td><td align="left">从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td align="left">getSeconds()</td><td align="left">返回 Date 对象的秒数 (0 ~ 59)。</td></tr><tr><td align="left">getTime()</td><td align="left">返回 1970 年 1 月 1 日至今的毫秒数。</td></tr></tbody></table><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>/正则表达式主体/修饰符(可选)</p><h3 id="使用字符串方法"><a href="#使用字符串方法" class="headerlink" title="使用字符串方法"></a>使用字符串方法</h3><p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p><p><strong>search()</strong> 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</p><p><strong>replace()</strong> 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。</p><p><strong>exec()</strong> 方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p><h3 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h3><p><strong>修饰符</strong> 可以在全局搜索中不区分大小写:</p><table><thead><tr><th align="left">修饰符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">执行对大小写不敏感的匹配。</td></tr><tr><td align="left">g</td><td align="left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td align="left">m</td><td align="left">执行多行匹配。</td></tr></tbody></table><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h4 id="try-catch-throw"><a href="#try-catch-throw" class="headerlink" title="try  catch  throw"></a><strong>try  catch  throw</strong></h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> message, x;</span><br><span class="line">  message = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"p01"</span>);</span><br><span class="line">  message.<span class="property">innerHTML</span> = <span class="string">""</span>;</span><br><span class="line">  x = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"demo"</span>).<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">try</span> { </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">""</span>) <span class="keyword">throw</span> <span class="string">"值是空的"</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isNaN</span>(x)) <span class="keyword">throw</span> <span class="string">"值不是一个数字"</span>;</span><br><span class="line">    x = <span class="title class_">Number</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">10</span>) <span class="keyword">throw</span> <span class="string">"太大"</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">5</span>) <span class="keyword">throw</span> <span class="string">"太小"</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">catch</span>(err) {</span><br><span class="line">    message.<span class="property">innerHTML</span> = <span class="string">"错误: "</span> + err + <span class="string">"."</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">finally</span> {</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"demo"</span>).<span class="property">value</span> = <span class="string">""</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="debugger-关键字"><a href="#debugger-关键字" class="headerlink" title="debugger 关键字"></a>debugger 关键字</h3><p><strong>debugger</strong> 关键字用于停止执行 JavaScript，并调用调试函数。</p><p>这个关键字与在调试工具中设置断点的效果是一样的。</p><p>可以先使用再声明</p><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>JavaScript 中的所有数据都是以 64 位<strong>浮点型数据(float)</strong> 来存储</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">let</span> z = x + y            <span class="comment">// z 的结果为 0.30000000000000004</span></span><br><span class="line"><span class="keyword">if</span> (z == <span class="number">0.3</span>)  </span><br></pre></td></tr></tbody></table></figure><p>=&gt;用乘除法解决问题</p><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p>由于与HTML的表单有关联,因此在这里先简单回顾一下HTML表单</p><p>具体可以参考另一篇笔记<a href="https://404ll.github.io/2024/04/25/%E5%89%8D%E7%AB%AF/HTML%E8%A1%A8%E5%8D%95/">HTML表单</a></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>表单验证可以包括以下内容：</p><ol><li><strong>必填字段验证</strong>：确保用户填写了表单中标记为必填的字段，防止用户提交空值或默认值。</li><li><strong>格式验证</strong>：检查用户输入的数据格式是否正确，例如邮箱地址、电话号码、日期等。</li><li><strong>长度验证</strong>：检查用户输入的数据长度是否符合要求，如最小长度、最大长度等。</li><li><strong>数据类型验证</strong>：确保用户输入的数据类型正确，如数字、字母、日期等。</li><li><strong>范围验证</strong>：检查数值型数据是否在指定的范围内，如年龄、价格等。</li><li><strong>正则表达式验证</strong>：使用正则表达式对用户输入的数据进行更灵活的验证，可以实现复杂的格式匹配。</li></ol><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="variable language_">document</span>.<span class="property">forms</span>[<span class="string">"myForm"</span>][<span class="string">"fname"</span>].<span class="property">value</span>;</span><br></pre></td></tr></tbody></table></figure><p>用于获取 HTML 表单中名为 “myForm” 的表单中名为 “fname” 的输入字段的值，并将其存储在变量 x 中。</p><h2 id="验证API"><a href="#验证API" class="headerlink" title="验证API"></a>验证API</h2><h3 id="验证验证和表单验证的区别"><a href="#验证验证和表单验证的区别" class="headerlink" title="验证验证和表单验证的区别"></a>验证验证和表单验证的区别</h3><ol><li><strong>JavaScript 验证 API</strong>：<ul><li>JavaScript 验证 API 是 JavaScript 提供的一组 API 和方法，用于编写自定义的验证逻辑。</li><li>开发人员可以使用 JavaScript 验证 API 编写自己的验证函数，以根据特定的需求对用户输入进行验证。</li><li>这种方式更加灵活，可以实现各种复杂的验证逻辑，但需要编写更多的代码。</li></ul></li><li><strong>表单验证</strong>：<ul><li>表单验证是 HTML 表单元素自带的一种验证机制，可以通过设置一些属性来定义验证规则。</li><li>HTML5 提供了一些内置的表单验证属性，如 <code>required</code>, <code>min</code>, <code>max</code>, <code>pattern</code> 等，可以直接在 HTML 中使用。</li><li>表单验证相对简单，适用于一些基本的验证需求，如必填字段、最小长度、最大长度、正则表达式验证等</li></ul></li></ol><h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><p>我理解的This 表示对<strong>上一级对象</strong>的引用：</p><ul><li><p>方法体内表示对该方法所属的属性的引用</p></li><li><p>单独使用，就是全局对象</p></li><li><p>在函数中，函数的所属者绑定默认到this上（这里和后面学习智能合约有关联）</p></li><li><p>在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素。</p></li></ul><blockquote><p>方法是与对象相关联的函数</p></blockquote><p>在学习教程中看到了一篇笔记，可以帮助理解：</p><blockquote><p>简单理解，this指向的是该this所在的最里层的object对象。</p><p>1、函数不是object对象，所以没有写在object对象里的函数调用this会指向window</p><p>2、构造函数是object对象，所以在构造函数中调用this会指向该构造函数</p><p>3、html元素是object元素，所以在html元素中调用this会指向该元素</p><p>4、函数1 return 函数2，函数2 return this，该this会指向window</p><p>例：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = {</span><br><span class="line">   <span class="attr">fun1</span>:<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">           <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">       }</span><br><span class="line">   },</span><br><span class="line">&gt;};</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">fun1</span>()()); <span class="comment">//window</span></span><br></pre></td></tr></tbody></table></figure></blockquote><h1 id="javascript-void-0-含义"><a href="#javascript-void-0-含义" class="headerlink" title="javascript:void(0) 含义"></a>javascript:void(0) 含义</h1><p>void 在C语言中也有涉及，表示没有返回值。</p><p>在<strong>javascript:void(0)</strong> 中最关键的是 <strong>void</strong> 关键字， <strong>void</strong> 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值</p><h3 id="href-”-”与href-”javascript-void-0-”的区别"><a href="#href-”-”与href-”javascript-void-0-”的区别" class="headerlink" title="href=”#”与href=”javascript:void(0)”的区别"></a>href=”#”与href=”javascript:void(0)”的区别</h3><ol><li>**href=”#”**：<ul><li>这个用法将页面的滚动位置移动到页面顶部。当用户点击链接时，浏览器会尝试滚动到页面中 ID 为 “#” 的元素，而在大多数情况下这个元素并不存在，因此页面会回到顶部。</li><li>使用 <code>href="#"</code> 会触发页面滚动，有时可能会导致页面跳跃，尤其是在单页应用或具有滚动效果的页面中。</li></ul></li><li>**href=”javascript:void(0)”**：<ul><li>这个用法是执行一个 JavaScript 表达式 <code>void(0)</code>，它会返回 undefined，但不会导致页面跳转或滚动。</li><li>使用 <code>href="javascript:void(0)"</code> 不会触发页面滚动，因此不会导致页面跳跃</li></ul></li></ol><h2 id="promise和异步编程"><a href="#promise和异步编程" class="headerlink" title="promise和异步编程"></a>promise和异步编程</h2><p>**异步编程 ** 通俗来讲就是，不按照顺序执行</p><blockquote><p>Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）、rejected（已失败</p></blockquote><p><strong>Promise 构造函数</strong>返回一个 Promise 对象，该对象具有以下几个方法：</p><ul><li>then：用于处理 Promise 成功状态的回调函数。</li><li>catch：用于处理 Promise 失败状态的回调函数。</li><li>finally：无论 Promise 是成功还是失败，都会执行的回调函数。</li></ul><p>感觉大部分学习基于代码会比较清楚：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2222</span>);</span><br><span class="line">}).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3333</span>;</span><br><span class="line">}).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"An error"</span>;</span><br><span class="line">}).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>在 JavaScript 中, 函数是对象。JavaScript 函数有它的属性和方法。</p><p><strong>call()</strong> 和 <strong>apply()</strong> 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身</p><h3 id="call-与apply-的不同"><a href="#call-与apply-的不同" class="headerlink" title="call()与apply()的不同"></a>call()与apply()的不同</h3><p>apply()的第二个参数是数组，call()是作为参数（从第二个起）单独传入。</p><h2 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h2><p>有关javascript的初步学习就到这里了，后面主要通过一些比较小的项目来进一步理解和深化学习！</p><p>进阶的补充会继续更新博客，请期待一下！</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
