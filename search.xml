<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML表单</title>
    <url>/2024/04/25/%E5%89%8D%E7%AB%AF/HTML%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<h1 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>表单（Form）是 HTML 中用于收集用户输入信息并将其提交到服务器的一种机制。它通常由包含表单元素的一组 HTML 元素组成，用户可以在表单中输入数据并通过提交按钮将数据发送到服务器进行处理&#x3D;&gt;</p>
<p>我的理解: 就是C语言中的scanf()和getchar(),用来读取用户的输入 </p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><code>&lt;form&gt;</code> 元素用于创建表单，<code>action</code> 属性定义了表单数据提交的目标 URL，<code>method</code> 属性定义了提交数据的 HTTP 方法（这里使用的是 “post”）</p>
<h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p><code>method</code> 属性用于定义 HTML 表单提交数据时所使用的 HTTP 方法。在 Web 开发中，常见的 HTTP 方法有两种：GET 和 POST。</p>
<ol>
<li><strong>GET 方法</strong>：</li>
</ol>
<ul>
<li>当使用 GET 方法提交表单时，表单数据会附加在 URL 的末尾，并作为查询字符串的一部分发送到服务器。</li>
<li>GET 方法通常用于请求资源，比如请求页面、提交搜索查询等。</li>
<li>使用 GET 方法提交的表单数据会在 URL 中可见，因此不适合传输敏感信息，且有长度限制。</li>
</ul>
<ol start="2">
<li><strong>POST 方法</strong>：</li>
</ol>
<ul>
<li>当使用 POST 方法提交表单时，表单数据会作为 HTTP 请求的正文发送到服务器。</li>
<li>POST 方法通常用于向服务器提交较大量或敏感信息的数据，比如用户注册信息、登录凭证等。</li>
<li>使用 POST 方法提交的表单数据不会在 URL 中可见，因此更安全，并且没有长度限制。</li>
</ul>
<p>在 HTML 表单中，通过设置 <code>method</code> 属性为 “post”，表示表单数据将使用 POST 方法提交给服务器。这意味着用户填写的数据会作为 HTTP 请求的正文发送到服务器，而不会出现在 URL 中，从而保护了用户数据的隐私和安全性。</p>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>表单的动作属性 <strong>action</strong> 定义了服务端的文件名。</p>
<p><strong>action</strong> 属性会对接收到的用户输入数据进行相关的处理</p>
<p>例如 action&#x3D;”html_form_action.php”，输入数据会传送到 <strong>html_form_action.php</strong> 文件，该页面将显示出输入的结果。</p>
<h3 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h3><p>文本域通过<code> &lt;input type=&quot;text&quot;&gt;</code>标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域</p>
<h2 id="代码罗列"><a href="#代码罗列" class="headerlink" title="代码罗列"></a>代码罗列</h2><p><code>required</code>表示必填</p>
<p><code>label</code> 为了增强可读性</p>
<p><code>checked</code> 表示默认选中&#x3D;&gt;进入就能看到的</p>
<p><code>value</code> 属性指定了用户输入的默认值或者在提交表单时发送到服务器的值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>表单<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 文本输入框 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>用户名:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- 密码输入框 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>密码:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- 单选按钮 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>性别:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">checked</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- 复选框  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;subscribe&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;subscribe&quot;</span> <span class="hljs-attr">checked</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;subscribe&quot;</span>&gt;</span>订阅推送信息<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- 下拉列表 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span>国家:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cn&quot;</span>&gt;</span>CN<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;usa&quot;</span>&gt;</span>USA<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;uk&quot;</span>&gt;</span>UK<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <br>        <span class="hljs-comment">&lt;!-- 提交按钮 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>删去lable版本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 省略了&lt;label&gt;元素 --&gt;</span><br>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 省略了&lt;label&gt;元素 --&gt;</span><br>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入密码&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 省略了&lt;label&gt;元素 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登录&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>sui-move2</title>
    <url>/2024/09/30/sui-move%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%BF%9B%E9%98%B6%E7%89%88%EF%BC%89/sui-move%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%BF%9B%E9%98%B6%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="sui-move"><a href="#sui-move" class="headerlink" title="sui -move"></a>sui -move</h1><h2 id="Sui-PTB-（可编程交易模块）"><a href="#Sui-PTB-（可编程交易模块）" class="headerlink" title="Sui-PTB （可编程交易模块）"></a>Sui-PTB （可编程交易模块）</h2><p>官方文档地址：<a href="https://docs.sui.io/concepts/transactions/prog-txn-blocks">https://docs.sui.io/concepts/transactions/prog-txn-blocks</a></p>
<h3 id="PTB概述"><a href="#PTB概述" class="headerlink" title="PTB概述"></a>PTB概述</h3><p>PTB 全称 Programmable Transaction Block（可编程交易模块），在Sui上，交易不仅仅是资产流动的基本记录，交易由多个命令组成，这些命令在输入上执行，定义交易的结果。</p>
<p>PTB允许用户在单个交易中调用多个Move函数，管理其对象和管理其代币，而无需发布新的Move包，是生成交易的一种轻量灵活的方式，同时其执行组合的交易模式减少了gas fee 。</p>
<h3 id="PTB-的组成"><a href="#PTB-的组成" class="headerlink" title="PTB 的组成"></a>PTB 的组成</h3><p>每个PTB由单独的交易命令组成，这里的交易命令有：</p>
<ol>
<li><p><strong>TransferObjects</strong></p>
<ul>
<li>将一组对象转移到指定地址。</li>
</ul>
</li>
<li><p><strong>SplitCoins</strong></p>
<ul>
<li>将一个硬币拆分成多个硬币。</li>
</ul>
</li>
<li><p><strong>MakeMoveVec</strong></p>
<ul>
<li>构建一个 Move 类型的向量。</li>
</ul>
</li>
<li><p><strong>MoveCall</strong></p>
<ul>
<li>调用指定的 Move 函数。</li>
</ul>
</li>
<li><p><strong>Publish</strong></p>
<ul>
<li>发布指定的模块。</li>
</ul>
</li>
<li><p><strong>Upgrade</strong></p>
<ul>
<li>升级已有的模块或包。</li>
</ul>
</li>
</ol>
<p>每个交易命令按顺序执行，您可以在任何后续交易命令中使用前一个交易命令的结果。所有交易命令在一个块中的效果，特别是对象修改或转移，会在事务结束时以原子方式应用。如果一个交易命令失败，整个块都会失败，并且命令的任何效果都不会被应用</p>
<p>主要通过前端来整合并连续实施多个操作，即操作前端来实现交易的添加和合约的调用</p>
<h3 id="PTB的使用"><a href="#PTB的使用" class="headerlink" title="PTB的使用"></a>PTB的使用</h3><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//创建可编程事务块 (PTB)</span><br><span class="hljs-keyword">const</span> txb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transaction</span>();<br><span class="hljs-comment">//设置输入参数</span><br><span class="hljs-keyword">const</span> arg1 = txb.<span class="hljs-title function_">object</span>(objectId0);<br><span class="hljs-keyword">const</span> arg2 = txb.<span class="hljs-title function_">object</span>(objectId1);<br><span class="hljs-keyword">const</span> arg3 = txb.<span class="hljs-property">pure</span>.<span class="hljs-title function_">u8</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> arg4 = txb.<span class="hljs-property">pure</span>.<span class="hljs-title function_">bool</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">const</span> arg5 = txb.<span class="hljs-title function_">pure</span>(bcs.<span class="hljs-title function_">vector</span>(bcs.<span class="hljs-property">U64</span>).<span class="hljs-title function_">serialize</span>([<span class="hljs-number">123</span>, <span class="hljs-number">456</span>]));<br><br><span class="hljs-keyword">const</span> myCoin = txb.<span class="hljs-title function_">object</span>(myCoinId);<br> <span class="hljs-comment">//通过命令调用 Move 函数拿到输出的资产</span><br><span class="hljs-keyword">const</span> coinOut = txb.<span class="hljs-title function_">moveCall</span>(&#123;<br>  <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;$&#123;packageId&#125;::$&#123;moduleName&#125;::$&#123;funcName&#125;*&#x27;</span>,<br>  <span class="hljs-attr">typeArguments</span>: [type1, type2],<br>  <span class="hljs-attr">arguments</span>: [arg1, arg2, arg3, arg4, arg5]<br>&#125;);<br><span class="hljs-comment">// 拆分Coin为coinOut0和 coinOut1</span><br><span class="hljs-keyword">const</span> [coinOut0, coinOut1] = txb.<span class="hljs-title function_">splitCoins</span>(coinOut, [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>]);<br><span class="hljs-comment">// 将coin合并到自己的资产中</span><br>txb.<span class="hljs-title function_">mergeCoins</span>(myCoin, [coinOut]);<br><span class="hljs-comment">// 转移对象</span><br><span class="hljs-keyword">if</span> (coinOut0) txb.<span class="hljs-title function_">transferObjects</span>([coinOut0], recipient);<br><br><span class="hljs-keyword">if</span> (coinOut1) txb.<span class="hljs-title function_">transferObjects</span>([coinOut1], recipient1);<br><br></code></pre></td></tr></table></figure>

<h4 id="terminal"><a href="#terminal" class="headerlink" title="terminal"></a>terminal</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">sui client ptb <br><span class="hljs-literal">--assign</span> kapy @<span class="hljs-number">0</span>xa8f224924c9570c0bed020606be889fd46373e80c3a6b9547aeb33e646b4d540 <br><span class="hljs-literal">--assign</span> cfg @<span class="hljs-number">0</span>x80ff28774e3056f00e130a2dedda8be83c04acf3ab0697395bd37ee022001d15 <br><span class="hljs-literal">--move-call</span> <span class="hljs-number">0</span>xf61cffb662dda6c8ac484f299361b0d85464d06e46603321ad0b7311f0594490::exercise_3::buy_with_kapy kapy <br><span class="hljs-literal">--assign</span> dv <br><span class="hljs-literal">--move-call</span> <span class="hljs-number">0</span>xf61cffb662dda6c8ac484f299361b0d85464d06e46603321ad0b7311f0594490::exercise_3::pay <span class="hljs-string">&quot;&lt;sui::sui::SUI&gt;&quot;</span> @<span class="hljs-number">0</span>xd4fb85849ac089d5df317663b818dda0cf35a9f8b3c68ec81f941d010019bf7d cfg dv @<span class="hljs-number">0</span>x5617dbcfdea83576ae108ce03ea4fdebf2c505c53eec6e8c1130366f5bbb2eac <br><span class="hljs-literal">--assign</span> org <br><span class="hljs-literal">--move-call</span> <span class="hljs-number">0</span>xcbfbdaaa8e8a70556c0cf1a038ddb3d9cc86cdaeb1add61abf7ebd2becac7b9d::kapy::carry kapy org <span class="hljs-literal">--gas-budget</span> <span class="hljs-number">10000000</span> <br></code></pre></td></tr></table></figure>



<h2 id="Sui-client-命令速查"><a href="#Sui-client-命令速查" class="headerlink" title="Sui -client 命令速查"></a>Sui -client 命令速查</h2><ul>
<li><a href="https://docs.sui.io/references/cli/cheatsheet">https://docs.sui.io/references/cli/cheatsheet</a></li>
</ul>
<h2 id="Sui-Dapp-kit-套件"><a href="#Sui-Dapp-kit-套件" class="headerlink" title="Sui-Dapp kit 套件"></a>Sui-Dapp kit 套件</h2><ul>
<li><a href="https://sdk.mystenlabs.com/dapp-kit">https://sdk.mystenlabs.com/dapp-kit</a></li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">npm i <span class="hljs-literal">--save</span> @mysten/dapp<span class="hljs-literal">-kit</span> @mysten/sui @tanstack/react<span class="hljs-literal">-query</span><br>npm creat @mysten/dapp <br>npm install <span class="hljs-literal">--legacy-peer-deps</span><br>npm run dev<br></code></pre></td></tr></table></figure>

<h2 id="创建-Dapp"><a href="#创建-Dapp" class="headerlink" title="创建 Dapp"></a>创建 Dapp</h2><p><a href="https://sdk.mystenlabs.com/dapp-kit/create-dapp">https://sdk.mystenlabs.com/dapp-kit/create-dapp</a></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">npm create @mysten/dapp<br>选择<span class="hljs-number">1</span>：react<span class="hljs-literal">-client-dapp</span> - 一个基本的 React dApp，用于获取连接的钱包所拥有的对象列表。<br>选择<span class="hljs-number">2</span>：react<span class="hljs-literal">-e2e-counter</span> - 包含 <span class="hljs-built_in">Move</span> 代码和简单计数器应用程序 UI 的端到端示例<br>输入Dapp<span class="hljs-literal">-name</span><br><span class="hljs-built_in">cd</span> Dapp<span class="hljs-literal">-name</span><br>npm install  // 产生冲突 npm install <span class="hljs-literal">--legacy-peer-deps</span><br>npm run dev - 运行<br></code></pre></td></tr></table></figure>



<h3 id="Typescript-SDK"><a href="#Typescript-SDK" class="headerlink" title="Typescript SDK"></a>Typescript SDK</h3><ul>
<li><a href="https://sdk.mystenlabs.com/typescript">https://sdk.mystenlabs.com/typescript</a></li>
</ul>
<h4 id="coin-value-和-coin-into-balance-不同："><a href="#coin-value-和-coin-into-balance-不同：" class="headerlink" title="coin::value 和 coin::into_balance 不同："></a><strong><code>coin::value</code> 和 <code>coin::into_balance</code> 不同</strong>：</h4><ol>
<li><p><strong><code>coin::value</code></strong>:</p>
<ul>
<li><p>用于获取一个 <code>Coin</code> 的<strong>数值</strong>。</p>
</li>
<li><p>它是一个公共的 getter 函数，可以返回 <code>Coin</code> 的具体数值。</p>
</li>
<li><p>代码签名为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">public fun value&lt;T&gt;(self: &amp;coin::Coin&lt;T&gt;): u64<br></code></pre></td></tr></table></figure>
</li>
<li><p>这个函数不会改变 <code>Coin</code> 的状态，只是读取其数值。</p>
</li>
</ul>
</li>
<li><p><strong><code>coin::into_balance</code></strong>:</p>
<ul>
<li><p>用于将一个 <code>Coin</code> 解构为 <code>Balance</code>。</p>
</li>
<li><p>这个函数会消耗 <code>Coin</code> 对象，并返回其内部的 <code>Balance</code>。</p>
</li>
<li><p>代码签名为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">public fun into_balance&lt;T&gt;(coin: coin::Coin&lt;T&gt;): balance::Balance&lt;T&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用这个函数后，**<code>Coin</code> 不再存在，而是转换为了 <code>Balance</code>**。</p>
</li>
</ul>
</li>
</ol>
<p>这两个函数的主要区别在于一个是读取操作（<code>value</code>），另一个是转换操作（<code>into_balance</code>）。如果你想获取 <code>Coin</code> 的数值而不改变其状态，使用 <code>value</code>；如果你需要将 <code>Coin</code> 转换为 <code>Balance</code>，使用 <code>into_balance</code>。</p>
<h4 id="和直接传参和-mut-的区别"><a href="#和直接传参和-mut-的区别" class="headerlink" title="&amp; 和直接传参和&amp;mut 的区别"></a><strong>&amp; 和直接传参和&amp;mut 的区别</strong></h4><p>在 Move 中，<code>&amp;</code>、直接传参和 <code>&amp;mut</code> 的区别主要在于所有权和可变性：</p>
<ol>
<li><p><strong>引用（&amp;）</strong>：</p>
<ul>
<li>传递的是对象的不可变引用。</li>
<li>允许在函数中读取对象，但不能修改。</li>
<li>不会转移对象的所有权。</li>
</ul>
</li>
<li><p><strong>直接传参</strong>：</p>
<ul>
<li>传递的是对象本身。</li>
<li>转移对象的所有权到函数中。</li>
<li>函数可以消耗对象（例如，销毁或转移）。</li>
</ul>
</li>
<li><p><strong>可变引用（&amp;mut）</strong>：</p>
<ul>
<li>传递的是对象的可变引用。</li>
<li>允许在函数中读取和修改对象。</li>
<li>不会转移对象的所有权，但允许修改其状态。</li>
</ul>
</li>
</ol>
<p>选择使用哪种方式取决于你的具体需求：</p>
<ul>
<li>使用 <code>&amp;</code> 当你只需要读取对象而不修改。</li>
<li>使用 <code>&amp;mut</code> 当你需要在函数中修改对象。</li>
<li>使用直接传参当你需要转移对象的所有权或消耗它。</li>
</ul>
<h2 id="各类transfer的区别与使用"><a href="#各类transfer的区别与使用" class="headerlink" title="各类transfer的区别与使用"></a>各类transfer的区别与使用</h2><table>
<thead>
<tr>
<th>方法</th>
<th>生成的方法</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>transfer</td>
<td>独享对象</td>
<td>key</td>
</tr>
<tr>
<td>public_transfer</td>
<td>独享对象</td>
<td>key + store</td>
</tr>
<tr>
<td>freeze_object</td>
<td>共享对象-常量</td>
<td>key</td>
</tr>
<tr>
<td>public_freeze_object</td>
<td>共享对象-常量</td>
<td>key + store</td>
</tr>
<tr>
<td>share_object</td>
<td>共享对象</td>
<td>key</td>
</tr>
<tr>
<td>public_share_object</td>
<td>共享对象</td>
<td>key + store</td>
</tr>
</tbody></table>
<p>源码地址：<a href="https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/transfer.move">https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/transfer.move</a></p>
]]></content>
  </entry>
  <entry>
    <title>Javascript学习随笔</title>
    <url>/2024/04/25/%E5%89%8D%E7%AB%AF/JavaScript%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h1 id="Javascript-学习随笔"><a href="#Javascript-学习随笔" class="headerlink" title="Javascript 学习随笔"></a>Javascript 学习随笔</h1><blockquote>
<p>学习网站是：<a href="https://www.runoob.com/">https://www.runoob.com/</a><br>因为在这之前我只系统学习了C,因此在学习Javascript的过程中主要采用了比较的方法.</p>
</blockquote>
<h2 id="代码小问题"><a href="#代码小问题" class="headerlink" title="代码小问题"></a>代码小问题</h2><h3 id="为什么使用“-”？"><a href="#为什么使用“-”？" class="headerlink" title="为什么使用“+”？"></a>为什么使用“+”？</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">innerHTML</span> =<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span> + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-number">0</span> + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> &#123;&#125; + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> [] + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125; + <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>            <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>;<br></code></pre></td></tr></table></figure>

<p>在 JavaScript 中，<code>+</code> 运算符用于连接字符串。在这段代码中，<code>&quot;&lt;br&gt;&quot;</code> 是一个字符串，通过使用 <code>+</code> 运算符，我们将各种数据类型的类型输出连接成一个长字符串，然后将这个字符串设置为 <code>&lt;p&gt;</code> 元素的 <code>innerHTML</code>。这样可以确保每种数据类型的类型都输出到段落中，而不会覆盖之前的输出。</p>
<p>如果我们不使用 <code>+</code> 运算符，而是使用多个 <code>document.getElementById(&quot;demo&quot;).innerHTML</code> 进行赋值，只有最后一个赋值会生效，因为每次赋值都会覆盖之前的内容。通过使用 <code>+</code> 运算符，我们将每种类型的类型连接成一个字符串，然后一次性将整个字符串赋值给 <code>&lt;p&gt;</code> 元素的 <code>innerHTML</code>，这样就可以将所有类型都输出到段落中</p>
<h2 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个空数组</span><br><span class="hljs-keyword">let</span> emptyArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br><br><span class="hljs-comment">// 创建指定长度的空数组</span><br><span class="hljs-keyword">let</span> arrayWithLength = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 创建包含元素的数组</span><br><span class="hljs-keyword">let</span> fruits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>);<br><span class="hljs-comment">//直接</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript 中的对象是一种复合数据类型，用于存储多个<strong>键值对</strong> <em>在这里被称为<strong>对象属性</strong></em>。对象可以包含各种类型的数据，包括其他对象、数组、函数等</p>
<blockquote>
<p>关于键值对：我简单理解为名字和值一一对应的一种数据结构</p>
</blockquote>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p>就是属性值为函数</p>
<p><strong>特殊属性和方法</strong>：</p>
<ul>
<li><p><strong>原型（Prototype）</strong>：每个对象都有一个原型，它是一个指向另一个对象的引用，可以用于实现继承。</p>
</li>
<li><p><strong>构造函数（Constructor）</strong>：用于创建对象的函数。</p>
</li>
<li><p><strong>内置属性和方法</strong>：例如 <code>toString()</code>、<code>valueOf()</code> 等，这些方法和属性是 JavaScript 内置对象的一部分，可以直接使用</p>
</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>因为C中没有这个概念，所以这里着重写一下</p>
<blockquote>
<p>在 JavaScript 中，事件是指在 HTML 文档中发生的某些事情或动作，比如用户的交互操作（例如点击、鼠标移动、键盘输入等）或者浏览器自身的操作（例如页面加载完成、窗口大小改变等）。</p>
<p>HTML文档:我单纯理解为这个页面中包含的所有东西</p>
</blockquote>
<p><strong>事件可以分为两类：内置事件和用户自定义事件。</strong></p>
<ol>
<li><h3 id="内置事件："><a href="#内置事件：" class="headerlink" title="内置事件："></a><strong>内置事件</strong>：</h3><ul>
<li><p>内置事件是浏览器或者特定 HTML 元素自身触发的事件，比如：</p>
<ul>
<li><p>页面加载完成事件 (<code>load</code>)</p>
</li>
<li><p>鼠标点击事件 (<code>click</code>)</p>
</li>
<li><p>鼠标移动事件 (<code>mousemove</code>)</p>
</li>
<li><p>键盘按键事件 (<code>keydown</code>, <code>keyup</code>, <code>keypress</code>)</p>
</li>
<li><p>表单提交事件 (<code>submit</code>)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;title&gt;Event Examples&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;!-- Click Event Example --&gt;<br>&lt;button onclick=&quot;alert(&#x27;按钮被点击了！&#x27;)&quot;&gt;点击我&lt;/button&gt;<br><br>&lt;hr&gt;<br><br>&lt;!-- Mousemove Event Example --&gt;<br>&lt;div style=&quot;width: 100px; height: 100px; background-color: red;&quot; onmousemove=&quot;alert(&#x27;鼠标移动到了盒子上！&#x27;)&quot;&gt;&lt;/div&gt;<br><br>&lt;hr&gt;<br><br>&lt;!-- Key Event Example --&gt;<br>&lt;input type=&quot;text&quot; <br>       placeholder=&quot;按下按键或者松开按键&quot; <br>       onkeydown=&quot;alert(&#x27;按键按下了！&#x27;)&quot; <br>       onkeyup=&quot;alert(&#x27;按键松开了！&#x27;)&quot; <br>       onkeypress=&quot;alert(&#x27;按键被按下并松开了！&#x27;)&quot;&gt;<br><br>&lt;hr&gt;<br><br>&lt;!-- Load Event Example --&gt;<br>&lt;script&gt;<br>    function pageLoaded() &#123;<br>        alert(&#x27;页面加载完成！&#x27;);<br>    &#125;<br>    window.onload = pageLoaded;<br>&lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="用户自定义事件："><a href="#用户自定义事件：" class="headerlink" title="用户自定义事件："></a><strong>用户自定义事件</strong>：</h3><ul>
<li>除了内置事件之外，开发者还可以自定义事件，以便在特定情况下触发 JavaScript 代码执行。这种自定义事件通常是通过 <code>Event</code> 对象的构造函数来创建，并且可以通过 <code>dispatchEvent()</code> 方法手动触发。</li>
</ul>
</li>
</ol>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p><code>===</code>:绝对相等&#x3D;&gt;值类型都相等</p>
<p><code>!==</code>:不绝对相等</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>大体相同,还有一种比较特别的for循环</p>
<p><code>itCompanies</code> 是一个数组，<code>for...of</code> 循环用来遍历数组中的元素。<code>company</code> 是循环中的一个临时变量，每次迭代时，它会被赋值为数组中的一个元素。所以你的解释几乎正确，但是应该是将 <code>company</code> 赋值为 <code>itCompanies</code> 数组中的每个元素，而不是整个数组本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> itCompanies = [<span class="hljs-string">&quot;Facebook&quot;</span>, <span class="hljs-string">&quot;Google&quot;</span>, <span class="hljs-string">&quot;Microsoft&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;IBM&quot;</span>, <span class="hljs-string">&quot;Oracle&quot;</span>, <span class="hljs-string">&quot;Amazon&quot;</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> company <span class="hljs-keyword">of</span> itCompanies) &#123;<span class="hljs-comment">//让company赋值为itCompanies中的一个元素</span><br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> company) &#123;<br>    <span class="hljs-keyword">if</span> (char.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&quot;o&quot;</span>) &#123;<br>      count++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) &#123;<br>    companiesWithMoreThanOneO.<span class="hljs-title function_">push</span>(company);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Companies with more than one &#x27;o&#x27;:&quot;</span>, companiesWithMoreThanOneO);<br></code></pre></td></tr></table></figure>

<h2 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h2><p><strong>constructor</strong> 属性返回所有 JavaScript 变量的构造函数。</p>
<h2 id="Data-方法"><a href="#Data-方法" class="headerlink" title="Data()方法"></a>Data()方法</h2><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getDate()</td>
<td align="left">从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="left">getDay()</td>
<td align="left">从 Date 对象返回一周中的某一天 (0 ~ 6)。</td>
</tr>
<tr>
<td align="left">getFullYear()</td>
<td align="left">从 Date 对象以四位数字返回年份。</td>
</tr>
<tr>
<td align="left">getHours()</td>
<td align="left">返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="left">getMilliseconds()</td>
<td align="left">返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td align="left">getMinutes()</td>
<td align="left">返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">getMonth()</td>
<td align="left">从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="left">getSeconds()</td>
<td align="left">返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td align="left">getTime()</td>
<td align="left">返回 1970 年 1 月 1 日至今的毫秒数。</td>
</tr>
</tbody></table>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>&#x2F;正则表达式主体&#x2F;修饰符(可选)</p>
<h3 id="使用字符串方法"><a href="#使用字符串方法" class="headerlink" title="使用字符串方法"></a>使用字符串方法</h3><p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p>
<p><strong>search()</strong> 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</p>
<p><strong>replace()</strong> 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。</p>
<p><strong>exec()</strong> 方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>
<h3 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h3><p><strong>修饰符</strong> 可以在全局搜索中不区分大小写:</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">执行对大小写不敏感的匹配。</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">执行多行匹配。</td>
</tr>
</tbody></table>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h4 id="try-catch-throw"><a href="#try-catch-throw" class="headerlink" title="try  catch  throw"></a><strong>try  catch  throw</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> message, x;<br>  message = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p01&quot;</span>);<br>  message.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;&quot;</span>;<br>  x = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">value</span>;<br>  <span class="hljs-keyword">try</span> &#123; <br>    <span class="hljs-keyword">if</span>(x == <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;值是空的&quot;</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isNaN</span>(x)) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;值不是一个数字&quot;</span>;<br>    x = <span class="hljs-title class_">Number</span>(x);<br>    <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;太大&quot;</span>;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">5</span>) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;太小&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(err) &#123;<br>    message.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;错误: &quot;</span> + err + <span class="hljs-string">&quot;.&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;demo&quot;</span>).<span class="hljs-property">value</span> = <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="debugger-关键字"><a href="#debugger-关键字" class="headerlink" title="debugger 关键字"></a>debugger 关键字</h3><p><strong>debugger</strong> 关键字用于停止执行 JavaScript，并调用调试函数。</p>
<p>这个关键字与在调试工具中设置断点的效果是一样的。</p>
<p>可以先使用再声明</p>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>JavaScript 中的所有数据都是以 64 位<strong>浮点型数据(float)</strong> 来存储</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">0.1</span>;<br><span class="hljs-keyword">let</span> y = <span class="hljs-number">0.2</span>;<br><span class="hljs-keyword">let</span> z = x + y            <span class="hljs-comment">// z 的结果为 0.30000000000000004</span><br><span class="hljs-keyword">if</span> (z == <span class="hljs-number">0.3</span>)  <br></code></pre></td></tr></table></figure>

<p>&#x3D;&gt;用乘除法解决问题</p>
<h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p>由于与HTML的表单有关联,因此在这里先简单回顾一下HTML表单</p>
<p>具体可以参考另一篇笔记<a href="https://404ll.github.io/2024/04/25/%E5%89%8D%E7%AB%AF/HTML%E8%A1%A8%E5%8D%95/">HTML表单</a></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>表单验证可以包括以下内容：</p>
<ol>
<li><strong>必填字段验证</strong>：确保用户填写了表单中标记为必填的字段，防止用户提交空值或默认值。</li>
<li><strong>格式验证</strong>：检查用户输入的数据格式是否正确，例如邮箱地址、电话号码、日期等。</li>
<li><strong>长度验证</strong>：检查用户输入的数据长度是否符合要求，如最小长度、最大长度等。</li>
<li><strong>数据类型验证</strong>：确保用户输入的数据类型正确，如数字、字母、日期等。</li>
<li><strong>范围验证</strong>：检查数值型数据是否在指定的范围内，如年龄、价格等。</li>
<li><strong>正则表达式验证</strong>：使用正则表达式对用户输入的数据进行更灵活的验证，可以实现复杂的格式匹配。</li>
</ol>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x=<span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-string">&quot;myForm&quot;</span>][<span class="hljs-string">&quot;fname&quot;</span>].<span class="hljs-property">value</span>;<br></code></pre></td></tr></table></figure>

<p>用于获取 HTML 表单中名为 “myForm” 的表单中名为 “fname” 的输入字段的值，并将其存储在变量 x 中。</p>
<h2 id="验证API"><a href="#验证API" class="headerlink" title="验证API"></a>验证API</h2><h3 id="验证验证和表单验证的区别"><a href="#验证验证和表单验证的区别" class="headerlink" title="验证验证和表单验证的区别"></a>验证验证和表单验证的区别</h3><ol>
<li><strong>JavaScript 验证 API</strong>：<ul>
<li>JavaScript 验证 API 是 JavaScript 提供的一组 API 和方法，用于编写自定义的验证逻辑。</li>
<li>开发人员可以使用 JavaScript 验证 API 编写自己的验证函数，以根据特定的需求对用户输入进行验证。</li>
<li>这种方式更加灵活，可以实现各种复杂的验证逻辑，但需要编写更多的代码。</li>
</ul>
</li>
<li><strong>表单验证</strong>：<ul>
<li>表单验证是 HTML 表单元素自带的一种验证机制，可以通过设置一些属性来定义验证规则。</li>
<li>HTML5 提供了一些内置的表单验证属性，如 <code>required</code>, <code>min</code>, <code>max</code>, <code>pattern</code> 等，可以直接在 HTML 中使用。</li>
<li>表单验证相对简单，适用于一些基本的验证需求，如必填字段、最小长度、最大长度、正则表达式验证等</li>
</ul>
</li>
</ol>
<h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><p>我理解的This 表示对<strong>上一级对象</strong>的引用：</p>
<ul>
<li><p>方法体内表示对该方法所属的属性的引用</p>
</li>
<li><p>单独使用，就是全局对象</p>
</li>
<li><p>在函数中，函数的所属者绑定默认到this上（这里和后面学习智能合约有关联）</p>
</li>
<li><p>在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素。</p>
</li>
</ul>
<blockquote>
<p>方法是与对象相关联的函数</p>
</blockquote>
<p>在学习教程中看到了一篇笔记，可以帮助理解：</p>
<blockquote>
<p>简单理解，this指向的是该this所在的最里层的object对象。</p>
<p>1、函数不是object对象，所以没有写在object对象里的函数调用this会指向window</p>
<p>2、构造函数是object对象，所以在构造函数中调用this会指向该构造函数</p>
<p>3、html元素是object元素，所以在html元素中调用this会指向该元素</p>
<p>4、函数1 return 函数2，函数2 return this，该this会指向window</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&gt;<span class="hljs-keyword">let</span> obj = &#123;<br>   <span class="hljs-attr">fun1</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>       &#125;<br>   &#125;,<br>&gt;&#125;;<br>&gt;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">fun1</span>()()); <span class="hljs-comment">//window</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h1 id="javascript-void-0-含义"><a href="#javascript-void-0-含义" class="headerlink" title="javascript:void(0) 含义"></a>javascript:void(0) 含义</h1><p>void 在C语言中也有涉及，表示没有返回值。</p>
<p>在<strong>javascript:void(0)</strong> 中最关键的是 <strong>void</strong> 关键字， <strong>void</strong> 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值</p>
<h3 id="href-”-”与href-”javascript-void-0-”的区别"><a href="#href-”-”与href-”javascript-void-0-”的区别" class="headerlink" title="href&#x3D;”#”与href&#x3D;”javascript:void(0)”的区别"></a>href&#x3D;”#”与href&#x3D;”javascript:void(0)”的区别</h3><ol>
<li>**href&#x3D;”#”**：<ul>
<li>这个用法将页面的滚动位置移动到页面顶部。当用户点击链接时，浏览器会尝试滚动到页面中 ID 为 “#” 的元素，而在大多数情况下这个元素并不存在，因此页面会回到顶部。</li>
<li>使用 <code>href=&quot;#&quot;</code> 会触发页面滚动，有时可能会导致页面跳跃，尤其是在单页应用或具有滚动效果的页面中。</li>
</ul>
</li>
<li>**href&#x3D;”javascript:void(0)”**：<ul>
<li>这个用法是执行一个 JavaScript 表达式 <code>void(0)</code>，它会返回 undefined，但不会导致页面跳转或滚动。</li>
<li>使用 <code>href=&quot;javascript:void(0)&quot;</code> 不会触发页面滚动，因此不会导致页面跳跃</li>
</ul>
</li>
</ol>
<h2 id="promise和异步编程"><a href="#promise和异步编程" class="headerlink" title="promise和异步编程"></a>promise和异步编程</h2><p>**异步编程 ** 通俗来讲就是，不按照顺序执行</p>
<blockquote>
<p>Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）、rejected（已失败</p>
</blockquote>
<p><strong>Promise 构造函数</strong>返回一个 Promise 对象，该对象具有以下几个方法：</p>
<ul>
<li>then：用于处理 Promise 成功状态的回调函数。</li>
<li>catch：用于处理 Promise 失败状态的回调函数。</li>
<li>finally：无论 Promise 是成功还是失败，都会执行的回调函数。</li>
</ul>
<p>感觉大部分学习基于代码会比较清楚：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1111</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2222</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3333</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;An error&quot;</span>;<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>&#125;);<br></code></pre></td></tr></table></figure>





<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>在 JavaScript 中, 函数是对象。JavaScript 函数有它的属性和方法。</p>
<p><strong>call()</strong> 和 <strong>apply()</strong> 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身</p>
<h3 id="call-与apply-的不同"><a href="#call-与apply-的不同" class="headerlink" title="call()与apply()的不同"></a>call()与apply()的不同</h3><p>apply()的第二个参数是数组，call()是作为参数（从第二个起）单独传入。</p>
<h2 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h2><p>有关javascript的初步学习就到这里了，后面主要通过一些比较小的项目来进一步理解和深化学习！</p>
<p>进阶的补充会继续更新博客，请期待一下！</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>React</title>
    <url>/2024/09/18/%E5%89%8D%E7%AB%AF/react%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>学习视频</p>
<p><a href="https://www.bilibili.com/video/BV1is4y167yY/?p=41&spm_id_from=pageDriver&vd_source=7815abf75f25008fd075daf46f5ff072">12. Props, Immutability, and One-Way Data Flow_哔哩哔哩_bilibili</a></p>
</blockquote>
<h1 id="React笔记"><a href="#React笔记" class="headerlink" title="React笔记"></a>React笔记</h1><hr>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>这里写了常用到的 js知识 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//对象解构赋值（Object Destructuring），允许你从对象中提取属性，并将它们赋值给变量</span><br><span class="hljs-keyword">const</span> &#123; title,author,publicationDate,hasMovieAdaptation,genres,reviews,translations &#125; = book; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(title, author);<br><br><span class="hljs-comment">//数组解构赋值允许你将数组中的值提取到单独的变量中，语法类似于对象解构赋值，但使用的是方括号 []；</span><br><span class="hljs-keyword">const</span> [firstBook, secondBook, ...otherBooks ] = books; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstBook, secondBook, otherBooks);<br><span class="hljs-comment">//添加新元素  在解构赋值中，... 操作符可以用来收集剩余的元素。它可以用于数组解构时将剩余的元素赋值给一个新数组</span><br><span class="hljs-keyword">const</span> newGenres = [...book.<span class="hljs-property">genres</span>, <span class="hljs-string">&quot;horror&quot;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newGenres);<br><br><span class="hljs-comment">//adding new genre to books可以覆盖原数组，也可以添加新的元素</span><br><span class="hljs-comment">//先展开</span><br><span class="hljs-keyword">const</span> updateBook = &#123; ...books, <span class="hljs-attr">data</span>:<span class="hljs-string">&quot;123&quot;</span> &#125;;<br>updateBook;<br><br><span class="hljs-comment">//模板字符串</span><br><span class="hljs-keyword">const</span> summary = <span class="hljs-string">`<span class="hljs-subst">$&#123;title&#125;</span> is a book,and published in <span class="hljs-subst">$&#123;publicationDate.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">0</span>]&#125;</span>`</span>;<br>summary;<br><br><span class="hljs-comment">//三元运算符</span><br><span class="hljs-keyword">const</span> hasMovie = books.<span class="hljs-property">hasMovieAdaptation</span> ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>;<br>hasMovie;<br><br><span class="hljs-comment">//箭头函数 split() 方法用于分割字符串，并返回一个包含分割后的子字符串的数组。</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">publicationDateYear</span> = (<span class="hljs-params">str</span>) =&gt; str.<span class="hljs-property">publicationDate</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">0</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">publicationDateYear</span>(book));<br><span class="hljs-comment">//运算符</span><br><span class="hljs-comment">// &amp;&amp; 短路逻辑与 || 短路逻辑</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-string">&quot;nihao&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-literal">false</span> || <span class="hljs-string">&quot;nihao&quot;</span>);<br><span class="hljs-comment">// console.log( true || &quot;nihao&quot;);</span><br><span class="hljs-comment">// console.log( false &amp;&amp; &quot;nihao&quot;);</span><br><br><span class="hljs-comment">//?? false短路逻辑 总评</span><br><span class="hljs-keyword">const</span> count = book.<span class="hljs-property">reviews</span>.<span class="hljs-property">librarything</span> ?? <span class="hljs-number">0</span>;<br>count;<br><br><span class="hljs-comment">//falsy values: false, null, undefined, 0, NaN, &quot;&quot;</span><br><span class="hljs-comment">//truthy values: true, non-empty string, non-empty array, object, function </span><br><br><br><span class="hljs-comment">//optonal chaining  </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTotalReviewcount</span>(<span class="hljs-params">book</span>)&#123;<br>  <span class="hljs-keyword">const</span> goodreads = book.<span class="hljs-property">reviews</span>?.<span class="hljs-property">goodreads</span>;<br>  <span class="hljs-keyword">const</span> librarything = book.<span class="hljs-property">reviews</span>?.<span class="hljs-property">librarything</span> ?? <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> goodreads + librarything;<br>&#125;<br><span class="hljs-keyword">const</span> totalReviewCount = <span class="hljs-title function_">getTotalReviewcount</span>(book);<br>totalReviewCount;<br><br><span class="hljs-comment">//map会遍历数组中的每一个元素，并按照函数式，对原数组的每一项进行操作，返回一个新的数组</span><br><span class="hljs-keyword">const</span> x =[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num * <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br><br><span class="hljs-comment">// reduce 的效果 是将数组中的元素合并成一个值 相较于 filter、map</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> sum = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, cur</span>) =&gt;</span> sum + cur, <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br><br><span class="hljs-comment">//filer 过滤数组中的元素，返回一个新的数组</span><br><span class="hljs-keyword">const</span> arr3 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> filteredArr = arr3.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);<br>filteredArr;<br><br><span class="hljs-comment">//sort 会改变原数组，返回排序后的数组</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> sortedArr = arr1.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>sortedArr;<br>arr1;<br><br><span class="hljs-comment">// slice 可以返回一个新数组，不会改变原数组</span><br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> slicedArr2 = arr2.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>).<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(slicedArr2);<br>arr2;<br><br><span class="hljs-comment">//箭头函数 为了延迟执行 onDeleteItem(item.id)，即在点击时才调用它</span><br>onClick=&#123;<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">onDeleteItem</span>(item.<span class="hljs-property">id</span>)&#125; <br><br><span class="hljs-comment">//回调函数 作为参数传递给另一个函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(greet, <span class="hljs-number">2000</span>);  <span class="hljs-comment">// 2秒后调用greet函数</span><br><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>React</strong> 是用于构建用户界面的 JavaScript 库。</p>
<p>它提供了组件、状态管理、生命周期方法等功能来帮助开发者构建复杂的前端应用</p>
<p>其主要功能是实现后端数据与前端页面的即时更新，同时减少单一使用<code>js</code>时的繁冗工作量</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h4 id="创建项目："><a href="#创建项目：" class="headerlink" title="创建项目："></a>创建项目：</h4><h5 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h5><p>a. 安装 Node.js 和 npm（Node.js 包管理器）。</p>
<p>b. 打开终端或命令提示符。</p>
<p>c. 运行以下命令来创建一个新的 React 应用程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npx create-react-app my-app<br>cd my-app<br>npm start<br></code></pre></td></tr></table></figure>

<h5 id="方法2：使用-Vite"><a href="#方法2：使用-Vite" class="headerlink" title="方法2：使用 Vite"></a>方法2：使用 Vite</h5><p>Vite 是一个轻量级的构建工具，它提供了快速的冷启动和热更新。它支持 TypeScript、CSS 预处理器和许多其他功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm init vite@latest my-app -- --template react<br>cd my-app<br>npm install<br>npm run dev<br></code></pre></td></tr></table></figure>

<p>文件结构如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">my-app/<br>├── node_modules/         <span class="hljs-comment"># 项目依赖的第三方库</span><br>├── public/<br>│   ├── favicon.ico       <span class="hljs-comment"># 网站图标</span><br>│   ├── index.html        <span class="hljs-comment"># HTML 入口文件</span><br>│   ├── manifest.json     <span class="hljs-comment"># PWA 应用配置文件</span><br>│   └── robots.txt        <span class="hljs-comment"># 爬虫协议文件</span><br>├── src/<br>│   ├── App.css           <span class="hljs-comment"># 应用的样式文件</span><br>│   ├── App.tsx           <span class="hljs-comment"># 应用的主组件文件 (或 .js)</span><br>│   ├── App.test.tsx      <span class="hljs-comment"># 测试文件，使用 Jest 测试框架</span><br>│   ├── index.css         <span class="hljs-comment"># 全局样式文件</span><br>│   ├── index.tsx         <span class="hljs-comment"># 应用入口文件 (或 .js)</span><br>│   ├── logo.svg          <span class="hljs-comment"># 应用 logo 图标</span><br>│   ├── reportWebVitals.ts <span class="hljs-comment"># 性能报告 (可选)</span><br>│   └── setupTests.ts     <span class="hljs-comment"># 设置测试环境的配置文件</span><br>├── .gitignore            <span class="hljs-comment"># Git 忽略文件配置</span><br>├── package.json          <span class="hljs-comment"># 项目配置文件，包含依赖信息和脚本</span><br>├── README.md             <span class="hljs-comment"># 项目的 README 文件</span><br>├── tsconfig.json         <span class="hljs-comment"># TypeScript 配置文件（如果使用 TypeScript）</span><br>└── yarn.lock / package-lock.json  <span class="hljs-comment"># 锁定依赖版本的文件</span><br><br></code></pre></td></tr></table></figure>

<h2 id="React-三要素"><a href="#React-三要素" class="headerlink" title="React 三要素"></a>React 三要素</h2><h3 id="1-组件（Component）"><a href="#1-组件（Component）" class="headerlink" title="1. 组件（Component）"></a>1. <strong>组件（Component）</strong></h3><p>组件是 React 的基础构建块，每个 React 应用都是由一个个组件组合而成的。React为每一个组件渲染一个视图，这些视图组成UI。每个组件都拥有自己的 “<strong>数据</strong>”  “<strong>（js）逻辑</strong>”  “<strong>外观</strong>”</p>
<ul>
<li><img src="https://raw.githubusercontent.com/404ll/My-images/main//img202411052000182.png" alt="image-20240920204607063-17268363750311"><strong>类组件</strong>：通过 ES6 的类来定义，包含状态（state)和生命周期方法。</li>
<li><strong>函数组件</strong>：React 16.8 之后推荐的方式，使用函数定义组件并结合钩子（Hooks）来管理状态和生命周期。</li>
</ul>
<p>组件不可嵌套</p>
<p><strong>示例</strong>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 函数组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<h4 id="什么是-JSX"><a href="#什么是-JSX" class="headerlink" title="什么是 JSX ?"></a>什么是 JSX ?</h4><p>jsx是一种声明语法，用来描述组件的外观，根据数据和逻辑工作。通常与 React 一起使用，允许在 JavaScript 代码中编写类似 HTML 的标签</p>
<ol>
<li><strong>类 HTML 的语法</strong>：</li>
</ol>
<ul>
<li>JSX 允许在 JavaScript 代码中嵌入类似 HTML 的标签，使得编写用户界面时更加直观和简洁。虽然看起来像 HTML，但 JSX 实际上会被编译成 JavaScript 函数调用。</li>
</ul>
<ol start="2">
<li><strong>支持表达式</strong>：</li>
</ol>
<ul>
<li><p>JSX 中可以使用 JavaScript 表达式，通过{}包裹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">const name = &#x27;Alice&#x27;;<br>const element = &lt;h1&gt;Hello, &#123;name&#125;!&lt;/h1&gt;;<br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><strong>必须返回一个父元素</strong>：</li>
</ol>
<ul>
<li><p>在 JSX 中，所有标签必须被一个父级元素包裹。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">return (<br>  &lt;div&gt;<br>    &lt;h1&gt;Title&lt;/h1&gt;<br>    &lt;p&gt;Description&lt;/p&gt;<br>  &lt;/div&gt;<br>);<br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><strong>样式和属性的处理</strong>：</li>
</ol>
<ul>
<li><p>在 JSX 中，class属性被替换为<code>className</code>，style属性接受一个对象。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;div className=&quot;container&quot; style=&#123;&#123; color: &#x27;red&#x27; &#125;&#125;&gt;Hello&lt;/div&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h3 id="2-状态（State）"><a href="#2-状态（State）" class="headerlink" title="2. 状态（State）"></a>2. <strong>状态（State）</strong></h3><p>状态是组件内部的数据，它决定了组件的行为和显示的内容。</p>
<p>状态是可变的，随着用户的交互或其他事件触发，它会发生变化并<strong>重新渲染</strong>组件。</p>
<p>在类组件中，状态通过 <code>this.state</code> 来管理，在函数组件中使用 <code>useState</code> <strong>钩子</strong>来管理。</p>
<blockquote>
<p>什么是钩子？</p>
<p>在 React 中，钩子就是use开头的状态组件，允许你在函数组件中使用状态和其他 React 特性，而不需要编写类组件。</p>
<p>常见的 React 钩子有：</p>
<ul>
<li><code>useState</code>：用于在函数组件中添加状态变量。</li>
<li><code>useEffect</code>：用于执行副作用操作（如数据获取、订阅或手动更改 DOM）。</li>
<li><code>useContext</code>：用于在组件树中共享数据，而无需逐层传递 props。</li>
</ul>
</blockquote>
<h4 id="怎么使用状态"><a href="#怎么使用状态" class="headerlink" title="怎么使用状态"></a>怎么使用状态</h4><p><strong>什么时候创建状态？</strong></p>
<ol>
<li><p>需要存储数据？</p>
</li>
<li><p>数据会发生变化吗 </p>
<ul>
<li>不会 &#x3D;&gt; const 常量即可</li>
</ul>
</li>
<li><p>是否可以从现有的道具&#x2F;状态中计算？</p>
<ul>
<li>会 &#x3D;&gt; 派生状态(derive state)</li>
</ul>
</li>
<li><p>更新状态是否需要重新渲染组件？</p>
</li>
</ol>
<ul>
<li>不会 &#x3D;&gt; 使用Ref （像普通状态一样持久的保持数据，但无需重新渲染组件）</li>
</ul>
<ol start="5">
<li>使用useState创建一个状态，并放置在组件中</li>
</ol>
<p><strong>在哪里使用状态？</strong></p>
<p><strong>当前组件</strong>、通过道具传递给<strong>子组件</strong>、将状态传递给同级组件的<strong>公共父组件</strong>中去（状态上移）、所有组件使用（<strong>全局状态</strong>）</p>
<h4 id="派生状态"><a href="#派生状态" class="headerlink" title="派生状态"></a>派生状态</h4><p>派生状态就是简单地从一个现有状态或者道具中计算出来的状态</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [total,setTotal] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> tip = total /<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>



<h3 id="3-属性（Props）"><a href="#3-属性（Props）" class="headerlink" title="3. 属性（Props）"></a>3. <strong>属性（Props）</strong></h3><p><code>props</code> 是组件之间传递数据的方式。</p>
<p>父组件可以通过 <code>props</code> 向子组件传递数据，子组件无法修改 <code>props</code>，它们是只读的。<code>props</code> 的主要作用是让组件的渲染更加灵活和<strong>可复用</strong>。</p>
<p>在传递中，我们可以使用 js 中的<code>重构</code>来传递对象的名称而不是<code>props</code>，但是不要忘记使用<code>&#123;&#125;</code></p>
<p color="red">注 : React是单向数据流，数据只能从父组件流向子组件</p>

<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// 父组件向子组件传递数据<br>function Menu() &#123;<br>  return (<br>      &lt;main className=&quot;menu&quot;&gt;<br>        &lt;h2&gt;our pizzas&lt;/h2&gt;<br>        &lt;Pizza name= &quot;Focaccia&quot; <br>        ingredients= &quot;Bread with italian olive oil and rosemary&quot; <br>        price=&quot;6&quot; <br>        photoName=&quot;pizzas/focaccia.jpg&quot;/&gt;<br>       &lt;/main&gt;<br><br>function Pizza(props) &#123;<br>  return (<br>      &lt;div className=&quot;pizza&quot;&gt;<br>        &lt;img src=&#123;props.photoName&#125; alt=&#123;props.name&#125; /&gt;<br>        &lt;div className=&quot;pizzas&quot;&gt;<br>        &lt;h3&gt;&#123;props.name&#125;&lt;/h3&gt;<br>        &lt;p&gt;&#123;props.ingredients&#125;&lt;/p&gt;<br>        &lt;span&gt;&#123;props.price&#125;&lt;/span&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="子代道具"><a href="#子代道具" class="headerlink" title="子代道具"></a>子代道具</h4><p>在 React 中，<strong>子代道具（Children Props）</strong> 是指通过 <code>props.children</code> 传递的内容，它允许父组件将嵌套在其内部的 JSX 代码或组件传递给子组件。它提供了一种灵活的方式来构建可复用的组件，使得父组件可以决定子组件的内部内容，而不需要在子组件中明确指定。</p>
<p>示例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//子组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Wrapper</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span>&#123;props.children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-comment">//父组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Wrapper</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a paragraph inside the Wrapper component.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Wrapper</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="三要素关系总结："><a href="#三要素关系总结：" class="headerlink" title="三要素关系总结："></a>三要素关系总结：</h3><ul>
<li><strong>组件</strong> 是 UI 的基本单元，通过组合形成完整的应用。</li>
<li><strong>状态</strong> 是组件内部的动态数据，控制着组件的行为和显示。</li>
<li><strong>属性（props）</strong> 用于在组件间传递数据，通常是父组件传递给子组件的数据。</li>
</ul>
<blockquote>
<p>状态与道具有什么区别？</p>
<p><strong>状态（state）</strong>：状态是组件内部管理的数据，数据归创建他的组件所有，它可以看作组件的存储，可以用来长期保存数据。状态可以在组件内部被修改（通过<code>setState</code>或<code>useState</code>），并会在变化时触发组件重新渲染，用来控制组件的行为、渲染和交互。</p>
<ul>
<li>用于存储组件内部<strong>动态变化的数据</strong>，比如用户输入的表单值、加载数据的结果、组件的交互状态（如打开或关闭某个UI元素）。</li>
<li>当状态发生变化时，React会自动触发两个组件的重新渲染</li>
</ul>
<p><strong>道具（props）</strong>：道具是从父组件传递给子组件的数据，数据被父组件所有，可以把它想象函数参数。因为它是只读的，<strong>子组件无法直接修改它</strong>。当子组件收到更新的props时，也会重新渲染组件</p>
<ul>
<li>道具主要用来让组件间进行<strong>静态数据传</strong>递，通常是父组件将数据通过道具传递给子组件，子组件根据道具的值渲染。</li>
<li>当道具的值在父组件中发生变化时，子组件会重新渲染。</li>
</ul>
</blockquote>
<h2 id="怎么渲染列表（rendering-a-list）"><a href="#怎么渲染列表（rendering-a-list）" class="headerlink" title="怎么渲染列表（rendering a list）"></a>怎么渲染列表（rendering a list）</h2><p>概念：可以理解为创建一个数组，并为数组里的每个元素创建组件</p>
<p>通常我们会使用数组的 <code>map()</code> 方法来生成列表项。每个列表项需要一个唯一的 <code>key</code> 属性，以帮助 React 识别和优化列表中的元素</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//const pizzaData = [&#123;...&#125;]</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Menu</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>our pizzas<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;pizzaData.map((pizzas) =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Pizza</span> <span class="hljs-attr">pizzaObj</span>=<span class="hljs-string">&#123;pizzas&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;pizzas.name&#125;</span> /&gt;</span> ))&#125;</span><br><span class="language-xml">  &#123;/*这一段代码是 React 中通过数组的 map() 方法渲染列表的常用方式。它的作用是遍历 pizzaData 数组，为数组中的每个对象生成一个对应的 Pizza 组件*/&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Pizza</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;pizza&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;props.pizzaObj.photoName&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;props.pizzaObj.name&#125;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;pizzas&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;props.pizzaObj.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;props.pizzaObj.ingredients&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;props.pizzaObj.price&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>方法一：使用 &amp;&amp; 运算符的<strong>短路逻辑</strong>，在特定条件下选择内容</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Footer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getHours</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  <span class="hljs-keyword">const</span> open = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">const</span> close = <span class="hljs-number">22</span>;<br>  <span class="hljs-keyword">const</span> isOpen = data &gt;= open &amp;&amp; data &lt; close;<br>  <span class="hljs-keyword">return</span> ( <br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;isOpen &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Open<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> &#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>方法2：使用<strong>三元运算符</strong></p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Footer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getHours</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  <span class="hljs-keyword">const</span> open = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">const</span> close = <span class="hljs-number">22</span>;<br>  <span class="hljs-keyword">const</span> isOpen = data &gt;= open &amp;&amp; data &lt; close;<br>  <span class="hljs-keyword">return</span> ( <br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;isOpen = true ?(<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Open<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>): null&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>方法三：多重返回</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Footer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getHours</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  <span class="hljs-keyword">const</span> open = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">const</span> close = <span class="hljs-number">22</span>;<br>  <span class="hljs-keyword">const</span> isOpen = data &gt;= open &amp;&amp; data &lt; close;<br><br>  <span class="hljs-keyword">if</span> (!isOpen) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Close<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> ( <br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span></span><br><span class="language-xml">        &#123;/* &#123;isOpen &amp;&amp;  */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;order&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> We&#x27;re open for orders from &#123;open&#125; to &#123;close&#125;. Call us at 123-456-7890.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span> &#x27;<span class="hljs-attr">yellow</span>&#x27;&#125;&#125; &gt;</span>Order<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> </span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="React-Fragment-react-片段"><a href="#React-Fragment-react-片段" class="headerlink" title="React Fragment(react 片段)"></a>React Fragment(react 片段)</h2><p>概念：<code>React.Fragment</code> 是 React 中用于<strong>包裹多个子元素</strong>而不额外生成 HTML 元素的组件。</p>
<p>通常在 JSX 中，如果你返回多个元素，它们需要被一个父级元素<code>&lt;div&gt;&lt;/div&gt;</code>包裹，而 <code>React.Fragment</code> 可以在不生成额外 DOM 节点的情况下包裹这些元素。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">react.fragment</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span>/&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Menu</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">react.fragment</span>&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span>/&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Menu</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure>





<h2 id="如何在React中使用表单？"><a href="#如何在React中使用表单？" class="headerlink" title="如何在React中使用表单？"></a>如何在React中使用表单？</h2><h4 id="怎么判断是否需要使用表单？"><a href="#怎么判断是否需要使用表单？" class="headerlink" title="怎么判断是否需要使用表单？"></a>怎么判断是否需要使用表单？</h4><ol>
<li><strong>用户输入</strong>：如果你需要用户输入数据，比如添加待办事项，那么你需要一个表单。表单可以包含输入框、文本域、选择框等元素，让用户输入信息。</li>
<li><strong>提交操作</strong>：如果你需要用户提交数据，比如添加待办事项后保存到列表中，那么你需要一个表单。表单通常包含一个提交按钮，用户点击后触发数据提交。</li>
<li><strong>数据验证</strong>：如果你需要对用户输入的数据进行验证，比如检查待办事项是否为空，那么你需要一个表单。表单可以包含验证逻辑，确保用户输入的数据符合要求。</li>
<li><strong>状态管理</strong>：如果你需要管理用户输入的状态，比如输入框的值，那么你需要一个表单。表单可以包含状态管理逻辑，确保用户输入的数据能够被正确处理。</li>
<li><strong>事件处理</strong>：如果你需要处理用户输入的事件，比如输入框的 <code>onChange</code> 事件，那么你需要一个表单。表单可以包含事件处理逻辑，响应用户的操作。</li>
</ol>
<p>表单完整代码（以ToDoList为例）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span> (<span class="hljs-params"></span>)&#123;<br>  <br>    <span class="hljs-keyword">const</span> [description, setDescription] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [quantity, setQuantity] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">e</span>)&#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;<br>   <br>    <span class="hljs-keyword">return</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;add-form&quot;</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>What do you need for your trip<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;quantity&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> setQuantity(Number(e.target.value)&#125; &gt;</span><br><span class="language-xml">        &#123;Array.from(&#123;length: 20&#125;, (_, i) =&gt; i+1).map</span><br><span class="language-xml">        ((num) =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">option</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;num&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;num&#125;</span>&gt;</span></span><br><span class="language-xml">            &#123;num&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>))&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Item...&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;description&#125;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> setDescription(e.target.value)&#125;/&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>渲染列表</p>
<p><code> &#123;Array.from(&#123;length: 20&#125;, (_, i) =&gt; i+1).map         ((num) =&gt; (           &lt;option value=&#123;num&#125; key=&#123;num&#125;&gt;             &#123;num&#125;             &lt;/option&gt;))&#125;</code>:</p>
<p>利用<code>Array.from()</code>生成一个数组，并通过<code>map()</code>来遍历数组，动态生成一组<code>&lt;option&gt;</code>标签</p>
<p><code>onChange</code>：当用户在输入框中输入内容时，<code>onChange</code>事件会触发，更新React状态，从而动态更新表单值</p>
<h3 id="如何将表单中的数据导入事件"><a href="#如何将表单中的数据导入事件" class="headerlink" title="如何将表单中的数据导入事件?"></a>如何将表单中的数据导入事件?</h3><blockquote>
<h4 id="常见的React事件类型："><a href="#常见的React事件类型：" class="headerlink" title="常见的React事件类型："></a>常见的React事件类型：</h4><ul>
<li>**<code>onClick</code>**：点击事件</li>
<li>**<code>onChange</code>**：表单元素（如输入框、选择框）的值改变事件</li>
<li>**<code>onSubmit</code>**：表单提交事件</li>
<li>**<code>onKeyDown</code><strong>、</strong><code>onKeyUp</code>**：键盘按下、松开事件</li>
<li>**<code>onMouseEnter</code><strong>、</strong><code>onMouseLeave</code>**：鼠标进入、离开事件</li>
</ul>
</blockquote>
<h4 id="受控元素"><a href="#受控元素" class="headerlink" title="受控元素"></a>受控元素</h4><p>在React中，使用受控组件可以将HTML表单中的数据与组件的状态（<code>state</code>）直接绑定，从而避免直接操作DOM。这样做的好处是表单数据的更新和管理完全交由React来处理，无需手动获取DOM元素的值</p>
<p>三个步骤：</p>
<ul>
<li><p>设置状态  <code>const [description, setDescription] = useState(&#39;&#39;);</code></p>
<ul>
<li><strong>目的</strong>：创建一个变量来存储用户输入的值，并在用户与表单交互时，React能够追踪和管理这个值。</li>
</ul>
</li>
<li><p>绑定变量   通过<code>value</code>属性，将表单元素（例如<code>&lt;input&gt;</code>或<code>&lt;textarea&gt;</code>）的值与刚刚创建的状态变量绑定。这样，表单的值由状态控制，React状态和UI之间建立了双向绑定关系。</p>
<ul>
<li><strong>操作</strong>：在表单元素上使用<code>value=&#123;description&#125;</code>，使输入框的值与<code>description</code>状态保持同步</li>
</ul>
</li>
<li><p>更新状态   <code> onChange=&#123;(e) =&gt; setDescription(e.target.value)&#125;</code>，当用户在表单元素中输入内容时，<code>onChange</code>事件会触发。此时，你可以使用<code>setDescription</code>函数更新状态，确保状态随用户输入的变化而改变。事件处理函数将接收事件对象，通过<code>e.target.value</code>获取表单元素的新值。</p>
<ul>
<li><p><strong>操作</strong>：在<code>onChange</code>事件处理函数中调用<code>setDescription(e.target.value)</code>，将表单的新值更新到状态中</p>
</li>
<li><blockquote>
<h4 id="js小知识"><a href="#js小知识" class="headerlink" title="js小知识"></a>js小知识</h4><p>在 <code>onChange=&#123;(e) =&gt; setDescription(e.target.value)&#125;</code> 这段代码中，<code>e</code> 是一个事件对象（Event Object），它代表了当前正在发生的事件。在 JavaScript 中，当事件（如点击、输入等）发生时，浏览器会创建一个事件对象，该对象包含了与该事件相关的所有信息。</p>
<p>在这个特定的例子中，<code>e</code> 是一个合成事件（Synthetic Event）对象，它是 React 为了兼容不同浏览器而创建的一个抽象层。合成事件对象封装了原生浏览器事件，并提供了一个统一的接口，使得开发者可以编写跨浏览器的代码。</p>
<p><code>e.target</code> 是事件的目标元素（Event Target），即触发事件的 DOM 元素。在这个例子中，<code>e.target</code> 是输入框（input）元素。</p>
<p><code>e.target.value</code> 是输入框元素的当前值（Value），即用户输入的内容。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>扫盲小知识之 质押与再质押</title>
    <url>/2024/05/21/%E5%8C%BA%E5%9D%97%E9%93%BE/2024-05-21-%E6%89%AB%E7%9B%B2%E5%B0%8F%E7%9F%A5%E8%AF%86%E4%B9%8B-%E8%B4%A8%E6%8A%BC%E4%B8%8E%E5%86%8D%E8%B4%A8%E6%8A%BC/</url>
    <content><![CDATA[<h1 id="质押-staking-与-再质押-restaking"><a href="#质押-staking-与-再质押-restaking" class="headerlink" title="质押(staking) 与 再质押(restaking)"></a>质押(staking) 与 再质押(restaking)</h1><h2 id="质押"><a href="#质押" class="headerlink" title="质押"></a>质押</h2><blockquote>
<p>质押（staking）是一种通过锁定一定数量的加密货币来支持区块链网络操作（例如验证交易和维护网络安全）的机制。作为回报，质押者可以获得奖励（通常是额外的加密货币），同时质押者通常拥有一定的投票权或参与网络治理的权利</p>
</blockquote>
<h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a><strong>详细解释</strong>：</h3><ul>
<li><strong>Proof of Stake（PoS）</strong>：质押最常见于基于权益证明（Proof of Stake, PoS）共识机制的区块链中。在这种机制下，区块链通过质押者的投票选举出区块验证者（validators），而不是通过解决复杂的数学难题（如在工作量证明（Proof of Work, PoW）机制中）。</li>
<li><strong>奖励</strong>：质押者通常会根据他们所质押的加密货币数量和质押时间长度来获得奖励。这些奖励可以是新生成的加密货币或交易费用的一部分。</li>
<li><strong>风险</strong>：质押也有风险，例如质押的加密货币可能会被冻结一定时间，无法随时取出。此外，如果网络遭受攻击或质押者不遵守规则，可能会损失一部分或全部质押的加密货币。</li>
</ul>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a><strong>举例</strong>：</h3><ul>
<li><strong>以太坊2.0</strong>：以太坊2.0采用PoS机制，用户可以质押32个以太币（ETH）成为验证者，并获得奖励。</li>
</ul>
<h3 id="为什么ETH会存在质押的模式"><a href="#为什么ETH会存在质押的模式" class="headerlink" title="为什么ETH会存在质押的模式?"></a>为什么ETH会存在质押的模式?</h3><p>质押是权益证明（Proof of Stake, PoS）及其变种共识机制的核心概念.下面是我在网络上看到的有关文章的部分节选,完整版请参照</p>
<blockquote>
<p>[<strong>白话区块链</strong>]    <a href="https://www.hellobtc.com/kp/du/09/4703.html">https://www.hellobtc.com/kp/du/09/4703.html</a> 质押现状：以太坊合并一年后的 5 大看点</p>
<p>ps: 我觉得这个频道用来扫盲挺好的,不过不要仅仅局限于一篇文章</p>
</blockquote>
<img src="file://C:/Users/32423/AppData/Roaming/Typora/typora-user-images/image-20240605184045270.png?lastModify=1717592035?lastModify=1717592086" alt="image-20240605184045270" style="zoom:25%;">



<h2 id="再质押"><a href="#再质押" class="headerlink" title="再质押"></a>再质押</h2><blockquote>
<p>「再质押」是一个将流动性质押代币资产用于在其他区块链的验证者进行质押，以获得更多收益，同时有助于提高新网络的安全性和去中心化的行为。也可理解为再质押是加密经济安全中的一个新概念，它使以太坊既定的经济信任能够扩展到保护其他分布式系统，例如预言机、桥接器或侧链。      其使用从质押获得的奖励继续向该节点存款，以增加未来的利润。通过再质押，投资者可以从原始协议和再质押协议两方面获得多重收益。</p>
</blockquote>
<h3 id="再质押的实现方式"><a href="#再质押的实现方式" class="headerlink" title="再质押的实现方式"></a>再质押的实现方式</h3><p><strong>再质押主要是基于以太坊的安全框架来提升整个加密货币生态系统中的资金使用效率；质押者在能够支持一个网络安全性的同时还能够为多个网络提供验证服务，从而获得额外的奖励。</strong></p>
<ol>
<li><strong>衍生代币（Derivative Tokens）</strong>：<ul>
<li>当用户在某个平台上质押其资产后，平台可以为用户生成一种代表这些质押资产的衍生代币。</li>
<li>例如，用户在平台A上质押ETH，平台A会给用户发放一种代币，如stETH，代表用户在平台A上质押的ETH。</li>
<li>用户可以拿这些衍生代币（如stETH）去另一个平台B上进行再质押或参与其他DeFi活动。</li>
</ul>
</li>
<li><strong>合约层的再质押</strong>：<ul>
<li>一些区块链协议或智能合约平台允许直接将已经质押的资产再质押。</li>
<li>例如，通过跨链桥或跨协议的智能合约，用户可以将质押的资产从一个网络转移并质押到另一个网络。</li>
</ul>
</li>
<li><strong>流动性质押（Liquid Staking）</strong>：<ul>
<li>这种方式允许用户在质押其资产的同时，获取一种具有流动性的代币，这种代币可以在其他平台上进行交易或再质押。</li>
<li>流动性质押代币通常可以在市场上自由交易，使用户即使在质押期间，也能有一定的流动性来参与其他投资活动。</li>
</ul>
</li>
</ol>
<h3 id="再质押的风险"><a href="#再质押的风险" class="headerlink" title="再质押的风险"></a>再质押的风险</h3><ol>
<li><p><strong>智能合约风险</strong>：</p>
<ul>
<li>再质押涉及多个智能合约，每个智能合约都有可能存在漏洞或被攻击的风险。</li>
</ul>
</li>
<li><p><strong>流动性风险</strong>：</p>
<ul>
<li>衍生代币或流动性质押代币的市场流动性可能不足，导致在需要变现时价格波动较大。</li>
</ul>
</li>
<li><p><strong>复杂性风险</strong>：</p>
<ul>
<li>再质押增加了操作的复杂性，用户需要了解和管理多个平台和代币，可能会遇到操作失误或平台不兼容的问题。</li>
</ul>
</li>
</ol>
<h3 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h3><h4 id="1-提高收益率"><a href="#1-提高收益率" class="headerlink" title="1. 提高收益率"></a>1. <strong>提高收益率</strong></h4><h5 id="流动性质押（Liquid-Staking）"><a href="#流动性质押（Liquid-Staking）" class="headerlink" title="流动性质押（Liquid Staking）"></a>流动性质押（Liquid Staking）</h5><ul>
<li><strong>场景</strong>：用户质押ETH在Lido上，获得stETH。</li>
<li><strong>运用</strong>：用户可以将stETH再质押在其他DeFi协议中，如Aave或Compound，获取借贷利息或参与流动性挖矿，进一步提高收益率。</li>
</ul>
<h5 id="跨平台收益最大化"><a href="#跨平台收益最大化" class="headerlink" title="跨平台收益最大化"></a>跨平台收益最大化</h5><ul>
<li><strong>场景</strong>：用户质押资产在某个平台上获得收益，但发现另一个平台提供更高的收益率。</li>
<li><strong>运用</strong>：用户将质押资产转化为衍生代币后，转移到收益更高的平台进行再质押。</li>
</ul>
<h4 id="2-流动性增强"><a href="#2-流动性增强" class="headerlink" title="2. 流动性增强"></a>2. <strong>流动性增强</strong></h4><h5 id="跨链流动性提供"><a href="#跨链流动性提供" class="headerlink" title="跨链流动性提供"></a>跨链流动性提供</h5><ul>
<li><strong>场景</strong>：用户在以太坊上质押ETH，获得衍生代币。</li>
<li><strong>运用</strong>：用户将衍生代币通过跨链桥转移到其他区块链（如Polkadot或Binance Smart Chain），并在这些链上参与流动性池或借贷平台，提供流动性。</li>
</ul>
<h5 id="去中心化交易所（DEX）流动性挖矿"><a href="#去中心化交易所（DEX）流动性挖矿" class="headerlink" title="去中心化交易所（DEX）流动性挖矿"></a>去中心化交易所（DEX）流动性挖矿</h5><ul>
<li><strong>场景</strong>：用户质押资产获得流动性质押代币。</li>
<li><strong>运用</strong>：用户将这些流动性质押代币提供给去中心化交易所的流动性池，获得流动性挖矿奖励，同时保持资产流动性。</li>
</ul>
<h4 id="3-多重收益"><a href="#3-多重收益" class="headerlink" title="3. 多重收益"></a>3. <strong>多重收益</strong></h4><h5 id="合成资产生成"><a href="#合成资产生成" class="headerlink" title="合成资产生成"></a>合成资产生成</h5><ul>
<li><strong>场景</strong>：用户在某平台质押资产，获得衍生代币。</li>
<li><strong>运用</strong>：用户使用这些衍生代币在合成资产平台（如Synthetix）上生成合成资产（如sUSD或sBTC），再将合成资产用于交易或借贷，获得多重收益。</li>
</ul>
<h5 id="DeFi生态系统参与"><a href="#DeFi生态系统参与" class="headerlink" title="DeFi生态系统参与"></a>DeFi生态系统参与</h5><ul>
<li><p><strong>场景</strong>：用户质押ETH在Lido上，获得stETH。</p>
</li>
<li><p><strong>运用</strong>：用户使用stETH在Curve、Yearn等平台参与流动性挖矿、收益聚合等活动，获得平台奖励和交易费。</p>
</li>
</ul>
<h4 id="4-风险对冲"><a href="#4-风险对冲" class="headerlink" title="4. 风险对冲"></a>4. <strong>风险对冲</strong></h4><h5 id="衍生品交易"><a href="#衍生品交易" class="headerlink" title="衍生品交易"></a>衍生品交易</h5><ul>
<li><strong>场景</strong>：用户质押资产获得流动性质押代币。</li>
<li><strong>运用</strong>：用户使用这些代币在衍生品平台（如dYdX或Perpetual Protocol）进行杠杆交易或期权交易，对冲价格波动风险。</li>
</ul>
<h5 id="稳定币生成"><a href="#稳定币生成" class="headerlink" title="稳定币生成"></a>稳定币生成</h5><ul>
<li><p><strong>场景</strong>：用户质押ETH获得stETH。</p>
</li>
<li><p><strong>运用</strong>：用户在MakerDAO等稳定币生成平台上将stETH作为抵押品，生成DAI等稳定币，用于其他DeFi操作或风险对冲。</p>
</li>
</ul>
<h4 id="5-去中心化自治组织（DAO）治理"><a href="#5-去中心化自治组织（DAO）治理" class="headerlink" title="5. 去中心化自治组织（DAO）治理"></a>5. <strong>去中心化自治组织（DAO）治理</strong></h4><h5 id="提高投票权重"><a href="#提高投票权重" class="headerlink" title="提高投票权重"></a>提高投票权重</h5><ul>
<li><strong>场景</strong>：用户质押资产获得治理代币。</li>
<li><strong>运用</strong>：用户将治理代币再质押在治理平台上，提高在去中心化自治组织中的投票权重，影响平台决策。</li>
</ul>
<h5 id="提案创建和支持"><a href="#提案创建和支持" class="headerlink" title="提案创建和支持"></a>提案创建和支持</h5><ul>
<li><strong>场景</strong>：用户质押资产参与某DAO获得治理代币。</li>
<li><strong>运用</strong>：用户将治理代币再质押以创建或支持新的提案，提高提案通过的几率，积极参与治理。</li>
</ul>
<h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><p>通俗来说流动性质押代币（<strong>LST</strong>）代表质押 ETH 和累积奖励的代币化版本，流动性再质押代币（<strong>LRT</strong>）代表再质押 ETH 和累积奖励的代币化版本。相关项目 我之前整理过一篇  <a href="https://404ll.github.io/2024/05/10/AVS%E4%BB%A5%E5%8F%8AEigenLayer%E8%A7%A3%E6%9E%90/">Eigenlayer</a>的文章，有兴趣可以看看</p>
<p>具体深入了解,可以参考这篇(文章中还涉及了 质押与再质押的原理区别)</p>
<p> 📌<a href="https://foresightnews.pro/article/detail/55642">一文读懂「再质押 Restaking 」赛道</a></p>
<h2 id="比较好的信息网站"><a href="#比较好的信息网站" class="headerlink" title="比较好的信息网站"></a>比较好的信息网站</h2><p>📌<a href="https://foresightnews.pro/">foresight news</a></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>AVS以及EigenLayer解析</title>
    <url>/2024/05/10/%E5%8C%BA%E5%9D%97%E9%93%BE/AVS%E4%BB%A5%E5%8F%8AEigenLayer%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、-AVS赛道的逻辑和它出现的底层原因（Restaking与AVS到底有没有区别？各层级机制）"><a href="#一、-AVS赛道的逻辑和它出现的底层原因（Restaking与AVS到底有没有区别？各层级机制）" class="headerlink" title="一、 AVS赛道的逻辑和它出现的底层原因（Restaking与AVS到底有没有区别？各层级机制）"></a><strong>一、 AVS赛道的逻辑和它出现的底层原因（Restaking与AVS到底有没有区别？各层级机制）</strong></h2><p>AVS全称主动验证服务，其龙头是EigenLayer，在直播当天（北京时间2024年4月30日）刚刚公布了自己的代币计划。</p>
<h3 id="1-AVS赛道的逻辑及其底层原因"><a href="#1-AVS赛道的逻辑及其底层原因" class="headerlink" title="1. AVS赛道的逻辑及其底层原因:"></a>1. AVS赛道的逻辑及其底层原因:</h3><p>共识在区块链中至关重要，以太坊节点提供的服务在过去仅仅包括交易排序交易执行，但是其他服务来自于其他的服务商（跨链桥、预言机等等），其他的服务商资产量不够，所以很容易被攻击，最终导致了DApp的用户遭受损失。</p>
<p>AVS赛道的逻辑是通过将区块链本身的安全性桥接到主动验证服务商身上，利用以太坊的高级安全性来赋能这些服务商，从而将以太坊的安全性扩展到这些中间件身上。这样做的底层原因是为了弥补区块链中共识机制下的短板，使其得到补足。</p>
<h3 id="2-Eigenlayer代币经济学"><a href="#2-Eigenlayer代币经济学" class="headerlink" title="2. Eigenlayer代币经济学"></a><strong>2. Eigenlayer代币经济学</strong></h3><p>从分配的角度来看，超过一半（55%）的代币分配给了EigenLayer团队和投资者，而余下的分配给了社区；从应用的角度来看，EigenLayer代币的使用涉及到与DeFi协议的交互，其中可能包括借贷、交易和提供流动性等操作。但是代币分配给了少数人，这可能导致代币解锁后的抛售压力增加。</p>
<p><strong>空投</strong>：将再质押的代币九成给到平台交互用户，一成给到defi协议的用户，但是中国、美国的用户被限制。</p>
<p><strong>代币的价值</strong>：基于流通量和市值来推断，可能会有一定的不确定性。保守估计18元，目前场外9-12元</p>
<p><strong>Puffer是否被限制在10%：</strong>实际是一个误解。只是大户直接存入的量更大，导致他们挖得的积分比较多，从而分配到的空投也比较多。Puffer实际上并没有设定一个10%的限制，而是根据积分的累积来分配代币，大概只有10%来自于Defi那些东西。</p>
<h2 id="二．EigenLayer的锁仓逻辑"><a href="#二．EigenLayer的锁仓逻辑" class="headerlink" title="二．EigenLayer的锁仓逻辑"></a>二．<strong>EigenLayer的锁仓逻辑</strong></h2><p>EigenLayer的代币锁仓逻辑通过不可转移的代币和可质押的机制，建立稳定的社区基础，避免短期波动，以支持项目的长期发展。</p>
<ol>
<li><p>代币不可转移：在锁仓期间，代币持有者无法将其代币转移到其他地址或进行交易。避免短期内的代币大规模流通，从而稳定价格和社区生态。</p>
</li>
<li><p>质押机制：代币持有者可以选择将代币质押，尽管代币不可转移，但质押允许持有者保留代币的所有权，并获得相应的回报或权益。</p>
</li>
</ol>
<h2 id="三．为什么Eigenlayer-这么受关注？"><a href="#三．为什么Eigenlayer-这么受关注？" class="headerlink" title="三．为什么Eigenlayer 这么受关注？"></a><strong>三．为什么Eigenlayer 这么受关注？</strong></h2><ol>
<li><p>独特地位：作为AVS和Restaking项目的龙头，EigenLayer在DeFi领域占据了独特的地位</p>
</li>
<li><p>提供安全性保障：EigenLayer允许用户质押资产，为其他DeFi协议提供安全性保障</p>
</li>
<li><p>高度锁仓的代币设计：EigenLayer采取了措施确保代币的稳定性和可持续性，这对项目的长期发展产生积极影响。</p>
</li>
</ol>
<p><strong>五．AVS与模块化区块链有什么关联？</strong></p>
<p>AVS与模块化区块链都是为了提高区块链网络的效率和安全性而采取的一种方法。</p>
<p><strong>模块化区块链</strong>：将区块链网络的不同功能模块分离开来，使得每个模块可以独立运行，相互之间不产生影响。提高系统的可扩展性和灵活性，同时降低了开发和维护的难度。</p>
<p><strong>AVS</strong>：由于零知识证明的验证成本比较高，通过质押的方式提高节点执行作恶的成本，让应用更加安全，同时加快验证交易的速度。质押的代币可以被用来执行网络中的任务，并作为一种激励来防止恶意行为。提高区块链网络的安全性，同时也为参与者提供了一种获利的机会。</p>
<h2 id="四．EigenLayer和Restaking有什么比较好的方向？"><a href="#四．EigenLayer和Restaking有什么比较好的方向？" class="headerlink" title="四．EigenLayer和Restaking有什么比较好的方向？"></a><strong>四．EigenLayer和Restaking有什么比较好的方向？</strong></h2><ol>
<li><p>提供更有效率的解决方案：在市场上已有的服务效率较低的情况下，可以提供更有效率的解决方案。例如，结合密码学安全性和Restaking技术，对交易进行分类处理：采用零知识证明（zk）验证重要交易，采用Restaking验证一般性交易。这种方法可以让大量zk项目运作起来，提高整体效率。</p>
</li>
<li><p>与融资充足的项目合作：与已经融资充足且有潜力的项目合作，利用它们的业务机会。特别是在技术尚未成熟但市场机会已经出现的情况下，与这些项目合作，提供简单或者价值较低的交易验证服务，从而抓住市场机会。</p>
</li>
</ol>
<h2 id="五．Eigenlayer150-亿美金的锁仓量是否已经超过了-AvS-安全性的实际需求"><a href="#五．Eigenlayer150-亿美金的锁仓量是否已经超过了-AvS-安全性的实际需求" class="headerlink" title="五．Eigenlayer150 亿美金的锁仓量是否已经超过了 AvS 安全性的实际需求?"></a><strong>五．Eigenlayer150 亿美金的锁仓量是否已经超过了 AvS 安全性的实际需求?</strong></h2><p>这种情况可能是一个动态平衡。在项目初期，可能会有大量锁仓，主要是因为一些人想要获取更多的积分，而另一些人则想要做空。这导致了锁仓量的虚高。随着时间的推移，项目会发展壮大，空投活动逐渐减少，资金也会流向其他地方。因此，锁仓量可能会减少并达到一个动态平衡点。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="六．EigenLayer-为什么不选Solana而选择以太坊？"><a href="#六．EigenLayer-为什么不选Solana而选择以太坊？" class="headerlink" title="六．EigenLayer 为什么不选Solana而选择以太坊？"></a>六．EigenLayer <strong>为什么不选Solana而选择以太坊？</strong></h2><p>以太坊具有较长的共识历史，其安全性更高。同时以太坊网络上已经存在着大量的节点和质押资产，形成了一个相对稳定和安全的生态系统，这对于项目的发展和用户的信任至关重要。相比之下Solana的不确定性更大，安全性更低，流动性更差，Defi生态不太强</p>
<h2 id="七．ETH的EigenLayer和BTC的Babylon的区别是什么？"><a href="#七．ETH的EigenLayer和BTC的Babylon的区别是什么？" class="headerlink" title="七．ETH的EigenLayer和BTC的Babylon的区别是什么？"></a>七．ETH的EigenLayer和BTC的Babylon的区别是什么？</h2><p>EigenLayer和Babylon在解决的问题和定位上存在一些不同</p>
<p>Babylon致力于解决比特币的闲置和无法获得利息的问题。它通过一种名为”remo-staking”的操作，使得持有比特币的用户能够在不离开比特币网络的情况下参与质押，从而获得一定的收益。</p>
<p>EigenLayer更加关注以太坊网络上已经质押了资产的用户，为他们提供一个在不需要牺牲安全性的前提下，可以为其他中间层提供质押服务的机会，EigenLayer致力于解决以太坊网络中质押者的机会成本问题，以及降低中间层支付高昂资金成本的问题，从而提高质押网络的效率。</p>
]]></content>
      <categories>
        <category>区块链知识</category>
      </categories>
      <tags>
        <tag>Uweb笔记整理</tag>
      </tags>
  </entry>
  <entry>
    <title>Move on Aptos 初入门-研报</title>
    <url>/2024/06/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Move-on-Aptos-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>研报前言： 如有引用，文章结尾yml会附上相关文章的来源，同时会写出信息源便于读者证实，同时希望可以给投研新手提供一些帮助。</p>
</blockquote>
<h1 id="Move-on-Aptos-初入门"><a href="#Move-on-Aptos-初入门" class="headerlink" title="Move on Aptos - 初入门"></a>Move on Aptos - 初入门</h1><hr>
<h2 id="什么是-Aptos-？"><a href="#什么是-Aptos-？" class="headerlink" title="什么是 Aptos ？"></a>什么是 Aptos ？</h2><p>Aptos 是一个新兴的Layer1公链，脱胎于 Meta 的 Diem 和 Novi 项目，采用PoS（权益证明）机制，原生集成并使用 <em>Move 语言</em> 。Aptos 的设计注重安全性和可扩展性，通过独特的共识算法和并行执行技术，实现了高吞吐量、低延迟、安全可靠的特点。</p>
<p>Aptos 的目标是为开发者提供一个高效、安全、可扩展的区块链平台，推动区块链技术的进一步发展和应用。</p>
<h2 id="受人关注的技术亮点"><a href="#受人关注的技术亮点" class="headerlink" title="受人关注的技术亮点"></a>受人关注的技术亮点</h2><ul>
<li>采用Move语言</li>
<li>实现Aptos Keyless</li>
</ul>
<p>（Aptos创新性的技术远远不止这些，我只选取了部分技术进行解读）</p>
<p>这些技术的引进，使得Aptos在其他同类公链中获得了一定的竞争优势。</p>
<p>接下来让我们具体看看这些技术架构：</p>
<h2 id="全新的智能合约语言-Move"><a href="#全新的智能合约语言-Move" class="headerlink" title="全新的智能合约语言-Move"></a>全新的智能合约语言-Move</h2><p>Move是Meta为区块链开发量身定制的专有语言，Aptos 区块链从 Diem 区块链中继承使用并不断发展 Move。</p>
<h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a><strong>语言特点</strong></h3><p>Move语言是一种面向对象编程的语言，比较贴切地形容为“资源为一等公民”，Move 强调了资源的稀缺性、保存和访问控制，在Move语言中，资源（resources）是一种特殊的数据类型，表示对外部资源（如文件、网络连接等）的引用和操作，具有可复制 （ copy )、可索引 ( key )、可毁灭 ( drop )、可储存 ( store )等四个不同的属性。</p>
<p>通过进一步的学习，我认为与目前通用的智能合约语言（solidity，Rust)相比，Move语言上手的门槛相对较低， 它的语法更加的简单，编程模型也更加易懂。在实际编写的过程中比较突出的一点是：Move语言主要采用Module模型，在提高了组合性的同时使得系统的升级和优化变得更加简单。</p>
<h2 id="简化用户进入Web3世界-Aptos-Keyless"><a href="#简化用户进入Web3世界-Aptos-Keyless" class="headerlink" title="简化用户进入Web3世界-Aptos Keyless"></a>简化用户进入Web3世界-Aptos Keyless</h2><p>最近，账户抽象新标准—Aptos Keyless 正式在Aptos主网上线，可以说这是Aptos区块链<strong>里程碑式的更新</strong>。</p>
<p>在官方介绍中，Aptos Keyless 允许用户使用他们现有的谷歌账户来设置 Aptos 区块链账户，而不是使用传统的密钥或助记词，也就是说在Aptos上，用户不必特意创建钱包去交易，同时借助Google账号可以实现不同设备之间的丝滑使用。</p>
<hr>
<h3 id="Aptos-Keyless工作原理"><a href="#Aptos-Keyless工作原理" class="headerlink" title="Aptos Keyless工作原理"></a>Aptos Keyless工作原理</h3><p>Aptos Keyless 允许dapp使用 OIDC 提供商(如谷歌）进行用户身份验证，并生成一个包含用户身份、dApp 身份和临时公钥的<code>JWT</code>。通过用户身份和 dApp 身份的哈希值生成区块链账户地址。</p>
<p>签名的 <code>JWT</code> 将区块链地址绑定到 <code>EPK</code>(临时公钥），并将交易签名权限委托给 <code>EPK</code>。用户可以使用与其区块链账户关联的<code> EPK</code> 对交易进行签名。如果用户丢失了 <code>ESK</code>（临时私钥），他们可以通过 OIDC 提供商重新登录来获取新的 <code>EPK</code>。</p>
<blockquote>
<p>OIDC 提供商指的是Open Connect 提供商，允许客户端应用程序（如网站、移动应用等）使用认证和授权服务来验证终端用户的身份，并获取访问资源的权限，常见的 OIDC 提供商包括 Google、Microsoft、Auth0、Okta 等，它们为开发者和组织提供了便捷的身份验证和授权服务，帮助应用程序实现安全的用户身份验证和资源访问控制。</p>
</blockquote>
<hr>
<p>用户隐私方面：1. 不会透露用户google的邮件地址  2.对身份提供商隐藏用户的区块链地址和交易历史</p>
<p>目前面临的挑战是如何保持用户隐私，因为公开<code> JWT</code> 可能会泄露用户身份，而公开<code> EPK</code> 可能会允许 OIDC 提供商跟踪用户在链上的交易。</p>
<p>通过以上种种，我们足以窥见其革新性，传统繁琐的密钥管理和有“门槛”的Web3进入方式都将在这里得到解决。</p>
<h2 id="Aptos的特性"><a href="#Aptos的特性" class="headerlink" title="Aptos的特性"></a>Aptos的特性</h2><p>Aptos 框架由 Aptos 区块链的核心库和配置组成，被定义为一个可定期升级的模块包，同时Aptos通过引入Block-STM并行执行引擎、Quorum Store内存池协议和集成Move语言等技术，实现了高性能、低gas、可升级的伟大成果。利用模块化设计的思路对项目进行部署，更进一步保证了项目的安全性和可操作性。</p>
<h2 id="Aptos-与-Sui-有什么区别？"><a href="#Aptos-与-Sui-有什么区别？" class="headerlink" title="Aptos 与 Sui 有什么区别？"></a>Aptos 与 Sui 有什么区别？</h2><p>Aptos和Sui总是同时出现，那Sui到底与Aptos有什么关系呢？</p>
<p><strong>来源方面</strong>：与Aptos 不同，Sui 不是 Diem 的派生版本，而是从头开始构建，充分利用固有的可扩展性和快速结算能力提供高吞吐量、低延迟和经济实惠的计算资源。</p>
<p><strong>编程语言方面</strong>：Sui在原有的Move语言上添加了一个面向对象的存储系统，用于跟踪地址和交易等所有内容，更加有利于提供可扩展性。</p>
<p><strong>技术架构方面</strong>：更不同的是Sui 在其执行层中采用了 Narwhal 和 Tusk 的共识技术来实现并行化。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过初步的了解，我们知道了Aptos的大致技术架构和展望，值得期待的是 Move语言是否会在未来获得更多的曝光量，而Aptos会不会迎来下一波牛市的崛起也让人拭目以待。</p>
<p>目前Aptos正在发力培育亚太和华语地区的开发生态，目不暇接的共学营和黑客松也在等待着爱好者和开发者的垂青，同时处于早期发展阶段的 Aptos 也会提供相当多的建设机会给真正的信仰者，一起”Move on Aptos”!</p>
<hr>
<p><a href="https://www.notion.so/buidlerdao/Aptos-Web3-fa04fe55b4364594ad0ee20e429cb3f6">Aptos官方白皮书（Notion在线阅读）</a><br>有关Sui与Aptos区别: <a href="https://foresightnews.pro/article/detail/38911">https://foresightnews.pro/article/detail/38911</a><br>有关Aptos Keyless: <a href="https://mp.weixin.qq.com/s?__biz=Mzg4NDYwOTQwNw==&mid=2247485476&idx=1&sn=2acad9ada9173b15aa75d8d766d94a61&chksm=ce47ff5b0a0e64cf430937879db62428b98dfef3d1bc146b3d68a32150cfcee3f56284da42c2&scene=126&sessionid=1718803508#rd">https://mp.weixin.qq.com/s?__biz=Mzg4NDYwOTQwNw==&amp;mid=2247485476&amp;idx=1&amp;sn=2acad9ada9173b15aa75d8d766d94a61&amp;chksm=ce47ff5b0a0e64cf430937879db62428b98dfef3d1bc146b3d68a32150cfcee3f56284da42c2&amp;scene=126&amp;sessionid=1718803508#rd</a><br>我的信息源:<br>    -foresight news  <a href="https://foresightnews.pro/">https://foresightnews.pro/</a><br>    -Aptos官网  <a href="https://aptosfoundation.org/">https://aptosfoundation.org/</a> </p>
]]></content>
      <tags>
        <tag>研报</tag>
      </tags>
  </entry>
  <entry>
    <title>Aptos学习资源</title>
    <url>/2024/06/22/%E5%8C%BA%E5%9D%97%E9%93%BE/Aptos%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="Aptos学习资源"><a href="#Aptos学习资源" class="headerlink" title="Aptos学习资源"></a>Aptos学习资源</h1><h2 id="我的整理"><a href="#我的整理" class="headerlink" title="我的整理"></a>我的整理</h2><ul>
<li>Aptos入门研报 [<a href="https://404ll.github.io/2024/06/20/%E5%8C%BA%E5%9D%97%E9%93%BE/Move-on-Aptos-%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%85%A5%E9%97%A8/">Move on Aptos 初入门-研报 | Elemen的象牙塔 (404ll.github.io)</a>]</li>
</ul>
<h2 id="共学营学员资料"><a href="#共学营学员资料" class="headerlink" title="共学营学员资料"></a>共学营学员资料</h2><blockquote>
<p>以下收录了Move On Aptos 共学营的全部资料</p>
</blockquote>
<ul>
<li><a href="https://alcove-pro.notion.site/Move-on-Aptos-alcove-bc0e60f57caa4f2195e06f89bfaedf8e?pvs=4">Notion资料</a> 这个资料包括了新手入门的了解和各种文档，以及课程的代码</li>
<li><a href="https://drive.google.com/drive/folders/1-EmZXvuPuVH60XmbmFxUg1jDm6-uDDG2">Google 云盘共学视频</a> 视频包括了Move语法的学习和实战，节奏很慢，适合学习</li>
<li><a href="https://aptos.dev/">Aptos开发者文档</a> 文档比较详细的说明了如何安装环境和一些进阶语法，英文版可以配合谷歌浏览器的自动翻译</li>
</ul>
<p>还有一段共学老师说的话，我觉得很有道理，所以分享出来:</p>
<p>“刚学一门语言会遇到很多新的语法和新的库接口，这是一定的。</p>
<p>最好的方法是把代码逐行解读，把每一行弄懂（可以通过写注释，或者打印在纸上），这样坚持看 3 个项目的源码，就可以自己仿照着写项目了。</p>
<p>写项目的时候又会遇到一些新的需求，就需要去看文档&#x2F;源码，等项目做出来了，这个时候你对一个语言的基本世界观就形成了。</p>
<p>学新语言，忌求快。</p>
<p>时刻牢记，慢就是快。”</p>
]]></content>
      <tags>
        <tag>资源收录</tag>
      </tags>
  </entry>
  <entry>
    <title>扫盲小知识之 Roll-up</title>
    <url>/2024/05/21/%E5%8C%BA%E5%9D%97%E9%93%BE/Roll-up/</url>
    <content><![CDATA[<h1 id="什么是-Roll-up"><a href="#什么是-Roll-up" class="headerlink" title="什么是 Roll-up ?"></a>什么是 Roll-up ?</h1><blockquote>
<p>Roll-up是一种Layer 2扩展解决方案，旨在提高以太坊网络的吞吐量和效率。<strong>它通过将大量的交易数据压缩成少量的摘要信息，然后将这些摘要信息提交到以太坊主链上，以实现高性能的链上交易处理。</strong></p>
<p><strong>人话就是</strong> :  把以太坊上几百笔交易打包带走，并在验证通过后只向以太坊主网输出一笔交易。</p>
</blockquote>
<p> 具体可以看看这篇文章：<a href="https://foresightnews.pro/article/h5Detail/59078">https://foresightnews.pro/article/h5Detail/59078</a></p>
<p>Roll-up通常分为这几种类型：</p>
<ol>
<li><p><strong>Optimistic Roll-up（乐观 Roll-up）</strong>:  默认打包的这些交易每一笔都是准确无误的，因此会直接进入验证。但为了防止错误交易混入其中，乐观证明引入了挑战者机制，就是说在验证的一定期限内，其他人可以怀疑其中的交易并在以太坊上比对这笔交易是否合法。如果挑战成功，挑战者就可以获得收益，验证者就会被罚没质押在协议上的资金。</p>
</li>
<li><p><strong>ZK-Rollup（零知识 Roll-up）</strong></p>
<p>​     在ZK-Rollup中，交易的验证过程使用了零知识证明技术，可以在不暴露具体交易内容的情况下证明交易的有效性。这样可以进一步减少在主链上的数据量，并提高隐私性和效率.</p>
</li>
</ol>
<p>Roll-up技术的引入为以太坊网络提供了一种高效的扩展方案，可以大幅提升网络的吞吐量和性能，同时降低交易成本，并为更多的去中心化应用提供了支持。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>sui-move学习笔记</title>
    <url>/2024/09/30/%E5%8C%BA%E5%9D%97%E9%93%BE/sui-move%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<p>参考资料：</p>
<ul>
<li><p>基本语法 ：<a href="https://www.bilibili.com/video/BV1Rm42177Kx/">https://www.bilibili.com/video/BV1Rm42177Kx/</a></p>
</li>
<li><p>相关书籍：</p>
<ul>
<li>轻松入门：<a href="https://easy.sui-book.com/chapter_1.html">https://easy.sui-book.com/chapter_1.html</a> </li>
<li>Move参考手册：<a href="https://reference.sui-book.com/introduction.html">https://reference.sui-book.com/introduction.html</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量这一章比较简单， <a href="https://reference.sui-book.com/packages.html">轻松入门sui</a>: <a href="https://reference.sui-book.com/packages.html">https://reference.sui-book.com/packages.html</a> 中写得也非常详细！</p>
<p>let _a &#x3D; 10u32;&#x2F;&#x2F;下划线开头，表示后续没有使用</p>
<h1 id="包-模块-方法"><a href="#包-模块-方法" class="headerlink" title="包-模块-方法"></a>包-模块-方法</h1><p><strong>包</strong>：包是同一个合约地址包含的全部代码的集合，由很多模块组成，也就是<code>sui move new &lt;name&gt;</code>生成的文件夹</p>
<p>a_move_package<br>├── Move.toml      (必需)<br>├── Move.lock      (生成的)<br>├── sources        (必需)<br>├── doc_templates  (可选)<br>├── examples       (可选，测试和开发模式)<br>└── tests          (可选，测试模式)</p>
<blockquote>
<p>有关包下具体的配置信息，可以参见 </p>
</blockquote>
<p><strong>模块</strong>-module：代码模块是代码划分访问权限和代码的组织方式</p>
<p>创建格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">module &lt;address&gt;::&lt;name&gt;&#123;<br>  use sui::tx_context::TxContext;<br>  fun init(ctx: &amp;mut TxContext) &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="方法访问权限控制"><a href="#方法访问权限控制" class="headerlink" title="方法访问权限控制"></a><strong>方法访问权限控制</strong></h2><p>我把这里的方法理解为其他语言中的函数</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>调用范围</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>fun  call()</td>
<td>只能模块内调用</td>
<td>可以有</td>
</tr>
<tr>
<td>public fun call()</td>
<td>全部合约能调用</td>
<td>可以有</td>
</tr>
<tr>
<td>public entry fun call()</td>
<td>全部合约和Dapp(RPC)能调用</td>
<td>无</td>
</tr>
<tr>
<td>entry fun call()</td>
<td>只能Dapp(RPC)调用</td>
<td>无</td>
</tr>
<tr>
<td>public(package) fun call()</td>
<td>只能当前的包能调用</td>
<td>可以有</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">fun a()&#123;<br>&#125;<br>//全局可调用<br>public fun b()&#123;<br>&#125;<br>//只能声明package的包可调用（当前包也可调用） <br>public(package) fun c()&#123;&#125;<br>//全部合约和Dapp(RPC)能调用<br>public entry fun d()&#123;<br>&#125;<br><br>public  fun f(a:u32, b:u32): bool&#123;<br>   a &gt; b<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>init 方法</strong></p>
<p>只能是私有的</p>
<p>会在发布合约的是时候自动调用一次</p>
<p>只有两种形式</p>
<ul>
<li><p><strong>fun</strong> <strong>init (ctx: &amp;mut TxContext){}</strong></p>
</li>
<li><p><strong>fun init (witness: Struct, ctx: &amp;mut TxContext) {}</strong></p>
</li>
</ul>
<h1 id="引用-注释"><a href="#引用-注释" class="headerlink" title="引用-注释"></a>引用-注释</h1><p>mut: 可变引用 </p>
<p>&amp;：不可变引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">let mut a: u32 = 32;//mut表示 后续会改变它<br>a = 64;<br><br></code></pre></td></tr></table></figure>

<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>这里比较简单，与其他语言差不多，结合代码学习很快就能上手</p>
<p>if-条件语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">if (condition) true_branch // implied default: else ()<br>if (condition) true_branch else ()<br><br><br>// x and y must be u64 integers<br>//这里意思为 x&gt;y时,返回x; x&lt;y时,返回y<br>let maximum: u64 = if (x &gt; y) x else y;<br><br>// ERROR! branches different types<br>let z = if (maximum &lt; 10) 10u8 else 100u64;<br><br></code></pre></td></tr></table></figure>

<p>while-循环语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">fun sum(n: u64): u64 &#123;<br>   let mut sum = 0;<br>   let mut i = 1;<br>   while (i &lt;= n) &#123;<br>       sum = sum + i;<br>       i = i + 1<br>   &#125;;<br><br>   sum<br>&#125;<br></code></pre></td></tr></table></figure>

<p>break-跳出循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">fun min_factor(n: u64): u64 &#123;<br>   let mut i = 2;<br>   while (i &lt;= n) &#123;<br>       if (n % i == 0) break;<br>       i = i + 1<br>   &#125;;<br><br>   i<br>&#125;<br></code></pre></td></tr></table></figure>

<p>continue-跳过当前条件的循环，直接进入下一个<code>应该进入循环</code>的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">fun sum(n: u64): u64 &#123;<br>   let mut sum = 0;<br>   let mut i = 0;<br>   while (i &lt; n) &#123;<br>       i = i + 1;<br>       if (i % 20 == 0) continue;<br>       sum = sum + i;<br>   &#125;;<br><br>   sum<br>&#125;<br></code></pre></td></tr></table></figure>



<p>loop-只有遇到break时才跳出循环</p>
<p>相当于 c语言中的while(1)，这里等价于while(true)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">fun sum(n: u64): u64 &#123;<br>   let mut sum = 0;<br>   let mut i = 0;<br>   loop &#123;<br>       i = i + 1;<br>       if (i &gt; n) break;<br>       sum = sum + i<br>   &#125;;<br>   sum<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="结构体-所有权-对象"><a href="#结构体-所有权-对象" class="headerlink" title="结构体-所有权-对象"></a>结构体-所有权-对象</h1><h2 id="struct-结构体"><a href="#struct-结构体" class="headerlink" title="struct-结构体"></a>struct-结构体</h2><p>结构体是自定义类型，由字段组成，可以简单地理解成”key-value”存储，其中 key 是字段的名称，而 value 是存储的内容，使用关键字 struct 定义，可以为空。</p>
<p>注：结构体只能在模块内部定义，并且以关键字 <strong>public</strong> <strong>struct</strong> 开头，结构体名称首字母需要大写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move"> public struct NAME &#123;<br>    FIELD1: TYPE1,<br>    FIELD2: TYPE2,<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="UTXO"><a href="#UTXO" class="headerlink" title="*UTXO"></a>*UTXO</h2><p>每个交易产生一个或多个UTXO，每一个UTXO都对应者一个ID，代表未花费的金额，可以简单理解为你的零钱。</p>
<p>sui基于UTXO模型</p>
<h2 id="object-对象"><a href="#object-对象" class="headerlink" title="object-对象"></a>object-对象</h2><p>对象在Sui上存储，维护了一个全局的Map数据结构 Map&lt;ID,object&gt;， id 是唯一的，通过这个唯一的id 查找到object。</p>
<p>sui上的<strong>资产</strong>都是对象，对象可以相互嵌套，所有的对象都是全局存储。</p>
<h3 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h3><ul>
<li><p><strong>必须有</strong> <strong>key</strong> <strong>能力</strong></p>
</li>
<li><p>必须第一个字段 是id,而且类型为<strong>sui::object::UID</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">module book::obj &#123;<br>    use sui::object::UID;<br>    public struct Obj has key &#123;<br>        id:UID,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h1><h2 id="定义资产"><a href="#定义资产" class="headerlink" title="定义资产"></a>定义资产</h2><p>资产也就是个人拥有所有权的物品合集</p>
<p> <strong>常见资产</strong>：银行余额，支付宝微信余额，房产等。</p>
<h2 id="资产所有权"><a href="#资产所有权" class="headerlink" title="资产所有权"></a>资产所有权</h2><p>资产所有权可以分为：独有资产和共有资产，拥有所有权，则可以改变、删除、增加资产内容。</p>
<p>在Object中可以用关键字来标记所有权的类型，也就是<strong>能力</strong>，具体在下一章</p>
<p>分为：</p>
<ul>
<li>key</li>
<li>copy </li>
<li>drop</li>
<li>store</li>
</ul>
<h2 id="所有权在函数之间的三种传递方式"><a href="#所有权在函数之间的三种传递方式" class="headerlink" title="所有权在函数之间的三种传递方式"></a>所有权在函数之间的三种传递方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">fun f(consume: T, write: &amp;mut T, read: &amp;T)<br>T: transfer, delete, write, read//权限最高<br>&amp;mut T: write, read<br>&amp;T: read<br>//示例<br>    public fun del(dog:Dog)&#123;<br>        let Dog&#123;id,gender,age&#125; = dog;<br>        object::delete(id);<br>    &#125;<br><br>    public fun transfer(dog: &amp;mut Dog,age:u8)&#123;<br>        dog.age = 18<br>    &#125;<br><br>    public fun view_dog(dog:Dog)&#123;<br>        dog.age<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="所有权的方法"><a href="#所有权的方法" class="headerlink" title="所有权的方法"></a>所有权的方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>生成的方法</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>transfer</td>
<td>独享对象</td>
<td>key</td>
</tr>
<tr>
<td>public_transfer</td>
<td>独享对象</td>
<td>key + store</td>
</tr>
<tr>
<td>freeze_object</td>
<td>共享对象 - 常量</td>
<td>key</td>
</tr>
<tr>
<td>public_freeze_object</td>
<td>共享对象 - 常量</td>
<td>key + store</td>
</tr>
<tr>
<td>share_object</td>
<td>共享对象</td>
<td>key</td>
</tr>
<tr>
<td>public_share_object</td>
<td>共享对象</td>
<td>key + store</td>
</tr>
</tbody></table>
<h1 id="能力-Event-常量错误处理"><a href="#能力-Event-常量错误处理" class="headerlink" title="能力-Event-常量错误处理"></a>能力-Event-常量错误处理</h1><h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><p>四种能力可以相互组合</p>
<ul>
<li>key - 被值修饰的键可以对全局进行访问。</li>
<li>copy - 被修改的值可以被复制。</li>
<li>drop - 被成员函数在作用域结束时被丢弃。</li>
<li>store被修改的建议 存储在紧急情况下</li>
</ul>
<p>没有任何能力：只能存活在同一个交易中</p>
<p>只有key：对象，自定义转移规则，对象有全局ID，可以被全局存储和查找（实现灵魂绑定）</p>
<p>只有drop：被修饰的值在离开作用域的时候会被自动解构 (删除)，基本数据类型默认实现了drop</p>
<p>只有store：没法使用所有权，可以通过放在其他结构体中来实现所有权的使用，实现结构体的嵌套</p>
<p>key + store：对象，可以被任意转移，不被转移规则限定，对象有全局ID，可以被全局存储和查找</p>
<p><font color="red">注<p>：</p>
<ul>
<li>key 和 dorp 不能同时存在，也就是对资产进行操作后，不会销毁资产</li>
<li>key 和 copy不能同时存在，也就是资产不可复制</li>
</ul>
<h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>打印日志：copy+drop</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>不会更改的量即为常量，创建常量<code>const Name : Type = Value</code></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul>
<li><p>abort 配合if语句来终止程序</p>
</li>
<li><p>assert!(num&gt;10,ErrMustGet10) 断言，不满足条件时报错</p>
</li>
<li><p>debug 调试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">module std::debug &#123;<br>//打印数值<br>   native public fun print&lt;T&gt;(x: &amp;T);<br>//打印当前堆栈<br>   native public fun print_stack_trace();<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型是具体类型或其他属性的抽象替代品，使得在编写 Move 代码时提供更强的灵活性，并避免逻辑重复。</p>
<p>我理解的泛型，就是在起初定义结构体&#x2F;方法时<strong>不定义其类型</strong>，在后续使用时再定义类型。这样一个语句就能被多次使用，从而避免了重复定义类似的结构体。</p>
<p>结构体泛型示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">module generics::obj_generics &#123;<br>    public struct Box&lt;T&gt; &#123;<br>        value: T<br>    &#125;<br><br>//定义多个泛型<br>public struct Box&lt;T,Y,X&gt; &#123;<br>        value1: T,<br>        value2: Y,<br>    &#125;<br>  &#125;<br>  <br> //使用泛型<br> fun init(ctx:&amp;mut TxContext)&#123;<br> <br> let box = Box&lt;u8,u16&gt;&#123;<br> 	value1:23,<br> 	value2:45,<br> 	&#125;;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>方法泛型示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">module generics::generics &#123;<br><br>   public struct Box&lt;T&gt; &#123;<br>       value: T<br>   &#125;<br>  <br>   public fun create_box&lt;T&gt;(value: T): Box&lt;T&gt; &#123;<br>       Box&lt;T&gt; &#123; value &#125;<br>   &#125;<br>   //伪代码<br>   let box:Box&lt;u32&gt; = create_box&lt;u32&gt;&#123;value:1u32&#125;<br>   let box:Box&lt;u32&gt; = create_box&lt;_&gt;&#123;value:1u32&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="泛型的能力限制"><a href="#泛型的能力限制" class="headerlink" title="泛型的能力限制"></a>泛型的能力限制</h2><p>通过store、drop、key、copy，对泛型进行约束(区别一下泛型的约束和能力的约束)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">public struct Box3&lt;T: store + drop，Y:store&gt; has key, store &#123;<br>   id:UID,<br>   value: T,<br>   value2:X,<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="泛型如何传参"><a href="#泛型如何传参" class="headerlink" title="泛型如何传参"></a>泛型如何传参</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">sui client call --package $PACKAGE --module $MODULE --function &quot;create_box&quot; --args $OBJECT_ID --type-args &quot;0x2::coin::Coin&lt;0x2::sui::SUI&gt;&quot; --gas-budget 100000000<br></code></pre></td></tr></table></figure>

<h2 id="phanton-泛型"><a href="#phanton-泛型" class="headerlink" title="phanton 泛型"></a>phanton 泛型</h2><p>申明一个类型参数但并不使用它，用于区分或者约束</p>
<p>(这个我还不是很清晰，后续会补充一下)</p>
<p>使用场景：</p>
<ul>
<li><p>泛型未被使用</p>
</li>
<li><p>容器能力规则不满足</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">public struct Box &lt;phanton T&gt; has store&#123;<br>	value: u64<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote>
<p>这一节主要结合代码学习：<a href="https://github.com/404ll/letsmove/tree/main/tutorial/bootcamp/08_design_pattern">https://github.com/404ll/letsmove/tree/main/tutorial/bootcamp/08_design_pattern</a></p>
<p>我没有将过多的代码放上来，建议自己手搓学，多写注释。</p>
</blockquote>
<h2 id="Capability-权限设计模式"><a href="#Capability-权限设计模式" class="headerlink" title="Capability 权限设计模式"></a>Capability 权限设计模式</h2><p><code>public struct AdminCap has key &#123; id: UID &#125;</code></p>
<p>当你需要对结构体进行一些操作时，必须由传入这个结构体的实例来<strong>验证你是不是有这个权限</strong>，这个权限一般来说是一个有key能力的object，同时可以适当加上store能力，可以多次使用。</p>
<p>实际上就是实施权限控制，有权限的人才可以调用该操作</p>
<p>具体示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">module design_pattern::capability &#123;<br>    use std::string::&#123;Self,String&#125;;<br>    use sui::transfer<br>    use sui::object::&#123;Self, UID&#125;;<br>    use sui::tx_context::&#123;Self,TxContext&#125;;<br>    <br>//生成管理员权限结构体<br>    public struct AdminCap has key &#123; id: UID &#125;<br>//类似于NFT的类型<br>    public struct Item has key, store &#123; id: UID, name: String &#125;<br>//创建一个管理员权限，并传递给发行者<br>    fun init(ctx: &amp;mut TxContext) &#123;<br>        let my_address =  ctx.sender();<br>        let addmin_cap = AdminCap &#123;<br>            id: object::new(ctx)<br>        &#125;;<br>        //将权限转移transfer::transfer(addmin_cap, my_address);<br>        let addmin_cap2 = AdminCap &#123;<br>            id: object::new(ctx)<br>        &#125;;        transfer::transfer(addmin_cap2, @0x1111);<br><br>    &#125;<br>    //运行示例<br>    public fun create_and_send(<br>    //检验<br>        _: &amp;AdminCap, name: vector&lt;u8&gt;, to: address, ctx: &amp;mut TxContext<br>    ) &#123;<br>        transfer::transfer(Item &#123;<br>            id: object::new(ctx),<br>            name: name.to_string()<br>        &#125;, to)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="witness-见证者设计模式"><a href="#witness-见证者设计模式" class="headerlink" title="witness 见证者设计模式"></a>witness 见证者设计模式</h2><p><code>public struct Name has drop &#123;&#125;</code></p>
<p>简单理解为 这个结构体（资源）创建出来的实例是为了<code>见证</code>另一个资源的创建，类似于做标记。</p>
<p><font color="red">注<font>：此结构体没有字段，只有drop（销毁）能力，实例只能使用一次</font></font></p>
<p>示例代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move"><br>module design::guardian &#123;<br><br>    public struct Guardian&lt;phantom T: drop&gt; has key, store &#123;<br>        id: UID<br>    &#125;<br><br>    public fun create_guardian&lt;T: drop&gt;(<br>    //做标记，见证Guardian资源的创建<br>        _witness: T, ctx: &amp;mut TxContext<br>    ): Guardian&lt;T&gt; &#123;<br>        Guardian &#123; id: object::new(ctx) &#125;<br>    &#125;<br>    //结束后删除<br>&#125;<br><br>module design::peace_guardian &#123;<br>    use design::guardian;<br><br>    public struct PEACE has drop &#123;&#125;<br><br>    fun init(ctx: &amp;mut TxContext) &#123;<br>//生成对应的示例<br>        let peace = PEACE&#123;&#125;;<br>        transfer::public_transfer(<br>            guardian::create_guardian(peace, ctx),<br>            ctx.sender()<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="one-time-witness-见证者模式"><a href="#one-time-witness-见证者模式" class="headerlink" title="one-time-witness 见证者模式"></a>one-time-witness 见证者模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">public struct OTW has drop &#123;&#125;<br>types::is_one_time_witness(&amp;witness)<br></code></pre></td></tr></table></figure>

<p>该结构体是一个特殊的见证者：同一个包下面的同一个结构体，只能创建出来一个实例来做 ‘见证’ ，同一个结构体只能用一次，不然会报错。例如创建一个<code>Coin</code>，一条链对应一个<code>Coin</code></p>
<p><font color="red">注<font>：名称必须与包的名字完全相同，并且全部大写；没有字段，只有drop（销毁）能力；通过<code>fun init (witness: Struct, ctx: &amp;mut TxContext) &#123;&#125;</code> 传入</font></font></p>
<h3 id="Transferable-Witness-可以转移见证者模式"><a href="#Transferable-Witness-可以转移见证者模式" class="headerlink" title="Transferable Witness 可以转移见证者模式"></a>Transferable Witness 可以转移见证者模式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">public struct WITNESS has store, drop &#123;&#125;<br>public struct WitnessBox has key &#123; id: UID, witness: WITNESS &#125;<br></code></pre></td></tr></table></figure>

<p>这见证者结构体可以创建后放在一个容器里面，随着容器转移所有权，需要用到的时候在取出来做见证</p>
<p><font color="red">注<font>： 结构体没有字段，只有drop（销毁）和store（实现存储）和能力，需要一个object的容器来包装，存储在链上。</font></font></p>
<h2 id="hot-potato-设计模式"><a href="#hot-potato-设计模式" class="headerlink" title="hot-potato 设计模式"></a>hot-potato 设计模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">public struct Receipt &#123; price: u64 &#125;<br><br>public fun create(xx:XX,...):(Receipt&#123;&#125;,Coin&lt;x&gt;)<br><br>public fun burn(rece:Receipt,...)<br><br></code></pre></td></tr></table></figure>

<p>用这个结构体<code>public struct Receipt &#123; price: u64 &#125;</code>来检测是否符合交易的条件，防止别人盗走资源。</p>
<p>简单理解就是烫手的山芋，你拿到手里肯定处理不了，所以你只能还回去 </p>
<p><font color="red">注<font>：结构体没有任何能力，提供对外方法来<strong>创建</strong>结构体和<strong>销毁</strong>结构体。</font></font></p>
<h3 id="hot-potato具体例子-闪电贷"><a href="#hot-potato具体例子-闪电贷" class="headerlink" title="hot-potato具体例子-闪电贷"></a>hot-potato具体例子-闪电贷</h3><p>闪电贷的特点</p>
<ul>
<li><p>在一个交易里面必须完成借和还</p>
</li>
<li><p>无需抵押</p>
</li>
<li><p>不还款一定会报错</p>
</li>
<li><p>主要用于套利和加杠杆</p>
</li>
</ul>
<p>借款人通过智能合约请求贷款，在同一交易中利用这笔贷款进行各种操作，如投资、交易或其他金融活动，同时借款人必须在同一交易中将贷款金额与利息（gas fee)还清。如果借款人未能按时还款或不按协议还款，整个交易将被取消，贷款金额将被返还给贷款提供方，这时借款人仍然需要支付<code>gas fee</code></p>
<blockquote>
<p>闪电贷的具体研究可以看看这篇文章：</p>
<p>[闪电贷详解]: <a href="https://academy.binance.com/zh/articles/what-are-flash-loans-in-defi#how-does-a-flash-loan-work">https://academy.binance.com/zh/articles/what-are-flash-loans-in-defi#how-does-a-flash-loan-work</a>	“什么是defi中的闪电贷？”</p>
</blockquote>
<h1 id="Sui-framework"><a href="#Sui-framework" class="headerlink" title="Sui_framework"></a>Sui_framework</h1><p>建议去官方的库中查看学习</p>
<blockquote>
</blockquote>
<p>Sui_framework，是Sui-move编程功能的合集，有很多相关的库</p>
<ul>
<li>deepbook</li>
<li>move-stdlib 标准库</li>
<li>sui-framework</li>
<li>sui-system</li>
</ul>
<h2 id="Balance-Coin-Token-定义及特点"><a href="#Balance-Coin-Token-定义及特点" class="headerlink" title="Balance&#x2F;Coin&#x2F;Token-定义及特点"></a>Balance&#x2F;Coin&#x2F;Token-定义及特点</h2><ul>
<li>Balance：一个通用的余额可存储处理程序。在Coin 模块中用于允许余额操作，并可用于实现具有Supply 和 Balance 的自定义货币。</li>
<li>Coin：定义了 Coin类型-表示可互换的令牌和货币的平台范围内的表示。Coin 可以被描述为围绕Balance 类型的安全包装器。</li>
<li>Token: Token 模块实现了一个可配置的闭环令牌系统。该策略由一组规则定义，必须满足这些规则才能对令牌执行操作。</li>
</ul>
<p>Token的产生是由Coin抽象出来，限制<code>Coin的自由转发</code></p>
<table>
<thead>
<tr>
<th>Module</th>
<th>Main type</th>
<th>Capability</th>
<th>Abilities</th>
</tr>
</thead>
<tbody><tr>
<td>sui::balance</td>
<td>Balance<T></T></td>
<td>Supply<T></T></td>
<td>store</td>
</tr>
<tr>
<td>sui::coin</td>
<td>Coin<T></T></td>
<td>TreasuryCapT&gt;</td>
<td>key + store</td>
</tr>
<tr>
<td>sui:: token</td>
<td>Token<T></T></td>
<td>TreasuryCap<T></T></td>
<td>key</td>
</tr>
</tbody></table>
<h2 id="display-standard-NFT"><a href="#display-standard-NFT" class="headerlink" title="display standard -NFT"></a>display standard -NFT</h2><ul>
<li><p><strong>name（名称）</strong> - 对象的名称。用户查看对象时显示此名称。</p>
</li>
<li><p><strong>description（描述）</strong> - 对象的描述。用户查看对象时显示此描述。</p>
</li>
<li><p><strong>link（链接）</strong> - 用于应用程序中的对象链接。</p>
</li>
<li><p><strong>image_url（图片链接）</strong> - 对象的图像链接，可以是URL或者图像的二进制数据。</p>
</li>
<li><p><strong>thumbnail_url（缩略图链接）</strong> - 用作钱包、浏览器和其他产品中的预览的小图像的URL。</p>
</li>
<li><p><strong>project_url（项目链接）</strong> - 与对象或创建者相关联的网站链接。</p>
</li>
<li><p><strong>creator（创建者）</strong> - 表示对象创建者的字符串信息。</p>
</li>
</ul>
<p>NFT &#x3D; Object + Display</p>
<p>Sui Object Display 是一种模板引擎，可以实现对类型的链上管理与链下表示（显示）的模板化。通过它，你可以将对象的数据替换为模板字符串。该标准不限制你可以设置的字段。你可以使用｛property｝语法访问所有对象属性，然后将它们作为模板字符串的一部分插入其中。</p>
<h3 id="Kiosk"><a href="#Kiosk" class="headerlink" title="Kiosk"></a>Kiosk</h3><blockquote>
<p>具体介绍：<a href="https://docs.sui.io/standards/kiosk">https://docs.sui.io/standards/kiosk</a></p>
</blockquote>
<h2 id="Unit-Test-单元测试"><a href="#Unit-Test-单元测试" class="headerlink" title="Unit Test(单元测试)"></a>Unit Test(单元测试)</h2><ul>
<li>#[test]-只跑一遍某个函数</li>
<li>#[test_only]-工具函数，只在测试的时候才被编译</li>
<li>#[expect_failure(abort_code &#x3D; test_sui_hello ::my_coin::ENotlmplemented)]-测试指定函数，报出指定的错误，可以理解为用错误条件来检验程序是否正确</li>
</ul>
<p>使用前文的Print()来调试</p>
<h1 id="Coin协议"><a href="#Coin协议" class="headerlink" title="Coin协议"></a>Coin协议</h1><p>Coin有两种所有权：</p>
<ul>
<li>独有所有权：<code>public_transfer(treasury_cap,sender(ctx))</code></li>
<li>共享所有权： <code>public_share_object(treasury_cap)</code></li>
</ul>
<p>ps: 代码来自官方标准库</p>
<p>生成一个Coin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">module examples::my_coin &#123;<br>    use sui::coin::&#123;Self, TreasuryCap&#125;;<br><br>    public struct MY_COIN has drop &#123;&#125;<br>//采用一次见证<br>    fun init(witness: MY_COIN, ctx: &amp;mut TxContext) &#123;<br>        let (treasury, metadata) = coin::create_currency(witness, 6, b&quot;MY_COIN&quot;, b&quot;&quot;, b&quot;&quot;, option::none(), ctx);<br>        //所有权共享 不可变共享<br>        transfer::public_freeze_object(metadata);<br>        //向合约发布者共享所有权<br>        transfer::public_transfer(treasury, ctx.sender())<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们一步一步的认识这个函数</p>
<p>使用<code>coin::create_currency</code>时，创建硬币的智能合约的发布者会收到一个<code>TreasuryCap</code>对象和<code>Coin元数据</code>。该<code>TreasuryCap</code>对象是铸造新硬币或销毁现有硬币所必需的。</p>
<p>同时<code>TreasuryCap</code>对象是可转让的，因此如果您转让该对象，第三方可以接管您创建的代币的管理<code>TreasuryCap</code>。但是，在转让该功能后，您将无法再自行铸造和销毁代币。</p>
<p>还有很多其他功能：这里就不一一列举了，建议用文档学习 </p>
</font></p>]]></content>
      <categories>
        <category>move</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>move 课程笔记</title>
    <url>/2024/07/12/%E5%8C%BA%E5%9D%97%E9%93%BE/move%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://github.com/aptos-labs/aptos-core/">https://github.com/aptos-labs/aptos-core/</a></p>
</blockquote>
<blockquote>
<p>github代码参考：<a href="https://github.com/aptos-labs/aptos-core/">https://github.com/aptos-labs/aptos-core/</a></p>
</blockquote>
<h2 id="模块交互与发布"><a href="#模块交互与发布" class="headerlink" title="模块交互与发布"></a>模块交互与发布</h2><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>生成账户地址：aptos init</p>
<p>领水：aptos account fund-with-faucet –account de fault </p>
<p>编译：aptos move compile</p>
<p>测试:  aptos move test</p>
<p>发布：aptos move publish</p>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>Aptos 区块链浏览器:<a href="https://explorer.aptoslabs.com/">https://explorer.aptoslabs.com/</a></p>
<p>生成的<code>sender</code>来搜索（记得切换对应网络）</p>
<p>点击 Modules-run 实施交互，进行基本调试</p>
<h2 id="Vector-向量解析"><a href="#Vector-向量解析" class="headerlink" title="Vector 向量解析"></a>Vector 向量解析</h2><p>特性：vector 可以理解为其他语言的数组</p>
<h3 id="查询功能"><a href="#查询功能" class="headerlink" title="查询功能"></a>查询功能</h3><table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>vector::is_empty<T>(): bool</T></td>
<td>查询是否是空数组</td>
</tr>
<tr>
<td>vector::length<T>(v: &amp;vector<T>): u64</T></T></td>
<td>查询数组长度</td>
</tr>
<tr>
<td>vector::borrow<T>(v: &amp;vector<T>, i: u64): &amp;T</T></T></td>
<td>返回数组第n项的数据</td>
</tr>
<tr>
<td>vector::borrow_mut<T>(v: &amp;mut vector<T>, i: u64): &amp;mut T</T></T></td>
<td>返回数组第n项的可变引用</td>
</tr>
<tr>
<td>vector::contains<T>(v: &amp;vector<T>, e: &amp;T): bool</T></T></td>
<td>如果元素e在数组中，则返回true</td>
</tr>
<tr>
<td>vector::index_of<T>(v: &amp;vector<T>, e: &amp;T): (bool, u64)</T></T></td>
<td>如果元素e在数组中，则返回true和索引位置</td>
</tr>
</tbody></table>
<h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><table>
<thead>
<tr>
<th><strong>语法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>vector::push_back<T>(v: &amp;mut vector<T>, t: T)</T></T></td>
<td>添加尾部1个元素</td>
</tr>
<tr>
<td>vector::append<T>(v1: &amp;mut vector<T>, v2: vector<T>)</T></T></T></td>
<td>添加尾部1个数组</td>
</tr>
<tr>
<td>vector::reverse_append<T>(lhs: &amp;mut vector<T>, other: vector<T>)</T></T></T></td>
<td>添加尾部1个数组，并进行排序</td>
</tr>
<tr>
<td>vector::pop_back<T>(v: &amp;mut vector<T>): T</T></T></td>
<td>删掉尾部1个元素</td>
</tr>
<tr>
<td>vector::destroy_empty<T>(v: vector<T>)</T></T></td>
<td>删除数组</td>
</tr>
<tr>
<td>vector::swap<T>(v: &amp;mut vector<T>, i: u64, j: u64)</T></T></td>
<td>交换数组中两个元素的位置</td>
</tr>
<tr>
<td>vector::reverse<T>(v: &amp;mut vector<T>)</T></T></td>
<td>反转数组中元素的顺序</td>
</tr>
<tr>
<td>vector::insert<T>(v: &amp;mut vector<T>, i: u64, e: T)</T></T></td>
<td>在长度为i-1处插入一个元素</td>
</tr>
<tr>
<td>vector::remove<T>(v: &amp;mut vector<T>, i: u64): T</T></T></td>
<td>删除索引为i处的元素</td>
</tr>
</tbody></table>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">module 0x42::lesson4&#123;<br>    use std::debug;<br>    use std::vector;<br>//create a vector of u64<br>    const ARR:vector&lt;u64&gt; = vector[1,2,3,4,5,6];<br><br>    #[test]<br>    fun test_vector()&#123;<br>        debug::print(&amp;ARR);<br>    &#125;<br><br>    #[test]<br>    fun test_empty_vector()&#123;<br>        let bools:bool = vector::is_empty(&amp;ARR);<br>        debug::print(&amp;bools);<br><br>    &#125;<br>    #[test]<br>    fun test_vector_length()&#123;<br>        let len:u64 = vector::length(&amp;ARR);<br>        debug::print(&amp;len);<br>    &#125;<br><br>    #[test]<br>    fun test_vector_borrow()&#123;<br>        let val = vector::borrow(&amp;ARR,3);<br>        debug::print(val);<br>    &#125;<br>    <br>    #[test]<br>    fun test_vector_borrow_mut()&#123;<br>        //change vector value<br>        let arr:vector&lt;u64&gt; = vector[1,2,3,4,5];<br>        let val = vector::borrow_mut(&amp;mut arr,3);<br>        *val = 100;<br>        debug::print(&amp;arr); <br>    &#125;<br>    #[test]<br>    fun test_vector_contains()&#123;<br>        let n2:u64 = 11;<br>        let n:u64 = 3;<br>        let bools:bool = vector::contains(&amp;ARR,&amp;n);<br>        let bools2:bool = vector::contains(&amp;ARR,&amp;n2);<br>        debug::print(&amp;bools);<br>        debug::print(&amp;bools2);<br>    &#125;<br>    #[test]<br>    fun test_vector_index_of()&#123;<br>        let n2:u64 = 11;<br>        let n:u64 = 3;<br>        let (isIndex,index) = vector::index_of(&amp;ARR,&amp;n);<br>        let (isIndex2,index2) = vector::index_of(&amp;ARR,&amp;n2);<br>        debug::print(&amp;index);<br>        debug::print(&amp;index2);<br>        debug::print(&amp;isIndex);<br>        debug::print(&amp;isIndex2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>函数修饰符是用来赋予函数特殊能力的一组关键字。</p>
<p><strong>主要有以下几类</strong></p>
<p>可见性</p>
<ul>
<li><p>无public，私有函数，仅限module内部调用</p>
</li>
<li><p>friend (public)，模块内部函数，同包模块之间可以调用</p>
</li>
<li><p>public，模块公开函数，所有模块都可以调用</p>
</li>
</ul>
<p>全局存储引用</p>
<ul>
<li>acquires，当需要使用<code>move_from</code>、<code>borrow_global</code>、<code>borrow_global_mut</code> 访问地址下的资源的时候，需要用其修饰</li>
</ul>
<p>链下</p>
<ul>
<li><p>entry，修饰后，该方法可由链下脚本调用</p>
<h4 id="代码示例1"><a href="#代码示例1" class="headerlink" title="代码示例1"></a>代码示例1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">address 0x42&#123;<br>    module m&#123;<br>        friend 0x42::m3;<br><br>        fun f1() : u64&#123;<br>            1<br>        &#125;<br>        //public 可以被外部访问<br>        public fun f2() : u64&#123;<br>            2<br>        &#125;<br>        //外部模块无法直接调用，需要声明friend<br>        public(friend) fun f3() : u64&#123;<br>            3<br>        &#125;<br>    &#125;<br>    module m2&#123;<br>        fun f1() : u64&#123;<br>            0x42::m::f2()<br>        &#125;<br>    &#125;<br>    //view f2 f3<br>    module m3&#123;<br>        fun f1() : u64&#123;<br>            0x42::m::f3()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="代码示例2"><a href="#代码示例2" class="headerlink" title="代码示例2"></a>代码示例2</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">module 0x42::Demo&#123;<br>    use std::debug;<br>   // 每个账户在 move 中都有一个唯一的 Signer，它通常是账户的创建者或者拥有者。<br>    use std::signer;<br><br>    struct Coin has key&#123;<br>        value:u64<br>    &#125;<br>    <br>//可以被链下调用<br>    public entry fun mint(account: &amp;signer, value: u64)&#123;<br>    //将Coin移动到用户的地址中去<br>        move_to(account, Coin&#123;value&#125;);<br>    &#125;<br>    <br>    #[test(account = @0x42)]<br>    //acquires<br>    public fun test_mint(account: &amp;signer)acquires Coin&#123;<br>    <br>    //获取account的地址<br>        let addr = signer::address_of(account);<br>        mint(account, 10);<br>        <br>     //从全局资源中借用指定地址addr处的Coin类型资源，并获取其value<br>        let coin = borrow_global&lt;Coin&gt;(addr).value;<br>        debug::print(&amp;coin)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="struct-结构体"><a href="#struct-结构体" class="headerlink" title="struct 结构体"></a>struct 结构体</h2><h4 id="核心概念-1"><a href="#核心概念-1" class="headerlink" title="核心概念"></a>核心概念</h4><p>  Struct 结构体，用来存储具有结构化的数据，sturct可以相互嵌套（不能递归）可存储地址下作为资源，默认情况下，结构声明是线性且短暂的（也就是没办法引用）</p>
<ol>
<li>命名必须以大写字母开头</li>
<li>可以通过has 关键词赋与能力</li>
</ol>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>-Copy   值能够被复制<br>-Drop  值可以在作用域结束时删除<br>-Key   值可以用作全局存储操作的key，可以索引到相关结构体<br>-Store   值可以被全局存储，结合key使用，实现嵌套</p>
<p>  除struct类型外，其他的类型默认具备 store,drop,copy 的能力，sturct 最终是存储在用户的地址上（或者被销毁），不存在aptos合约里，aptos合约是一个全纯的函数（相较于Solidity）</p>
<h3 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h3><ol>
<li>对象是单个地址的资源容器，用于储存资源；</li>
<li>对象提供了一种集中式资源控制与所有权管理的方法；</li>
</ol>
<h3 id="创建并转移对象案例"><a href="#创建并转移对象案例" class="headerlink" title="创建并转移对象案例"></a>创建并转移对象案例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">module my_addr::object_playgoud&#123;<br>	use std::signer;<br>	use aptos_framework::object::&#123;self,ObjectCore&#125;;<br>	<br>	entry fun create_and_transfer(caller:&amp;signer,destination:address)&#123;<br>	//接受拥有者地址<br>	let caller_adsress = signer::address_of(caller);<br>	//绑定地址和对象<br>	let constructor_ref = object::create_object(caller_address);<br>	<br>	//Set up the object<br>    <br>    //transfer to destination<br>    //转移所有权<br>    let object = object::object_from_constructor_ref&lt;ObjectCore&gt;(<br>    &amp;constructor_ref<br>    );<br>    object::transfer(caller,object,destination);<br>	&#125;<br>	<br></code></pre></td></tr></table></figure>



<h4 id="三种对象类型"><a href="#三种对象类型" class="headerlink" title="三种对象类型"></a>三种对象类型</h4><ul>
<li>普通对象<strong>。</strong>可删除，且具有随机地址<code>object::create_object(owner_address: address)</code></li>
<li>命名对象。不可删除，通过固定的signer和特定的seed生成唯一地址的对象，1个地址只能生成1个，具有确定性地址<code>object::create_named_object(creator: &amp;signer, seed: vector&lt;u8&gt;)</code></li>
<li>粘性对象。不可删除，通过signer生成的对象，1个地址可以生成多个，具有随机地址<code>object::create_sticky_object(owner_address: address)</code></li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs move">module 0x42::demo&#123;<br>    use std::debug::print;<br>    use aptos_framework::object;<br>    use aptos_framework::object::&#123;Object, ConstructorRef, ObjectCore&#125;;<br><br>    use std::signer;<br><br>    const NAME:vector&lt;u8&gt; = b&quot;myObject&quot;;<br> //can_delet<br>    public fun createDeleteableObject(caller: &amp;signer):ConstructorRef&#123;<br>       let caller_addr = signer::address_of(caller);<br>       let obj = object::create_object(caller_addr);<br>       obj<br>    &#125;   <br><br><br>   <br>    //aptos-labs/examples<br><br>//cannt<br>   public fun createNamedObject(caller: &amp;signer):ConstructorRef&#123;<br>       let obj = object::create_named_object(caller, NAME);<br>       obj<br>    &#125;   <br>   public fun createStickyObject(caller: &amp;signer):ConstructorRef&#123;<br>        let caller_addr = signer::address_of(caller);<br>       let obj = object::create_sticky_object(caller_addr);<br>       obj<br>    &#125;   <br> #[test(caller = @0x88)]<br>    fun test2(caller: &amp;signer)&#123;<br>       let obj = createNamedObject(caller);<br>       print(&amp;obj);<br>    &#125;<br><br><br>       #[test(caller = @0x88)]<br>    fun test(caller: &amp;signer)&#123;<br>      let obj = createDeleteableObject(caller);<br>       print(&amp;obj);<br>    &#125;<br><br>      #[test(caller = @0x88)]<br>    fun test3(caller: &amp;signer)&#123;<br>      let obj = createStickyObject(caller);<br>      print(&amp;obj);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Object-配置"><a href="#Object-配置" class="headerlink" title="Object  配置"></a>Object  配置</h4><p>一旦您创建了对象，您将收到一个<code>ConstructorRef</code>可用于生成其他<code>Ref</code>s 。<code>Refs</code>可在将来用于启用&#x2F;禁用&#x2F;执行某些对象功能，例如传输资源、传输对象本身或删除对象。</p>
<ol>
<li><p>允许删除对象 ( <code>DeleteRef</code>)</p>
<p>对于使用默认方法（允许删除）创建的对象，您可以生成一个<code>DeleteRef</code>稍后可以使用的对象。这可以帮助消除混乱并获得存储退款。<code>DeleteRef</code>您不能为不可删除的对象创建。</p>
</li>
<li><p>一次性转账 ( <code>LinearTransferRef</code>)</p>
<p>此外，如果创建者想要控制所有传输，以提供一次性使用的传输功能。这可用于通过从对象创建者到接收者的一次性传输来创建“灵魂绑定”对象。必须<code>LinearTransferRef</code>由对象的所有者使用。</p>
</li>
<li><p>禁用&#x2F;切换传输 ( <code>TransferRef</code>)</p>
<p>默认情况下，所有对象都是可转让的。这可以通过 来更改，<code>TransferRef</code>来生成<code>object::generate_transfer_ref</code>。</p>
</li>
<li><p>添加可扩展性（<code>ExtendRef</code>)</p>
</li>
</ol>
<p>  将对象变成可动态配置的，可以往里面添置新的 struct 资源。生成一个<code>ExtendRef</code>和<code>object::generate_extend_ref</code>。此引用可用于为该对象生成签名者。</p>
<ol start="5">
<li><p>添加资源</p>
<p>使用<code>ConstructorRef</code>和<code>object::generate_signer</code>创建一个签名者，允许您将资源转移到对象上。这使用<code>move_to</code>，与将资源添加到帐户的功能相同</p>
</li>
</ol>
]]></content>
      <categories>
        <category>move</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Sui-学习路径</title>
    <url>/2024/07/18/%E5%8C%BA%E5%9D%97%E9%93%BE/Sui-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h1><h2 id="步骤一：前置安装"><a href="#步骤一：前置安装" class="headerlink" title="步骤一：前置安装"></a>步骤一：前置安装</h2><h3 id="安装Sui-Wallet"><a href="#安装Sui-Wallet" class="headerlink" title="安装Sui Wallet"></a>安装Sui Wallet</h3><p>采用Google插件<br><a href="https://chromewebstore.google.com/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil">https://chromewebstore.google.com/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil</a></p>
<h3 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h3><p>具体安装过程需要自行探索<br><a href="https://nodejs.org/en">https://nodejs.org/en</a>  </p>
<h3 id="安装编译器"><a href="#安装编译器" class="headerlink" title="安装编译器"></a>安装编译器</h3><p>VSCODE 和 RustRover 二选一即可</p>
<h4 id="RustRover"><a href="#RustRover" class="headerlink" title="RustRover"></a>RustRover</h4><p>RustRover的报错和提示比较友好，也有成熟的插件<br><a href="https://www.jetbrains.com.cn/rust/">https://www.jetbrains.com.cn/rust/</a></p>
<h4 id="VSCODE"><a href="#VSCODE" class="headerlink" title="VSCODE"></a>VSCODE</h4><p>容易上手，通用性强<br><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>
<h3 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h3><p><a href="https://docs.sui.io/guides/developer/getting-started/sui-install">https://docs.sui.io/guides/developer/getting-started/sui-install</a><br>建议采用从Github下载二进制文件，对小白更友好</p>
<h2 id="步骤二：基本语法学习"><a href="#步骤二：基本语法学习" class="headerlink" title="步骤二：基本语法学习"></a>步骤二：基本语法学习</h2><p><a href="https://www.bilibili.com/video/BV1Rm42177Kx/">bilibili教学视频</a> (视频包括基本语法的学习和实战演练  )<br>课程相关代码库:</p>
<ul>
<li><a href="https://github.com/404ll/letsmove/tree/main/tutorial/bootcamp">https://github.com/404ll/letsmove/tree/main/tutorial/bootcamp</a></li>
<li>Swap以及Coin的代码库 <a href="https://github.com/uvd/sui-swap-course">https://github.com/uvd/sui-swap-course</a></li>
</ul>
<p>完整入门手册，非常详细</p>
<ul>
<li><a href="https://easy.sui-book.com/">轻松入门move</a></li>
</ul>
<h2 id="步骤三：深入学习以及完成task"><a href="#步骤三：深入学习以及完成task" class="headerlink" title="步骤三：深入学习以及完成task"></a>步骤三：深入学习以及完成task</h2><p>区块链浏览器：<a href="https://suivision.xyz/">https://suivision.xyz/</a></p>
<p>由于教学视频的时间限制，手把手教学来完成每一个task基本是不现实的，同时已有的学习资料已经完全足够从入门到熟练掌握<br>因此需要学员有强大的内驱力和学习能力，从已有的文档和代码库中，寻找和学习所需的知识点  </p>
<p>基于官方标准库，可以查询和了解每一个函数的功能及使用方法</p>
<ul>
<li><a href="https://github.com/MystenLabs/sui/tree/main/crates/sui-framework">https://github.com/MystenLabs/sui/tree/main/crates/sui-framework</a></li>
</ul>
<p>探索官方文档（包括Coin协议等等）</p>
<ul>
<li><a href="https://docs.sui.io/">https://docs.sui.io</a></li>
</ul>
]]></content>
      <tags>
        <tag>sui</tag>
      </tags>
  </entry>
  <entry>
    <title>扫盲小知识之 L1 L2</title>
    <url>/2024/05/21/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%80%E4%B9%88%E6%98%AFLayer1-Layer2/</url>
    <content><![CDATA[<h1 id="什么是-Layer1-Layer2"><a href="#什么是-Layer1-Layer2" class="headerlink" title="什么是 Layer1  Layer2?"></a>什么是 Layer1  Layer2?</h1><p>Layer1是区块链的基础层，负责确认和记录交易；Layer2是用于扩容的解决方案，负责处理和记录高吞吐量的交易。</p>
<h2 id="什么是-Layer1"><a href="#什么是-Layer1" class="headerlink" title="什么是 Layer1?"></a>什么是 Layer1?</h2><p>第一层就是传统意义上的区块链，包括：比特币，以太坊，Aptos等</p>
<p>Layer1是区块链技术中的一个术语，指的是区块链协议中的基础层。它是指构成区块链网络基础架构的核心协议和数据结构，通常是一种完整的、独立的区块链网络，具有自己的共识机制和数据存储方式。Layer1协议负责处理交易验证、区块生成和链上数据存储等核心功能。</p>
<p>在Layer1层面，通常会涉及到底层的区块链技术和算法设计，如工作量证明（Proof of Work）或权益证明（Proof of Stake）等共识机制，以及区块链的数据结构、加密算法等。Layer1协议的设计决定了整个区块链网络的性能、安全性和去中心化程度。</p>
<h2 id="什么是-Layer2"><a href="#什么是-Layer2" class="headerlink" title="什么是 Layer2?"></a>什么是 Layer2?</h2><blockquote>
<p>本文只提供粗浅的定义，若想进一步了解，可以看看<a href="https://blog.chain.link/what-is-a-layer-2-zh/">一文读懂第 2 层</a> 🌟</p>
</blockquote>
<p>Layer 2的目的是通过在区块链之上引入额外的协议或机制，提供更高的吞吐量、低延迟和更便宜的交易，并解决Layer 1网络可能存在的扩展性和性能问题。</p>
<p>Layer 2解决方案通常可以分为两种主要类型：</p>
<ol>
<li><strong>状态通道（State Channels）</strong>：状态通道是一种通过在链外执行交易并最终将交易结果提交到区块链上的解决方案。在状态通道中，参与者可以直接在彼此之间进行多次交易，而不必在每次交易都提交到区块链上进行确认，从而大大提高了交易的速度和吞吐量。</li>
<li><strong>侧链（Sidechains）</strong>：侧链是与主区块链相互连接的独立区块链，可以处理与主链不同的交易逻辑和数据。通过侧链，用户可以将资产从主链转移到侧链上进行高速和低成本的交易，然后再将结果汇总提交到主链上，从而减轻了主链的负担，提高了整个系统的性能。</li>
</ol>
<p>有关扩容方案的文章 </p>
<p>[]: <a href="https://mp.weixin.qq.com/s?__biz=MzUyNzE4MDM2MA==&amp;mid=2247500009&amp;idx=2&amp;sn=aa68710cd3eb1758dff8776bbc1be70e&amp;chksm=fa01f7cecd767ed86a724a284233cca3cc0aec84d0a99ef126392305dd20f5c99976d37e6d27#rd">https://mp.weixin.qq.com/s?__biz=MzUyNzE4MDM2MA==&amp;mid=2247500009&amp;idx=2&amp;sn=aa68710cd3eb1758dff8776bbc1be70e&amp;chksm=fa01f7cecd767ed86a724a284233cca3cc0aec84d0a99ef126392305dd20f5c99976d37e6d27#rd</a>	“一文看懂区块链的扩容方案和主要的二层网络（Layer 2）方案”</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL入门学习笔记</title>
    <url>/2024/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/MYSQL%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习视频链接</p>
<ul>
<li></li>
</ul>
<hr>
<h1 id="MYSQL入门学习笔记"><a href="#MYSQL入门学习笔记" class="headerlink" title="MYSQL入门学习笔记"></a>MYSQL入门学习笔记</h1><p>关联式数据库 &#x3D;&gt; tables and keys</p>
<p>**primary key (主键)**：可以唯一区分资料</p>
<p>:heavy_exclamation_mark:当有重复时，可以设定多个主键来唯一区分资料</p>
<p>**foreign key(外键)**：实现table的互相关联(也可以和自己关联)    </p>
<p> :heavy_exclamation_mark:但是只能关联table的主键</p>
<blockquote>
<p>可以将一个属性同时设定为不同table的主键和外键</p>
</blockquote>
<h2 id="SQL基础语法"><a href="#SQL基础语法" class="headerlink" title="SQL基础语法"></a>SQL基础语法</h2><p> :heavy_exclamation_mark:  后文中的” &lt;&gt; “ 代表 “ &#96; “，同时SQL中遵循属性名用  &#96;&#96;包裹，值用 ‘’ 或者 “” 包裹的潜规则</p>
<h3 id="数据库相关操作"><a href="#数据库相关操作" class="headerlink" title="数据库相关操作"></a>数据库相关操作</h3><p>创建数据库 <code>CREATE DATABASE  &lt;name&gt; </code>；</p>
<p>展示数据库 <code>SHOW DATABASES;</code></p>
<p>关键字用大写，命名用&#96;&#96;包裹</p>
<p>删除数据库 <code>DROP DATABASE &lt;db_name&gt;;</code></p>
<h3 id="数据库常见类型"><a href="#数据库常见类型" class="headerlink" title="数据库常见类型"></a>数据库常见类型</h3><ul>
<li><p>INT    –整数</p>
</li>
<li><p>DECYMAL(m,n)    –有小数点的数，m&#x3D;几个数字，n&#x3D;几个小数</p>
</li>
<li><p>VARCHAR(n)    –字串，n&#x3D;最多可以容纳几个字</p>
</li>
<li><p>BLOB    –(Binary Large Object) 图片 影片 档案等二进制资料</p>
</li>
<li><p>DATE    –’YYYY-MM-DD’ 记录日期</p>
</li>
<li><p>TIMESTAMP    –’YYYY-MM-DD HH:MM:SS’ 记录时间</p>
</li>
</ul>
<h3 id="表格操作"><a href="#表格操作" class="headerlink" title="表格操作"></a>表格操作</h3><p>选择数据库 <code>USE &lt;db_name&gt;; </code></p>
<p>创建表格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>table_name<span class="hljs-operator">&gt;</span>(<br>    `属性名<span class="hljs-number">1</span>` 类型 限制类型,<br>    `属性名<span class="hljs-number">2</span>` 类型 限制类型<br>);<br></code></pre></td></tr></table></figure>

<p>删除表格 <code>DROP TABLE &lt;table_name&gt;;</code></p>
<p>新增属性 <code>ALTER TABLE &lt;name&gt; ADD &lt;属性名&gt; 类型;</code></p>
<p>删除属性 <code>ALTER TABLE &lt;name&gt; DROP &lt;属性名&gt; 类型;</code></p>
<p>查看表格属性 <code>DECRIBE &lt;table_name&gt;;</code></p>
<p>加入内容 <code>INSERT INTO &lt;table_name&gt; VALUES(属性1-内容,属性2-内容);</code></p>
<p>查找表格 <code>SELECT * FROM &lt;table_name&gt;;</code> 此条命令为查找当前数据库内所有名为table_name的表格，并完全展示出来</p>
<h4 id="限制和限制的类型"><a href="#限制和限制的类型" class="headerlink" title="限制和限制的类型"></a>限制和限制的类型</h4><ul>
<li>UNIQUE    –不允许重名</li>
<li>AUTO_INCREMENT    –增加内容时自动加一，无需手动填写 （用于序号）</li>
<li>DEFAULT    –预设值，不填写内容时，按照预设的填写</li>
</ul>
<h4 id="修改资料"><a href="#修改资料" class="headerlink" title="修改资料"></a>修改资料</h4><p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> `table_name`<br><span class="hljs-keyword">SET</span> `属性名` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;目标值&#x27;</span>;<br><span class="hljs-keyword">WHERE</span> 条件 (可以不写);<br></code></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> `student`<br><span class="hljs-keyword">SET</span> `major` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;历史&#x27;</span>;<br><span class="hljs-keyword">WHERE</span> `major` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;生物&#x27;</span> <span class="hljs-keyword">OR</span> `major` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;物理&#x27;</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将major为生物和物理的值，更新为历史<br></code></pre></td></tr></table></figure>



<h4 id="删除资料"><a href="#删除资料" class="headerlink" title="删除资料"></a>删除资料</h4><p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> `table_name`<br><span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> `student`<br><span class="hljs-keyword">WHERE</span> `score` <span class="hljs-operator">&gt;</span> <span class="hljs-number">60</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除 score小于<span class="hljs-number">60</span>的方式<br></code></pre></td></tr></table></figure>

<p><em>不写WHERE语句时，代表删除表格的所有资料</em></p>
<h4 id="搜寻资料"><a href="#搜寻资料" class="headerlink" title="搜寻资料"></a>搜寻资料</h4><p><code>SELECT * FROM &lt;table_name&gt;;</code>  &#x3D;&gt; <code>*</code> 代表取得所有属性的意思</p>
<p><code>SELECT * FROM &lt;table_name&gt; LIMIT n;</code> &#x3D;&gt; 仅仅显示前 n 笔资料</p>
<p><code>SELECT * FROM &lt;table_name&gt; WHERE &lt;属性名&gt; ;</code>  &#x3D;&gt; 仅仅显示属性名为属性1的内容</p>
<p><em>WHERE &lt;属性名&gt; IN (‘1’,’2’)  &#x3D; WHERE &lt;属性名&gt; &#x3D; ‘1’ OR &lt;属性名&gt; &#x3D; ‘2’</em>  </p>
<p><code>SELECT &lt;属性1&gt; FROM &lt;table_name&gt;;</code> &#x3D;&gt;  代表取得属性名为属性1的内容，取得多个属性的时候用  <code>,</code> 隔开</p>
<p><code>SELECT DISTINCT &lt;属性1&gt; FROM &lt;table_name&gt;;</code> &#x3D;&gt;去掉重复属性</p>
<p><code>SELECT * FROM &lt;table_name&gt; ORDER BY  &lt;属性1&gt; DESC;</code> &#x3D;&gt;以属性1来排序表格</p>
<blockquote>
<p><code>DESC</code> 表示由高到低排序；不写时默认为<code>ASC</code>，代表由低到高排序</p>
</blockquote>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> `student`<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `score`,`student_id`<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>排序时，优先以score对表格内容进行从低到高的排序；当score相同时，以student_id作为基准排序<br></code></pre></td></tr></table></figure>

<blockquote>
<p>:heavy_exclamation_mark: 各种语句的条件可以混用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-operator">&gt;</span><span class="hljs-keyword">FROM</span> `student`<br><span class="hljs-operator">&gt;</span><span class="hljs-keyword">WHERE</span> `major` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;英语&#x27;</span> <span class="hljs-keyword">OR</span> `score` <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">70</span><br><span class="hljs-operator">&gt;</span>LIMIT <span class="hljs-number">2</span>;<br><span class="hljs-operator">&gt;</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>回传major为英语和score不等于<span class="hljs-number">70</span>的前两个数据<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>增加外键</strong> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>将table2的对应属性名，设置为table1的外键<br><span class="hljs-keyword">FOREIGN</span> KEY(`table1`)<br><span class="hljs-keyword">REFERENCES</span> `table2`(`table2对应属性名`)<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>ON DELETE CASCADE 是当“table2对应属性名”被删除后，将table1中对应的值删掉</p>
<p>ON DELETE SET NULL 是当“table2对应属性名”被删除后，将table1中对应的值设置为NULL</p>
<p>当该键为其他表的主键时，不可以使用 ON DELETE SET NULL</p>
</blockquote>
<p><strong>基本逻辑</strong></p>
<p>新建表格时，先创建各个表格，再添加外键的关联</p>
<p>增加资料时，先增加外键所在的表格的资料，再增加自己表格的资料</p>
<h3 id="聚合函数-aggregate-functions"><a href="#聚合函数-aggregate-functions" class="headerlink" title="聚合函数 (aggregate functions)"></a>聚合函数 (aggregate functions)</h3><p>取得成员数   </p>
<ul>
<li><code>SELECT COUNT(&lt;属性名&gt;) FROM  &lt;table_name&gt;;</code></li>
<li><code>SELECT COUNT(*) FROM  &lt;table_name&gt;;</code></li>
</ul>
<p>在限制条件下取数 示例</p>
<ul>
<li><pre><code class="sql">SELECT COUNT(*) 
FROM  `employee`
WHERE `birth_date` &gt; &#39;1980-01-02&#39; AND `sex` = &#39;F&#39;;
//在employee表中取得birth_date 大于1980-01-02的女性
</code></pre>
</li>
</ul>
<p>取得员工的平均薪水 示例</p>
<ul>
<li>​	<code>SELECT AVG (&lt;salary&gt;) FROM &lt;employee&gt;;</code></li>
</ul>
<p>取得所有员工的薪水总和 示例</p>
<ul>
<li><code>SELECT SUM(&lt;salary&gt;) FROM &lt;employee&gt;;</code></li>
</ul>
<p>取得最高薪水</p>
<ul>
<li><code>SELECT MAX(&lt;salary&gt;) FROM &lt;employee&gt;;</code></li>
</ul>
<p>取得最低薪水</p>
<ul>
<li><code>SELECT MIN(&lt;salary&gt;) FROM &lt;employee&gt;;</code></li>
</ul>
<h3 id="万用字元-wildcards"><a href="#万用字元-wildcards" class="headerlink" title="万用字元 wildcards"></a>万用字元 wildcards</h3><p><strong>% 代表多个字元，_代表一个字元</strong></p>
<p>取得电话号码是335连续的客户</p>
<ul>
<li><code>SELECT * FROM &lt;cient&gt; WHERE &lt;phone&gt; LIKE &#39;%335%&#39;;</code></li>
</ul>
<p>取得姓艾的客户</p>
<ul>
<li><code>SELECT *FROM &lt;client&gt; WHERE &lt;phone&gt; LIKE &#39;艾%&#39;;</code></li>
</ul>
<p>取得生日在12月的员工 生日格式YYYY-MM-DD</p>
<ul>
<li><code>SELECT * FROM &lt;employee&gt; WHERE &lt;birth_data&gt; LIKE &#39;_________12%&#39;;	</code></li>
</ul>
<h3 id="union-连接搜寻结果"><a href="#union-连接搜寻结果" class="headerlink" title="union 连接搜寻结果"></a>union 连接搜寻结果</h3><p>:heavy_exclamation_mark:  <strong>连接的属性数目和资料类型必须相同</strong></p>
<p>员工名字 连接 客户名字</p>
<ul>
<li><pre><code class="sql">SELECT &lt;name&gt; FROM &lt;employee&gt;
UNION
SELECT &lt;client_name&gt; FROM &lt;client&gt;;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>员工id+员工名字 连接 客户id+客户名字<br><br>- ```sql<br>  SELECT &lt;employee_id&gt;,&lt;name&gt; <br>  FROM &lt;employee&gt;<br>  UNION<br>  SELECT &lt;client_id&gt;,&lt;client_name&gt; <br>  FROM &lt;client&gt;;<br>  <br>  //改名<br>  SELECT &lt;employee_id&gt; AS &lt;total_id&gt;,&lt;name&gt; AS &lt;total_name&gt;<br>  FROM &lt;employee&gt;<br>  UNION<br>  SELECT &lt;client_id&gt;,&lt;client_name&gt; <br>  FROM &lt;client&gt;;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="Join-连接表格"><a href="#Join-连接表格" class="headerlink" title="Join 连接表格"></a>Join 连接表格</h3><p>取得所有部门经理的资料 </p>
<ul>
<li><pre><code class="sql">//返回结果包含两个表格的所有属性
SELECT * 
FROM &lt;employee&gt; 
JOIN &lt;branch&gt; 
ON &lt;emp_id&gt; = &lt;manager_id&gt; //条件
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>- ```sql <br>  //返回结果只包含选中的属性<br>  SELECT &lt;emp_id&gt;,&lt;branch_name&gt;,&lt;name&gt; <br>  FROM &lt;employee&gt; <br>  JOIN &lt;branch&gt; <br>  ON &lt;emp_id&gt; = &lt;manager_id&gt;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<blockquote>
<p>可以用<code>&lt;table_name&gt;.&lt;属性名&gt;</code> 来区分不同表格的相同属性名</p>
</blockquote>
<h4 id="left-关键字"><a href="#left-关键字" class="headerlink" title="left 关键字"></a>left 关键字</h4><p>不管条件是否成立，都会将JOIN左边的表格属性全部回传；右边的表格没有对应的属性时，就填写NULL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>employee<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-operator">&lt;</span>branch<span class="hljs-operator">&gt;</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>emp_id<span class="hljs-operator">&gt;</span> <span class="hljs-operator">=</span> <span class="hljs-operator">&lt;</span>manager_id<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="right-关键字"><a href="#right-关键字" class="headerlink" title="right 关键字"></a>right 关键字</h4><p>和left正好相反，不在此赘述</p>
<h3 id="subquery-子查询"><a href="#subquery-子查询" class="headerlink" title="subquery 子查询"></a>subquery 子查询</h3><p>在一个查询语句中插入另外一个查询语句，对前一个查询的结果进行查询</p>
<p>示例  找出研发部门的经理名字</p>
<ul>
<li><pre><code class="sql">//从员工标准中查找其名字
SELECT `name`
FROM `employee`
WHERE `emp_id` = (
    //得到 研发部门经理的id
    SELECT `manager_id`
    FROM `branch`
    WHERE `branch_name` = `研发`
);
</code></pre>
</li>
</ul>
<p><em>把 WHERE 后的第一个”&#x3D;” 换为IN，可用于多个查询结果</em></p>
]]></content>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>http学习笔记</title>
    <url>/2024/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/http%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="HTTP学习笔记"><a href="#HTTP学习笔记" class="headerlink" title="HTTP学习笔记"></a>HTTP学习笔记</h1><blockquote>
<p>推荐教程：<a href="https://juejin.cn/post/6844903673680789517">https://juejin.cn/post/6844903673680789517</a></p>
</blockquote>
<p>HTTP全称 <strong>超文本传输协议</strong>（HyperText Transfer Protocol），是一种用于在网络上进行数据传输的协议，可以通俗理解为 这是电脑与电脑之间的沟通方式，主要用于网页上。</p>
<h2 id="HTTP的组成和基本概念"><a href="#HTTP的组成和基本概念" class="headerlink" title="HTTP的组成和基本概念"></a><strong>HTTP的组成和基本概念</strong></h2><ul>
<li><strong>客户端和服务器</strong>：HTTP 通常工作在客户端（如网页浏览器）和服务器之间。客户端向服务器发送请求，服务器处理请求并返回响应。</li>
<li><strong>请求和响应</strong>：HTTP 的工作方式基于请求-响应模型。客户端发送一个请求（包括请求行、请求头和请求体），服务器处理请求并返回一个响应（包括状态行、响应头和响应体）。</li>
</ul>
<p><strong>示例：</strong><a href="http://www.google.com/">http://www.google.com</a>  </p>
<p><code>http</code>定义了选择的协议方式    <code>www.google.com  </code> 则对应需要访问的ip地址</p>
<p><em>ip地址可以理解为每个人的家庭住址</em></p>
<p><strong>过程</strong>：当我们在浏览器上输入一段网址后，浏览器就会发送请求到服务器，服务器接受请求后回传数据，这个数据经过电脑处理后就会返回我们通常看到的网页。</p>
<blockquote>
<p>❗️ 并不是只有网址才会触发请求</p>
<p>例如在购物平台购物时，当点击<code>购物</code>按钮时，就已经隐匿地向服务器发送了请求，此时架构是在应用中实现</p>
</blockquote>
<h2 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a><strong>HTTP 方法</strong></h2><p>HTTP 定义了一些常见的方法来执行不同的操作，包括：</p>
<ul>
<li><strong>GET</strong>：获取资料，通常用于从服务器获取数据。</li>
<li><strong>POST</strong>：上传资料，用于创建或更新资源。</li>
<li><strong>PUT</strong>：更新指定的资源。</li>
<li><strong>DELETE</strong>：删除指定的资源。</li>
<li><strong>PATCH：</strong>覆盖资料</li>
</ul>
<p>:star: 区别GET和POST方法：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td><strong>目的</strong></td>
<td>从服务器获取数据或资源</td>
<td>向服务器提交数据以处理或存储</td>
</tr>
<tr>
<td><strong>数据位置</strong></td>
<td>数据附加在 URL 的查询字符串中</td>
<td>数据放在请求体（Body）中</td>
</tr>
<tr>
<td><strong>数据量</strong></td>
<td>数据量有限，受 URL 长度限制</td>
<td>数据量没有严格限制，可以传输大量数据</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>数据暴露在 URL 中，相对不安全</td>
<td>数据不暴露在 URL 中，相对较安全</td>
</tr>
<tr>
<td><strong>缓存</strong></td>
<td>请求可以被缓存</td>
<td>请求一般不被缓存</td>
</tr>
<tr>
<td><strong>书签</strong></td>
<td>URL 可以被书签保存</td>
<td>URL 不适合直接书签</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>获取资源或数据，如读取页面或搜索内容</td>
<td>提交表单、上传文件、修改或创建资源</td>
</tr>
<tr>
<td><strong>示例请求</strong></td>
<td><code>GET /page?name=value</code></td>
<td><code>POST /submit</code> <br> <code>Content-Type: application/x-www-form-urlencoded</code> <br> <code>name=John&amp;age=30</code></td>
</tr>
</tbody></table>
<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a><strong>HTTP报文</strong></h2><p>报文就是客户端和服务器之间沟通所需要遵循的格式</p>
<ul>
<li><p><strong>请求结构</strong>：</p>
<ul>
<li><p><strong>请求行</strong>：包含请求方法（如 GET、POST）、请求目标（如 URL）和 HTTP 版本。</p>
</li>
<li><p><strong>请求头</strong>：包括客户端环境的信息，如浏览器类型、语言等。</p>
</li>
<li><p><strong>请求体</strong>：包含需要发送给服务器的数据。</p>
</li>
</ul>
<p>:star2:<strong>示例</strong>：<a href="http://api/shop.com/card">http://api/shop.com/card</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">POST /card HTTP/1.1  *请求行<br>---<br>Host:api.shop.com  *传送的目标地址与请求行组合成网址<br>User-Agent:Mozila/5.0(windows...)Chrome  *请求的发送地址<br>Accept:text/plain  *可接受的回传档案类型<br>Content-Type:text/plain  *传送的档案类型<br>Con-Length:43  *内容长度<br>---<br>&#123;&quot;card&quot;:1234567890.&quot;total_price&quot;:8787&#125;  *内容=&gt;可以推断为刷卡的请求<br></code></pre></td></tr></table></figure>


</li>
<li><p><strong>响应</strong>结构：</p>
<ul>
<li><strong>状态行</strong>：包含 HTTP 版本、状态码（如 200、404）和状态消息。</li>
<li><strong>响应头</strong>：包含服务器的信息和响应的元数据，如内容类型、长度等。</li>
<li><strong>响应体</strong>：实际返回给客户端的数据，如网页内容、图片等。</li>
</ul>
<p>:star2:<strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HTTP/1.1 200 OK<br>---<br>Server:nginx  *服务器软体类型<br>Content-Type:text/plain  *回传信息的类型<br>Content-Length:7  *回传信息的长度<br>Date:Fri,27 Aug 2021 20:09:07 GMT  *回传回去的时间<br>---<br>success<br></code></pre></td></tr></table></figure></li>
</ul>
<p>:eyes:因此我们可以将请求和相应简单理解为两个人在相互写信，当然写信是需要遵循信的格式的 !</p>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a><strong>HTTP 状态码</strong></h2><p>HTTP 状态码用于表示请求的结果，常见的状态码包括：</p>
<ul>
<li><strong>200 OK</strong>：请求成功，服务器返回请求的数据。</li>
<li><strong>201 Creat</strong>: 创建成功</li>
<li><strong>301 Moved Permanently</strong>：请求的资源已被永久移动到新位置。</li>
<li><strong>400 Bad Request</strong>: 发送的格式错误力</li>
<li><strong>401 Unauthorized</strong>：请求的资源比较敏感，需要验证</li>
<li><strong>403 Forbidden</strong>: 验证身份不合格</li>
<li><strong>404 Not Found</strong>：请求的资源未找到。</li>
<li><strong>500 Internal Server Error</strong>：服务器内部错误，无法完成请求。</li>
</ul>
<h2 id="HTTP与HTTPS的主要区别"><a href="#HTTP与HTTPS的主要区别" class="headerlink" title="HTTP与HTTPS的主要区别"></a><strong>HTTP与HTTPS的主要区别</strong></h2><ul>
<li><strong>HTTP</strong> 是明文传输的，传送的资料都可以被看见，这意味着数据在传输过程中可能被第三方窃听或篡改，非常的不安全。</li>
<li><strong>HTTPS</strong>（HyperText Transfer Protocol Secure超文本传输安全协议）是在 HTTP 的基础上加上了 <strong>SSL&#x2F;TLS</strong> 加密层，提供了加密和安全性，保护数据在传输过程中不被窃取或篡改，比较安全，也是目前的主要传输方式。</li>
</ul>
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链概述</title>
    <url>/2024/07/31/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%A6%82%E8%BF%B0/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="区块链概述"><a href="#区块链概述" class="headerlink" title="区块链概述"></a>区块链概述</h1><h2 id="互联网的发展趋势"><a href="#互联网的发展趋势" class="headerlink" title="互联网的发展趋势"></a>互联网的发展趋势</h2><p>互联网经历了2个阶段：</p>
<ul>
<li><p>Web1.0<br>起初的互联网只提供  “读”，数据流向是单向的，也就是只有输入没有输出</p>
</li>
<li><p>Web2.0<br>也正是目前的主流互联网，它 提供 “读” “写”的功能，但是用户没办法拥有自己的数据，即“谁存储谁拥有”并非“谁创造谁拥有”。</p>
</li>
<li><p>Web3.0<br>目标是创建一个用户 “可读、可写、可拥有信息”的世界，用户可以将自己的信息掌握在自己的手中</p>
</li>
</ul>
<h2 id="为什么需要Web3？"><a href="#为什么需要Web3？" class="headerlink" title="为什么需要Web3？"></a>为什么需要Web3？</h2><p>这里需要提及两个概念&#x3D;&gt; 中心化和去中心化</p>
<hr>
<h3 id="中心化"><a href="#中心化" class="headerlink" title="中心化"></a>中心化</h3><p>概念：在中心化系统中，通常有一个或少数几个主要的决策者或实体负责管理和控制系统的运作和资源分配。</p>
<p>我们现在就处在一个中心化的社会之中，举最简单的例子来说：买房子有中介、在短视频平台上发布视频的收益需要分成给平台，这些<strong>并非用户与用户之间的直接接触，需要第三方的参与</strong>，除此之外，大家应该都经历过，在某个平台上填写了个人信息之后，就骚扰电话和垃圾信息不断，个人隐私问题难以得到保证。</p>
<p>中心化系统带来这些挑战：单点故障、信任问题、透明度不足以及对个人权利和隐私的侵犯。</p>
<h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><p>概念：去中心化将权力、控制或决策权分散到多个节点或参与者之间，而不是集中在单一的中心化实体或个体手中，简单理解就是，去除中介。</p>
<p>去中心化通过这样的手段来解决中心化带来的问题，实现了安全性的增强、公平的权力分配、更高的透明度和抗审查等能力。</p>
<hr>
<blockquote>
<p>很多东西不是非黑即白的，因此中心化不是绝对的错，去中心化也不是绝对的好，大部分前辈们所奋斗的方向也只是在中心化没做好的地方进行改革，希望理性看待这些问题。</p>
</blockquote>
<p>去中心化引发了许多新技术产生，其中最引人注目的便是区块链技术</p>
<h2 id="Web3的新技术-区块链"><a href="#Web3的新技术-区块链" class="headerlink" title="Web3的新技术 - 区块链"></a>Web3的新技术 - 区块链</h2><p>区块链通过一定的技术手段 ，实现了 “去中心化、可溯源、不可篡改”的特点，成为一个分布式的账本模型，在此之中，所有参与者共享同一个数据账本，每个参与者都可以查看完整的交易记录。</p>
<p>根据使用权限、治理结构和应用范围等多个维度将区块链进行分类，可以分为以下几类：</p>
<ol>
<li><strong>公链（Public Blockchain）</strong>：<ul>
<li>公链是一种开放的区块链网络，任何人都可以加入和参与其中，查看数据、验证交易，并可以自由创建和验证交易。典型的公链包括比特币（Bitcoin）和以太坊（Ethereum）等。</li>
</ul>
</li>
<li><strong>私链（Private Blockchain）</strong>：<ul>
<li>私链是一种受限制的区块链网络，参与者必须获得许可才能加入，通常由单个实体或组织管理和控制。私链可以提供更高的性能和隐私保护，常见于企业内部或特定联盟中。</li>
</ul>
</li>
<li><strong>联盟链（Consortium Blockchain）</strong>：<ul>
<li>联盟链是一种由多个组织或实体共同管理的区块链网络，参与者必须获得许可才能加入，但参与者之间有明确的信任关系。联盟链通常用于跨组织间的合作和数据共享。</li>
</ul>
</li>
</ol>
<p>现在的区块链仍然处于探索和发展的初期阶段，正需要新鲜血液来创新和参与，区块链世界欢迎你们-未来的开拓者。</p>
]]></content>
  </entry>
</search>
